>大阪さん
おつかれさまです。現在の進行のタスクと直接は関係ないですが、現状、進化合成の確認画面で進化結果の馬をクリックすると、継承されるはずのスピードやスタミナのプラス値が全て一律ゼロになって表示されています。
今までこちら不注意で気づきませんでしたが、他の限界突破値やスキルレベル値はちゃんと継承された値で表示されているので、今回の2.9の進化画面遷移の変更に合わせて修正しようと思っています。この点につきまして、特に問題がないかの判断をお願いしたいと思います。

まず考えられる一番の原因としては、スクリプトの単純な実装抜け。それなら話しが早い、というかそれしか考えられない気がしてきた。
いくらインスペター見ても、ﾋｴﾗﾙｷｰの階層関係見ても、一向に問題が見つからないだから、だとしたら、もうスクリプトが問題ということで決定なのでは

>大阪さん
たびたび失礼します。念のための確認なのですが、現在の進化確認画面では、進化先の馬ｄｓｆが過去に一度も所有したことのない場合、基本的には？で表示されていると思います。しかし究極進化と転生進化の場合、一度も入手したことがなくても、進化結果の馬の画像が表示されている状態になっています。（タッチすることで詳細も出ます）
今回新しく作る画面でも同様に、過去に所有したことのない馬は、通常進化の場合？で表示して、究極進化と転生進化の場合は、所有したことがなくても進化結果となる馬を表示する方向で問題ないでしょうか？お手数ですがよろしくお願いします。

エラーの状況を考えてみようか
まず表示切替のボタンの異状だよなここで異状になるせいで何かがおかしくなる
まあその可能性が一番たかい、というかそれ以外思いつかない

>大阪さん
了解しました、そのように修正します。


おそらくだけど、EvolutionBaseHorseではに
たぶんＨｏｒｓｅＬｉｓｔかHorseListManageBase
うーん多分後者だと思うけどなあ
ＨｏｒｓｅＬｉｓｔかああああああああああああああああ


ちょっとHorseListのＣｒｅａｔｅのとこみてくか
ここがおそらく真相に近い

    this.horseDatas = new List<NwDataUserHorse>( horseDatas );
これで内部的には所持している全馬だしてるよな
の後に馬のステータスを一部設定
  // 現在の状態を保存しておく一覧を作成(使用中なのか、お気に入りなのかなど)
  // リスト作成時、最初の1回だけ呼ばれる。
  private void CreateStatusList()


あああああなんかHorseListのＣｒｅａｔｅＬｉｓｔｇがあやしいですねえ
うーんどうやらCreateListのなかのCreateListItemでアイコンつくってるみたいね
ちな両方ともスクリプトはHorseLise

うーんなんかHorseListのfilterＨｏｒｓｒｅつかえば解決しそうな雰囲気はあるな

うーーんFileterHorseのなかのInHorseIVisibleがよくあわからんあu
nn
?
public delegate bool HorseFilter(NwDataUserHorse horse);

このＨｏｒｓｅＦｉｌｔｅｒのくせものだよな

はあもうわからん、
ＥｖｏｌｕｔｉｏｎＭａｉｎのCreateでHorseListManagBaseは呼び出されているね
ＨｏｒｓｅＦｉｌｔｅｒ自体はHorserListManageBaseでつくられているデリゲートである
このdeligateに

さて問題はこのfilter昨日を使うべきかどうか、もうこの複雑な勉強の子と考えると使わないほうがいい気がしてきた
いっそ、もう、NwUserDataHorseに独自の関数突っ込んじまうか

しかしHorseListFilterってフィルターをhourListのCreateするときにわたしてるけど、見る場見るほど意味分からん穴
第二引数で渡しているのが horseSort.GetHorseFilters()
しかしその先に飛んで実ｒｊと  
public List<List<HorseFilter>> GetHorseFilters() { return temporaryFilters ?? horseFilters; }　という意味の分からん式
なんだこの??ってのは
お、発見
	x && y	「論理演算子」（短絡評価）
x || y	「論理演算子」（短絡評価）
x ?? y	「null 合体演算子」
x ? y : z	「条件演算子」
 
?? 演算子は、null 合体演算子と呼ばれます。左側のオペランドが null 値でない場合には左側のオペランドを返し、null 値である場合には右側のオペランドを返します。

はえー便利

まあでもさ、できるならFilterつか憂いよな、しかし現状用意されているFIlterの使い方が分からな以上、やはり使わないほういいのではないかと思う

んんCreateListItemの中身手も一筋縄ではないんだよな
結局Createで渡してる第一引数は問答無用で所持ちゅの全馬情報なんだよな
 this.horseDatas = new List<NwDataUserHorse>( userHorseList.Values );
まずこの式なに、意味わかんないだけど
  public void SetHorseFilter(List<List<HorseFilter>> horseFilters) {
    horseSort.SetHorseFilter(horseFilters);
  }
んんｎhorseSortとhorseFilterがあるのか
ＳｅｔＨｏｒｓｅＦｉｌｔｅｒｎの関数の中でhoseSort変数の中の
ＳｅｔＨｏｒｓｅＦｉｌｅｒに引数のFillltersをいれる）
その結果どうなる？
  public void SetHorseFilter(List<List<HorseFilter>> filters) {
    temporaryFilters = filters;
  }その結果
   public void SetHorseFilter(List<List<HorseFilter>> filters) {
    temporaryFilters = filters;
  }
このようにhorseSortの中のtemporaryFItersに代入される。


やっぱりこれDelegateとしての正確を見ないと解決不能だと【思うな
 Dictionary<double,NwDataUserHorse> userHorseList = UserDataManager.Instance.GetHorseList();



horseData.IsImpossibleEvolution() && horseData.IsImpossibleReincarnation()

  public Dictionary<double,NwDataUserHorse> GetHorseListWithoutEnhanceHorse()
  {
	Dictionary<double,NwDataUserHorse> withoutEnhance = new Dictionary<double,NwDataUserHorse>();
	foreach (var key in userData.user_horse_list.Keys)
	{
		if(userData.user_horse_list[key].GetMasterData().cost < 99)
		{
			withoutEnhance.Add (key, userData.user_horse_list[key]);
		}
	}
	return withoutEnhance;
  }

    case PanelType.NumPanel    : FooterManager.Instance.SetHorseNumText( this.itemDatas.Count, UserDataManager.Instance.GetMaxLeiNum() ); break;

これ変えねばならん

    case PanelType.NumPanel    : FooterManager.Instance.SetEvolutionableHorseNumText( horseList.GetItemListNum() ); break; //進化可能数


EvolutionListManageBase
75

HorseListManageBase
112
512
557
112
 

やること忘れちゃったジャン、そうだ、トレーニングでなぜかヌルが出るんだ。
EnhanceMaterialSelect


>大阪さん、村井さん
おつかれさまです。バグレポートの213なのですが、新進化画面での右下の数は、現在進化ができる馬の総数を表示することで間違いないでしょうか。
もしそうでしたら、旧画面の2つの馬は被っているものも多いので（通常進化もできるし転生進化もできる）、単純に合計すると数が合わなくなってしまいます。
お手数ですがその部分のご指摘お願いします。


nn
まよて
autoscrollPosが0.9640719で
scrollPosが0だよな
つまり1動かそうとしても
ん？
それとこれとは、まず1動かす前に0.5動かしてみようか。。。。
とりあｒず。０.5と１００動かしてみよう
はい０．５では駄目

		scrollList.RepositionItems();
		scrollList.UpdateCamera();
maji
すすまねえぞ、どうする考えろよ
今のまんまのアプローチだと駄目だ
あれ、大竹さんｶﾞﾁｬでもやってるいってたけど
ｶﾞﾁｬではやってないきがするぞ
とするとやっぱりサンプルとしては使えないか
というかｍｍｍｍｍｍ
もしやUIScrollList全部勉強せなあかんあのか
きついわ


はああどうしよ

わからん本当にわからんどうしよ
何かが間違ってんの課？

おかしくないScrollListTo_Internalでさ、、、、、、、、、
でさ
でさ
でさ
最初はy軸161で下がってるのに
最後の方では0に戻ってる
なんで？
そういうもんなの？
ん、でもそれもまたおかしな話だな、なんでlocalPosition変える前から
position変わってんだ
そもそも他の可能性として、座標の変更を上書きしている可能性はない？

んん、なんか、個別のアイテムを
PositionItemsとRePositionItemsに変えてるみたいなだな
これなんか意味あるのかな

なるほど、すくなくともCommonScrollBarで上書きしている
ように見える

なんかCommonScrollBarのなかのSetDataの中の
 this.scrollList = scrollListで
何故かScrollListTo_Internal(float pos = 0)
が呼ばれているみたいね・・・なぜだろうね

scrollList.ScrollToItem(1, 0);

まずCommonScrollListのSetDataが何処でよばれているかよく見ないといけない

まあいろんなところで呼ばれているけど、この場合該当するのは
OverallListManageBaseの中のIn（）の中でしょうね
この後で変更してみたらどうでしょうか・・・・・

下げないときは０
一段下げる場合は115
二段下げるときは225が望ましい
なんでしょうねこの計算式は
単純に115ずつ足すと二段目が230になっちゃう
たった５だけマイナスにしてほしい
あれか110*num + 5か？
１段目だと115
二段目だと230　これか　いやちげえだろ・・・よくみろよカス

if(horseList.firstFocusItem != 0)
{
　　horseList.scrollList.ScrollListTo(110 * horseList.firstFocusItem + 5);
}

くそイライラする、なんでまともな値代入しねえんだよ
115にして欲しいのに実際入る値は19205だ
内部的に見ると0.9640719が入るとEditor上は141になる
何これ？
個人的にはワールド座標とローカル座標のナンたら間たらだと思う
OverallListの直下のmoverがいつ移動してくるかわからない

重要
とりあえずOverallListManageBaseの46行目が要,ここにScrollListToSやScroｌｌToItemをいれれば動くことは動く
あとはmoverがヒエラルキーに入るタイミングなんだよな
んで、OverallListManageBaseの、おやクラスのobjs[0]が、なぜかpositionがおかしくなっちゃうばしょやね　

PanelTypeがSelectTypeになるのはEnhanceMaterialSelect内か？
ああ、selectTYpeってそういうことか。。。。。
じゃあパネルとしてはNumPanaelと全く一緒でいいんだ、ただ文字だけを替えたい
これ一応メモっとくか
    case PanelType.NumPanel    :
      diffHeight = 20.0f;
      break;
    case PanelType.SelectPanel :
	  diffHeight = 34.0f;
      break;

うーん、＋２０しないとちょっとでかすぎるね・・・・
120.7862
115が理想だからね、またこの値は計算順序によって
かわることはない。
ここでviewableare.yに+20すると、その値は
113.6391
になる。惜しい、本当に惜しい
つまり、20より値が大きくなることはありえない。
０から２０、いやおそらく１０から２０の間の値がベストになる
しかしさ、これ何を基準にして決めればいいんだ？
ちなみに2ﾌﾞﾛｯｸ下に下げたいときの値は
222.3373
うーん、もうほぼ許容範囲ではあるんだが本当は225がいいんだよなあ。。。
x値を+19にすると222.997
+15だと225.6757
１２２

うーん、２ブロック下げたいとき、itemSpacingが10のときは225がいい
でitemSpacingが20のときは240がいい、これどういうこと？
論理的に考えよう、最初に15を足して


うーんこの16の値はなんなんだ
itemSpacingを変えるとぐちゃぐちゃになっちゃうぞ
itemSpacingが10のときは16でちょうどいい、狙ったとおりの値が出る
ただしitemSpacingを20にしたときは
268.7425になってしまい大分ずれる、本来ここは240になって欲しいところである
んで仮に16を26にすると
260.9302になる。前よりは上に行ったがまだ足りない、もっともっと上である
つまりitemSpacingが20のときは、謎値は16より26よりもっと上になる必要がある。
その前にまず確認するけど、上に行くとｙ値はマイナスになり、下に行くとプラスになる
お、５６だとぴったりだね
itemSpacingが20のとき謎値は56、
itemSpacingが10のときは謎値は16でﾌｧｲﾅﾙｱﾝｻｰです。
ちなみにviewablArea.yは318でこてい
ちょっと待てよ、16と56で考えるから分からなくなるんじゃないか？
318+16と318+56で考えてみよう
334と374ね
勘違いしてた、、、、、表示されるアイテム数によって割るべき値は変わる
３つだと56でいいけど、２つだと56では大分上になっちゃう


３つだと16でいい、はて、２つだと何でいいんだろう？11だろうか？
なぞ、上すぎる。。
スクロールを下にいかせたいってことは、もっと値を小さくする必要がある。
謎値４で40.71429
謎値０（つまりvireable318)で
41.22641
じゃあこれマイナスにするしかねえじゃねえか。
抜本的に見直してｓｃrollLength224で
58.52679

んんんん、vewableArea抜本的にかえるしかねえじゃん・・・・
まずspacingが10でアイテム3つの場合、viewableのｙは
334になるべきである。この計算は如何とするか
まずアイテム100が３つ、spacingが実質4つで340、
これに6を引いて334
もしspacingが20の場合
まずアイテム100が3つ、spacingが実質4つで300＋20*4で380
これに6を引いて374
ふっふっふっふ

そういうことか、越す数か
わかったぞ	

アイテム２つで一つ越す場合114で割れば良い
式はpanelLength(100) * 1 + itemSpacing(10) * 2 - 6 =
114

アイテム３つで1つ越す場合は３３４で割れば良い
式はpanelLength(100)  * 3 + itemSpacing(10) * 4 - 6 =
334

アイテム４つの場合は
式はpanelLength(100)  * 4 + itemSpacing(10) * 5 - 6 =
444

アイテム５つの場合は
式はpanelLength(100)  * 5 + itemSpacing(10) * 6 - 6 =
554

アイテム５つの場合は
式はpanelLength(100)  * 5 + itemSpacing(10) * 6 - 6 =
554

んん、なんだろうねこれ、越すアイテム数は関係ないってことになる。
そうだとすると、本来はアイテム２つで一つ越す場合は
式はpanelLength(100)* 2 + itemSpacing(10) * 3 - 6 =
224のはずなんだけどなあ・・・・

もしかしてこのｘ２ってのがまちがってんじゃねえのか？
もしこの*2がない場合どうなる？
アイテム２つの場合は224になって、
駄目だ、virewable替えてみよう・・・・

まったく検討がつけねえから全部想像で考えるしか寝蝦夷
アイテム２つのときは114（計算では224)　偶数
アイテム３つのときは334（計算では334)　奇数
アイテム４つのときは554（計算では444)　偶数
アイテム５つのときは774（計算では554）　奇数

つまりパネル２つのときは基礎数として114
そこからパネルが増えるごとに220足せばいいだけの話
220の内役はまだ分かる
いや分からんわやっぱ、常識的に考えると
んんん、パネル長さ＋itemSpacing　*２だよねたぶん



んんslideValueをかける2倍じゃなくてすむようにするには
とんでもなくScrollLengthを短くする必要があるな
二倍にしない場合は、単純に謎値を割る２でおｋ
つまり
アイテム２つのときは57（計算では224)　1つおろしで115
アイテム３つのときは167（計算では334)　奇数
アイテム４つのときは277（計算では444)　偶数
アイテム５つのときは387（計算では554）　奇数

この５７の理由をなんとか計算でわりだせないか。。。。
以前の計算式では
panelLength(100)* num + itemSpacing(10) * (num + 1) - 6 =
だった
しかしそれにしても、この-6の理由は全く判然としなかった
今だと
((100/2) * num) + ((10/2) * (num+1)) + 2となるか？　いやならんな。。。
nnnnnn６０－３てきな？？？

slideValueを計算してみるかpanelHeight=100、spacing = 100で
float slideValue = firstSpace + (panelHeight * horseList.firstFocusItem) + (itemSpacing / 2) +  (itemSpacing * (horseList.firstFocusItem - 1));

10 + (100 * 2) + (100/2) + (100) = 10 + 200 + 50 + 100 = 360

１１０ずつ増えてる
んー理論的！！
ところでｱｲﾃﾑ

110から何をひけば57になるんだ？
５３か
ならばさ、200に５３引いてみてわ？
147

>大坂さん
おつかれさまです。現在のの2.9では新画面とその先の最終確認画面で上記のように表示のずれがありまして、どのように修正するかの相談になります。
発生条件は、転生進化に必要な馬を所有しているものの、それが使用中である場合です。
現在２画面目では使用中などのラベル表示がないため、パッと見て馬を所有していないようにも見えます。
ユーザーによっては1画面目で進化可能だと思って先に進み、2画面目でのみ判断してバグだと思う可能性もあるように思います。
1画面目で仕様中とあらかじめ表示しておくか、2画面目で使用中のラベルを貼るか、1画面目と2画面目両方に貼るか色々方法はあると思いますが、この点につきましてお手数ですが指示の方お願いします。


よっっしゃ坂本さんの指示通りいくで
まずどういう条件判定で使用中を表示しているのか見ようか
よく考えたら使用中だけじゃなくてお気に入りもやらなくちゃいけないな


    List<NwDataUserHorse> favoriteHorse = UserDataManager.Instance.GetFavoriteList();
    List<NwDataUserHorse> organizedHorse = UserDataManager.Instance.GetOrganizedList();

どうなってんだこれ、SetCardStatusつかってないのに馬が暗くなってるぞ、どうやってんだこれ
ああ、SetDisableおSetEnableで直接暗くしたりしてんのか

1238
1848
1949
1557

なんだこれ、何でラベルｾｯﾄできねえんだ、
くっそ意味和漢ねえな
アニーメションがウゴ金円だよかすが
謎すぎるなんだよこれ。。。。。。。。。。。。。。。。
。。。
。。。。。。。。。。。。。
。。。。

なんで俺前やったことあるのに今度できないんだよ
直接SetLavelCardやっちゃいけないのか？え？

んんだよこれええええええええええ
理由が一つもわからない書くことがない
どうすんだよこれ
なんでやったことあるのができねえんだよ

どっかで処理を上書きしているっぽいな、確実に変更してるもんあ
上書きしてたわ103行目のDrawMaterial()
くだらなすぎ・・・・・
正確にはDrawMaterial()の中のSetMasterDataで初期化している。
はあ。。。。。


これは指定したhorse_idの馬データを取得するやつ
  public NwDataUserHorse GetHorse( double id )
  {
    if (TutorialManager.IsUseTutorialTeam())
	{
	  return UserDataManager.Instance.GetUserHorseDataFromMasterData( MasterDataManager.Instance.GetHorseData((int)id) );
	}
	else
	{
	  if( userData.user_horse_list.ContainsKey( id ) )
	  {
	    return userData.user_horse_list[id];
	  }
	  return null;
	}
  }

こっちがhorse_idね
俺が欲しいのはhorse_card_idを渡して、所有している全ての馬を帰す奴
それがない

これはhorseCardIdを渡して、その馬の数をLISTに突っ込んで返すやつ
正直意味わからん関数
  public List<double> GetUserCardIds(int horseCardId) {
    List<double> userCardIds = new List<double>();
    foreach (NwDataUserHorse horse in userData.user_horse_list.Values) {
      if (horse.horse_card_id == horseCardId) {
        userCardIds.Add(horse.horse_card_id);
      }
    }
    return userCardIds;
  }

ふぁああああああああ面倒くさい
ここの計算式よくわからんよな
とりあえずpositionはスクロールの長さの0.5倍の値をマイナスにして、そこから更になにがしか(adjustとマジックナンバー）をマイナスにしている・。

うーんなるほど、超大成功で大分取得経験値変わるんだな
57>60が長大施工で57>63まで言った
しかし予想で５７レベルで、一気に最大値（70)いくってことが本当にありえるのか
まあクリスタルホースの取得形見値が10000で、それが5体＝50000、それの二倍だから
100000が10万か、確かにたいした経験地だ

よし、とりあえず16時までスクリプトの整理をしよう、それからだ、


List<MasterLeiData>
List<MasterHorseData> 

List<MasterLeiData> leiMaterials = MasterDataManager.Instance.GetLeiList(leis);

List<MasterHorseData>  horseMaterials = MasterDataManager.Instance.GetMaterialHorseList(leis);

ん・・・・？
HorseList574行目
int totalShowNum = FilterHorses()
totalShowNumにゼロが代入されてますね。。。。なんで＞＜！
 int num = this.horseDatas.Count;
num = 104
    int start = (GetPage(totalShowNum)-1) * perPageNum;
start = 0
    int showNum = ((totalShowNum - start)>perPageNum)?perPageNum:(totalShowNum - start);
showNum = 0

ん、現況はtotalShowNumやね、ということは
さらにさかのぼってFilterHorses()に問題があるということだ
んん、714行目
  private int FilterHorses() {
    for (int i = 0; i < horseDatas.Count; ++i) {
ここのhorseDatas.Countは104なんだよ、つまり104回は絶対ループしているはず、だけど値がゼロになるんですよ
んｎ104回ループはするんだけど、その中の条件式
 if (horseDatas[i].horse_id == 0 || IsHorseVisible(horseDatas[i])) {
で全部はじかれてるってことか、
んんんんなかなかhorseDataのhorse_idがｾﾞﾛってことは起こりえないと思う。
実際中身が見れないからなんともいえないけどさ
いやJsonで見れるかもな、どうにしかして。。。
まあでもとりあえずこの可能性は横に置いといて
んデバッカでみたけどやっぱり予想通りInHorseVisibleが全部false
返している。
じゃあ更にInHorseVisible見てみるか
うん、InHorseVisibleに渡されてるhorseDataの配列中一つ一つ見たけど
どれも至極全うな数値だわ
完全にfilterが原因だ

   foreach (List<HorseFilter> filterList in horseFilters) {
      bool passSub = (filterList.Count == 0) ? true : false;
      foreach (HorseFilter filter in filterList) {
        if (filter(horse)) {
          passSub = true;
          break;
        }
      }
      pass &= passSub;
    }
で、どうやらhorseFiltersに入ってるのはひとるしかない
じゃあこれをつきつめていけばいいわけですな。。。

なんだこれ。。。Filterの変数の見方が分からない
こんなめちゃくちゃな変数でどうやってフィルターにかけてんだ？
とりあえずHorseFilterの宣言を見るとdelegateになってますな面倒くさい
public delegate bool HorseFilter(NwDataUserHorse horse);

ああ、   filteredHorses.Clear()ってのはフィルターを通った馬のリストをクリアしてる訳であって、フィルター条件をクリアしているわけではないのか

delegateといえど実際に処理をしているコード、関数はあるはずだ、何が代入されているか調べてそこのコードで何が起こっているか調べよう

さて、我々はなにをすべきであろうか
まず率先してやるべきはHorseFilterの中身を知ることである、かな
あの変数の見方が分からないんじゃどうしようもない
まずあのdelegateg型の変数に何が代入されているか調べないといけない

とりあえずHorseListの中で限って言えば、List<List<HorseFilter>>で宣言されたhorseFilterｓというのがまずあって、それに値を代入しているところは
二箇所のみということになる。141行目と169行目
前者はCreate内、後者はRefleresh内で使われる。
とりあえずCreateからみていこうか
Createの引数でわたされたhorseFilterがhorseListの中のhorseFilterに
代入されているから、その前段階のHorseListManageBaseから未定かなくはいけない
ここは前見たけどHorseListがCreateが呼ばれているのは
HorseListManageBaseの107, 510, 556
それぞれCreate, CreateReincarnationMaterial, CreateTutorialの３つのみ
とりあえずここは無難にCreateでもみたけど
  public List<List<HorseFilter>> GetHorseFilters() { return temporaryFilters ?? horseFilters; }
これが実際にHorseListの引数に渡しているフィルターの解・
この式なんだっけ、temporaryFiltersがなかったらNullをつっこむんだっけ？
事実フィルターはどうやら渡されているから、nullってこたあないと思うんだな
あ、temporaryFilterってhorseIflterHorse

うーん、このフィルター本当にまともな関数はい
ってんのか？
ちょっと他のプロジェクトで見てみるか
他のプロジェクトで見てみたけど、普通はここ初期値はゼロなんだな
ここって言ってもわからんかもしれんけど
horseListの530行目  private bool IsHorseVisible(NwDataUserHorse horse) {　が呼ばれた中の
このfilterHorseのcountがゼロなんですわ
だから実際フィルター処理はしない

うううううううんｎ、今度実際にfilterかけてためしてみたけど
filterListの中の_itemsってのは{HorseList[4]}がデフォなんだな

うーん、どんなにいろんな組み合わせためしてみても、
_itemsの１と２と３はnull以外見たことがないな
一番いいのはゲーム起動直後にフィルターを初期化することだよよな

まあ端的にいうと初期化をどの時点でやればよろしいかという話しなのですよこれは、それに尽きる
とういかもう面倒くさいそれでいいや
どうがんってもゲーム中ではクリアできない、おかしい

EvolutionMain 640行目

とりあえず前のページを見たところによると、ReincarnationMainの73行目
override outの中のOutConfirmを通ってきている
そうかcallStack見れば楽勝じゃねえか

ReincarnationMainの73行目　から
ReincarnationConfirm 570行目ぐらい

MainMenuLogic.ChangeMainMenu () 
FarmMenu.Out ()
ReincarnationMain.Out () 


あれええ、もしかしオレミスって消してた？
	private IEnumerator ChangeMainMenu( MenuType menuType )
	{
		if( menuType != MenuType.Result && NetworkManager.Instance.IsChangeDate() )
		{
			AssertManager.Instance.Set( AssertType.ChangeDate );
			yield break;
		}
		
		FooterManager.Instance.PushFooterAction( menuType );
		
    if ( curMenu == null )
    {
  		Debug.Log("<color=red>Touch Footer Out()!! curMenu=null</color>");
    }
    else
		{

{

curMenuが｛FarmMenu (FarmMenu)}
になっとるな、本来は何が正しいやろか
なるほど、どんどん派生的に細部にもぐっていくのか
FarmMenuの中では{EvolutionMain(Clone) (EvolutionMain)}
でした。
      Debug.Log("<color=red>Touch Footer Out()!! curMenu=" + curMenu + "</color>");
      curMenu.Out();

そうか、FarmMenuの中で	    case FarmPhase.Reincarnation : curMenu = instanceReincarnationMain; break; //*
けしちゃったんだ。
つまり転生進化だろうとなんだろうとcurMenu = instanceEvolutionMain; break;にしかいかない、つまりは、EvolutionMainの中に転生進化の遷移も含めなくてはいけないということだ、とにもかくにもEvolutionMainの中のInとOutみてみよか。。。。

EvolutionMainの中、ChangePhaseありすぎで面倒くさい

うーーーーーーｎ、EvolutionMainのCurMenuが
ReicarnationConfirmになってるのが問題なんだよな

とりあえずReincarnationMainの中の212行目

独自処理で変えることは出来るけど、どうするのか、規則にのっとるべきなのか、はああ面倒くせえええええええええええええええええええええええええええええええええええええ

>大坂さん
おつかれさまです。どうやら昔からあるバグで、旧画面の転生進化画面で次のページに行くと、アイテム不足やレベル不足が急に表示されることが分かりました。
統一していないのもおかしな感じなので、旧転生進化画面の方は１ページ目に合わせてラベルの表示はしない方向で問題ないでしょうか？


昨日やったことはええと、enum型をいじったことでいろんなプレハブに影響が出ていたのでそれの修正と、あとhorseListクラスを使った馬の表示がたまにおかしくなってい

へーい戻ってきたぜ、horseItemとhorseItemListのフィルターは別管理で間違いないんだよな、ヘイブラザーｍへいへい
でもいおブラザー、HorseListManageBaseにもHorseListSortってソートっぽい何かがあるんだぜ、しってるかい？？
ただこのHorseListSortはソートするため機能で、現在何のソートが保存されてるかっていう変数ではないんだよな、たぶん、もうちょっと見てみるか。いやでもたしかうん
reｆで返しているはずだ、たしか
  static public void Sort( ref List<NwDataUserHorse> listDatas )
  {
    listDatas.Sort( GetSortClass( CurSortType ) );
  }

  static public void Sort2(ref List<NwDataUserHorse> listDatas) {
     listDatas.Sort(new SortUltimate(GetSortClass(CurSortType)));
  }

  static public void Sort3(ref List<NwDataUserHorse> listDatas) {
	listDatas.Sort( GetSortClass(CurSortType));
	SortReincarnation(ref listDatas);
  }
うん、refで返しているね、間違いない、とすると、やっぱりこれを呼び出している元になにがしかが保存されているはず。HorseSortList
あれえええ、一応HorseSortListの中にも
  static private List<List<bool>> horseFilterFlags = new List<List<bool>>();
て変数は存在するね。それに
  static private List<List<HorseFilter>> temporaryFilters; // 特定の場所で一時的に使うフィルター(転生進化は指定した
ってのもあるから、やっぱりHorseSortListも注意してみないと駄目だな

HorseListSortとHorseItemListとHorseListgの３つにだいたい絞られると思う

つまりHorseListの136行目、    this.horseFilters = horseFilters;では、HorseSortListのhorseFiltersを、HorseListのhorseFiltersに代入しているという訳か
んでまずHorseSortListのhorseFiltersはstaticなんだよね、だから複数のところで使っても
本来は影響ないはずなんだけど

つまりさ、初期化では一切、HorseItemListではソート情報を渡していないんですよ。


HorseItemListManageBase.SortList (index=9) 
HorseItemListManageBase.Sorted () 
　HorseListSort.Sorted ()
　horseList.Refresh（）

なるほど、EvolutionNewBaseSelectはHoreItemListManageBaseを継承しているから
Sort2の情報を共有しているのか・・

なんで４５なんだ？どこでどうやってfilter絞込みやってんだ？あ？
だまされた、CreateListItemとCreateItemがあって紛らわしい。


HorseList.CreateListItems ()
HorseList.CreateList ()
HorseList.Refresh (horseDatas=Count=46, horseFilters=Count=3, isRemove=false, listMaxNum=-1)
HorseListManageBase.Sorted ()
HorseListManageBase.SortList (index=1)
SortWindow.OK ()


はいはいEvolutionBaseSelectのホースティテールは
親クラスHorseListManageBaseのShowCardDetaiｌでやってるのか

んん、TutorialManagerって一番最初のときの判定にだけ使うやつか？自分からhelp選んだときには使わないのか？

あれえ、Enhaceで試したら普通にTutorialManager.CheckTutorialEnhance()でfalseを返しているな。。。
普通ここのチェックって一度通ったらtrueになるんじゃなかったっけ？どっかでtrueにやり返し点丘？

ぶれずにいこう、	  evolutionSelect の値を適時かえない
本当に変えたい、本当に
でもなかなか買えずらい、FarmMenuのcurPhaseを簡単に取得できる方法はないだろうか

とりあえずチュートリアルが終わるところがどこか調べよう、もうそこでケリつける


どうしようか、もうやることない気がするけど
でもまだ見落としがあるかもしれないでそ。。。
もう一度同じこと確認してみようよ
トリアエズ馬増やしてみるか。。。
まずちょっと今日なんで見逃したか考えて御世か
どんな盲点があったのか、どんな見逃しがあったのか
どんな思い込みがあったのか
まずnullが発生する条件で知識不足があったな
実行す順番でinstanceを生成する順番も変わる可能性があるわけですよ
あとは、まあ致命的なのはそこぐらいか？
あとあれか、一度コメントアウト外して必要ないと判断したので
またそのまま放置したやつあったよな、あれどうやって防げばいいんだろうか
コメントアウト外したところは//いがあああ　とでもやっておくか
そうすればまず間違いないだろ