うわあまずMasterHorseDataとMasterDataManagerいじらなければあかんやん。。。。
そもそもどうやってローカルのテキストデータをMaseterHorseDataにいつ入れてるんやってことやろなあ。。。。その元をたどっていかないと
予想ではMasterDataManagerのどこかしかで代入しているとはおもうんだけど。。。
候補としては、MasterDataManagerの342行目ですなあ
          data.reincarnation_id = int.Parse(facts[71]); 
つまりMasterDataの71要素目がreincarnation_idだと予想するんだがど
おかしいな、71番目はreincarnation_item_1のはずなんだがな
仮にゼロ番ではじまるとしても、コンドはreincarnation_item2が71番目になる
どっか見落としてんじゃねえか

horse_card_id/
,name_b,
name,
body,
star,
socks_1,
socks_2,
socks_3,
socks_4,
Vandage_1,/1
Vandage_2,
Vandage_3,
Vandage_4,
menko,
mimiate,
parts_color,
shadowRoll,
CheekPieces,
BrowBand
,brinker,/2
pacifire,
sex,
foot_type,
element,
element_sub,
rarity,
cost,
type
,type_sub,
stamina_min,/3
stamina_max,
speed_min,
speed_max
recovery_min,
recovery_max,
stamina_glow,speed_glow,
recovery_glow,
EXP_table,
levelmax,
skill_id,/4
L_skill_id,
horse_card_id,
item_1,
item_2,
item_3,
item_4,
item_5,
sinka_money,
ImageVer,
int rarity_b,/5
speed_plus_limit,
stamina_plus_limit,
recovery_plus_limit,
skill_id2,
L_skill_id2,
evolution_type,
evolution2_horse_card_id,
evolution2_item_1,
evolution2_item_2,
evolution2_item_3
,evolution2_item_4,/6
evolution2_item_5,
evolution2_sinka_money,
evolution3_horse_card_id,
evolution3_item_1,
evolution3_item_2,
evolution3_item_3,
evolution3_item_4,
evolution3_item_5,
evolution3_sinka_money,

2892,1333,2897,2900,2903,2821,5000,
2898,1,2,3,4,5,50000,2901,1,2,3,4,5,50000

あれ・・・・？ちゃんと設定されてるはずだな

２８９８　２９０１
reincarnation_horse_card_id,/7　(スクリプト上ではここが71番目の要素)
reincarnation_item_1,  72
reincarnation_item_2,  73
reincarnation_item_3,  74
reincarnation_item_4,  75
reincarnation_item_5,  76
reincarnation_sinka_money,  77
collection_L, 78
collection_SS 79
,collection_S,  80
collection_A,  81
collection_B,  82
collection_C,  83
collection_SL,  84
reincarnation2_horse_card_id,  85
reincarnation2_item_1,  86
reincarnation2_item_2,  87
reincarnation2_item_3,  88
reincarnation2_item_4,  89
reincarnation2_item_5,  90
reincarnation2_sinka_money,  91
reincarnation3_horse_card_id,  92
reincarnation3_item_1,  93
reincarnation3_item_2,  94
reincarnation3_item_3,  95
reincarnation3_item_4,  96
reincarnation3_item_5,  97
reincarnation3_sinka_money   98;
1,-1,インティライミ,2,1,0,0,0,0,3,3,0,0,0,0,0,0,0,0,0,0,1,3,1,-1,1,2,3,-1,30 ,90 ,45 ,225 ,8 ,23 ,1,1,1,2,10,87,-1,140,38,-1,-1,-1,-1,5000,16,1,150,150,300,-1,-1,-1,-1,-1,-1,-1,-1,-1,7500,-1,-1,-1,-1,-1,-1,7500,-1,-1,-1,-1,-1,-1,10000,0,0,0,0,0,1,0,-1,-1,-1,-1,-1,-1,10000,-1,-1,-1,-1,-1,-1,10000





修正対象その１ 
NwDataUserHorseのIsImpossibleReincarnation()
これ一体どういうところで使うんだろうなあ。。。ていうかこれ本当に3日で間に合うのか。
まず使っているところを羅列すると
	
	GetHorseListWithoutImpossibleEvollution()　一切進化できない馬を除いたリストを作る
	GetImpossibleEvolutionAndReincarnationList()　似たような漢字化
	GetImpossibleReincarnationList(Dictionary<double,NwDataUserHorse> horseList)
	んん、まあパッと見た感じ気軽に買えて良いきはするね

 public bool IsCompletedReincarnationItem()
うはぁーこれあ面倒くさい。。。。。。
アイテムをコンプリートしているかどうかだって、一体どういうところでつかうんだよ

	GetNotCompletedOverallItemList()
	んんｎ、アイテム不足をベースの馬の顔に貼るときにつかってるんだろうねたぶん
	Func<List<NwDataUserHorse>> shortLvListWithoutReicarnation = () =>
	んんなんだこれどこで使うんだ、ん？これ何か使い方おかしくない？
	if (horseData.IsCompletedReincarnationItem())
	{
		continue;
	}
	んんん？ああなるほど、アイテムコンプリートしてればその時点で転生進化可能だから
	レベル不足って表示は必要ないのか（転生進化にはアイテム不足だけでレベル不足は存在しない）
	とすると他の方法として、進化先が転生進化しかない場合、レベル不足は問答無用で不要になると	いう見解でよろしいか
	まあこれは今はおいておこう

	うーんこのIsCompletedReincarnationItemに関しては、転生進化先のうちどれか一つでも
	満たしていたらtrueを返すのが望ましいと思うな

 	 public List<NwDataUserHorse> GetNotCompletedOverallItemList()
	ああああ、、、、
	コレ見るとIsCompletedReincarnationItemは３つつくったほうがいいね
	まあ３つというか引数にあわせ３パターン作った方が良い
　　　　		if( !horseData.IsCompletedItem() &&
		   !horseData.IsCompletedItem(evolutionIndex:1) &&
		   !horseData.IsCompletedItem(evolutionIndex:2) &&
		   !horseData.IsCompletedItem(evolutionIndex:3) &&
		   !horseData.IsCompletedReincarnationItem())
		{
			datas.Add( horseData );
		}
	とりあえず元の関数は変更しちゃったからそれに付随する全部の関数を変えた方がいい
	

protected NwDataUserHorse GetReincarnationHorse()
evolutionMainの関数、なんこれいろんなところで使われてるわ。。。。
たぶん上のやつとおんなじように、引数で改訂する感じかな・・・・・
ああ、逆にこれあれだ、いじんなくて良い奴だ、サーバから送られてkルやつをと手来るだけだからな


HorseItemListのLine752以降
これはあれだな、旧転生進化合成画面の話しだ。。。。。
これは今まで一体につき一つの転生先だったからすごいシンプルだったけど、これ抜本的変えなきゃ駄目だ
forループでループして変えるしかないな、
というかそろそろさ、この関数さ、旧通常進化画面と併用しているからさ、改造した方がいいと思う
おｋ改造した
うわあ超面倒癖絵  private Dictionary<double,HorseListItem> horseItems;
がくせものや、いままで転生先は一体につき一つで、かつhorse_idは完全に一意のものだから
Dictionaryにただつっこんでも問題なかったけど、今回複数になっちゃったから、Dictionaryで既に登録しています
みたいなエラーで茶太、これの解決方法はいろいろあるけど、とりあえず究極進化を参考に。。。
あできねえわ。。。。。
やりかたは色々ある、Dictionaryに自分のIDではなく、進化先のIDで登録して紐付け津
ただ波状的に色々問題は出そうではある
foreach( NwDataUserHorse horseData in horseDatas )
{
　　if(this.horseItems.ContainsKey(horseData.horse_id)) 
　　{
	if (this.horseItems[horseData.horse_id].evolutionListType == EvolutionListType.Ultimate && isContainShortItem == true) continue;
	if( this.horseItems[horseData.horse_id].labelType == CardLabelType.None )
	{
	　　this.horseItems[horseData.horse_id].labelType = CardLabelType.SwitchPlay;
	}
			
	if( this.horseItems[horseData.horse_id].labelType == CardLabelType.SwitchPlay && switchLabelType != null)
	{
	　　this.horseItems[horseData.horse_id].switchLabelType = switchLabelType;
	}
　　　　}
　　}　
　　isChanged = true;
}
たとえばこれなんかどうだろうか、んｎこれは特にもんだいないか
むっず、、、このDictionaryはユーザーが持ってること前提の馬や
問題はSetCardStatusなのだよ。。。
    base.horseList.SetCardStatus( shortItemList, HorseCardSprite.Status.Unavailable );
このように呼び出し元では、UserDataManagerを使って、所持している馬から、horseIdを取り出してリストを
作っている。ちなみにこのshortItemListで送り出す馬データは、全く架空のものでもいいのかい？
今回つくるIdは架空のものなんだからさ、ま、架空でも問題ないっちゃないけど、ちゃんとIDだけ変えた
NwDataUserHorseを３つ作んなきゃ駄目だよね。。。。
んfilterdHorses.add(i)してるから、userHorsesの何番目かっていう値を入れてるのか。。。。。
つまり本来は同じ値が入ることはないんだよな。。。。
つまりfilterdHorses[num]でuserHorsesの何番目かってのがずれて表示されんのな
12345678910
>
1589
1234 みたいな
だからここでもし同じ値がはいっちゃうと
たとえば8を二回入れちゃうと
1588
1234　みたいになるのか、これによる弊害って一体なんだ？
はああ。。。結局いろんなところからCreateで持ってきたhorseDataつかってるから
結局のところhorseData自体いじらないと駄目だわ。。。
えええと何やったっけオレ・・・・
とりあえずhorseData自体をいじったんだよな。。

うーん？？？このうちのどれがどこに代入されるんだ？？？
 base.CreateReincarnation( 
this.TouchCallback,
horseDataCallback: callback, 
userHorseList: userHorseList);

まずTouchCallback = tapCallback
callbackが最後の二つ前のhorseDataCallbackか
ほとんど使ってね画じゃねえか・・・・
public void CreateReincarnation( 
HorseCardCallback tapCallback, bool isMaxNum = false, bool isRemove = false,
HorseCardCallback holdCallBack = null, 
EvolutionPanelCallback tapEvolutionPanelCallback = null, 
EvolutionPanelCallback holdEvolutionPanelCallback = null,
HorseDataCallback horseDataCallback = null,
 Dictionary<double,NwDataUserHorse> userHorseList = null)
1102613
1102711
2102711
3102711
1102712
2102712
3102712
horse_card_idから仮想的なうまでーたが欲しいな
MasterDataManager.Instance.GetHorseData(horseID);
  public MasterHorseData GetHorseData( int horseId )
NwDataUserHorse newHorse = UserDataManager.Instance.GetUserHorseDataFromMasterData( newMasterHorse );
newHorse = EvoHorseAddSomeParam( newHorse, baseData());

  private NwDataUserHorse EvoHorseAddSomeParam(NwDataUserHorse newData, NwDataUserHorse baseData )
  {
	newData.exceed_count = baseData.exceed_count;
	newData.speed_plus = baseData.speed_plus;
	newData.stamina_plus = baseData.stamina_plus;
	newData.recovery_plus = baseData.recovery_plus;
	if (newData.GetMasterData().skill_id == baseData.GetMasterData().skill_id)
	{
		newData.skill_level_list[0] = baseData.skill_level_list[0];
	}
	if (newData.GetMasterData().skill_id2 == baseData.GetMasterData().skill_id2)
	{
		newData.skill_level_list[1] = baseData.skill_level_list[1];
	}
	return newData;
  }
ある程度は形になったけどまだ全然終わってないで、Confirm画面は全部reincarnationId == 1の情報になってる
あとhorseItemList画面も、素材が1,2,3で全部一緒だから何か怪しい幹事もする
どっから直すか、とりあえずConfirm画面からいこか。。。。
そのまえにSplitImaginaryIdをNwDataUserHorseDataに移そうか
とりあえずConfirm画面のマテリアルは正常に表示されるようになった
あとはHorseItemList画面でなんかおかしい、マテリアルどこで表示してるんだ

 public int[] GetReincarnationMaterialHorseIds() { return master_data.reincarnation_item_ids; }
NwDataUserHorseの中にあるスクリプト。
これも引数ぶちこめんで修正や名

EvolutionMain
protected NwDataUserHorse GetReincarnationHorse()
うん修正、一応必要ないけど（もう使わないから）ReincarnationMainの中の
GetReincarnationも守勢しておいたで

NwDataUserHorseData
GetReincarnationCoin()
うん、変数名そのまんまの意味だね・・・・



とりあえずreincarnationId検索して片っ端から修正していくで
１．NwDataUserHorse,IsImpossibleReincarnation()修正済み
２．UserDataManager.IsCompletedReincarnationItem()修正済み
３．HorseItemListのLine752以降修正済み
４．NwDataUserHorse.GetReincarnationMaterialHorseIds修正済み
5.　EvolutionMain.GetReincarnationHorse修正済み
６．NwDataUserHorse.GetReincarnationCoin
7
NwDataUserHorseData
GetReincarnationCoin()
修正済み






>坂本さん
新たなパラメータがいらない件了解しました。
ちなみに現在サーバ側ではどのようにして判断しているのでしょうか
進化ベースの馬IDと素材馬のIDで判断して返す馬データを振り分けている
感じでしょうか。

>坂本さん
了解しました、ありがとうございます。引き続き宜しくお願いします。

>大坂さん
おはようございます。転生進化の複数化の実装を少し進めていまして、転生進化先が３つあるシーズティジーを使ってテストしました。
画像のように旧転生進化画面の方では見た目が多少分かりづらいものとなっています。
旧画面は非推奨とのことでしたので、これで進めていっても問題ないでしょうか？

さ、、、、、一体どのJSONを見ればいいのかな。。。。。。
まずNetworkManagerを見るか

ん、ReincarnationのＥｘｅｃCmdで呼ばれている場所が二つあるな、EvolutionMainと
ReincarnationMain
たしか今ってReincarnationMainの方は使ってないから、EvolutionMainだけか直接関係
あるのは、うん、そうだね、今ReincarnationMainつかってないね・・・・

>坂本
おつかれさまです。
転生進化の複数化に関してですが、究極進化のevolution_type_idのように、どの転生進化を選択したのかfarm_horse_reincarnatioのリクエストパラメータとしてサーバ側に何か贈る必要があります。	
こちらもし変数名などが決まりましたらご連絡お願いします。

1333, 2897, 2900, 2903, 2821

うん？EvolutionMainのEndEffectのなかにinstanceReincarnationResultのｓSetDataが二つあるぞ
ああなるほど、旧画面と新画面か

了解しました。"転生に必要なホース"の前に文字列を追加するだけという対応で進めていきます。よろしくお願いします。

ああ、まずいな、旧転生進化画面でソートが効かない。。。。。
何をどうすればいいかぜんぜん分からない、たぶんFilterHorsesの使い方がこれまでと違うのが問題だとは思うんだけど、しかれど何をすればいいやら

とりあえずSortを実行したときに呼ばれるのは、HorseItemListManageBaseの中の
うーんいやちょと待てよ、HorseItemListManageBaseの中のhorseDatasとHorseItemList
の中のhorseDatasは最初から共有されているはずだ
なぜならreincarnation画面では、HorseItemListManageベースで既にソートした情報を
HorseItemListに渡して画面作りをしているからだ

んでまあそれは置いといて、Sortを実行したときはHorseItemListManageBaseｎの230行目
のSorted()が呼ばれる。
  public void Sorted()
  {
    if( !isCreated )return;
  
    horseSort.Sorted();
    horseList.Refresh( this.horseDatas, horseSort.GetHorseFilters(), this.isRemove );

    TitleBoardManager.Instance.SetSubText( HorseListSort.GetSortNameShort() );
  }
  まあ見ての通りまずhorseSort.Sorted（）が呼ばれる
horseSortはHorseItemListManageBaseのメンバで
このhorseSort.Sortedをやることで horseFilterFlags[0]にrarityFilters[i]);を突っ込む

    // element
    for (int i = 0; i < horseFilterFlags[1].Count; ++i) {
      if (horseFilterFlags[1][i]) {
        horseFilters[1].Add(elementFilters[i]);
      }
    }

    // type
見て通りhorseFlltersにフィルターの情報の基本を突っ込んでいる
    for (int i = 0; i < horseFilterFlags[2].Count; ++i) {
      if (horseFilterFlags[2][i]) {
        horseFilters[2].Add(typeFilters[i]);
次に第二引数を見ていくと
horseSort.GetHorseFilters(),とある
これはもう転生のマテリアルselectでもない限り、実質horseSort.horseFiltersである

そーか、スピード順だから、Sortedの方じゃなくてSortListの方だ

とりあえずhorseItemListManageBaseでSortが呼ばれているところはそんなに多くないと思うから、それとりあえず、うーん・・・まあ、、、、、、Deligateでやってみるか、

4つしかないな、これ全部変えよう、、、いや、オーバーロード混ぜると全部で5こか
Delegateはオーバーロードは使えないから、別名の変数にするしかないのか。。。。

      HorseListSort.Sort( ref this.horseDatas, (HorseSortType)index );
index = int

おれ前delegate使った記憶あるんだけど思い出せないわ

ＲｅｓｕｌｔＭｅｎｕか

とりあえずこれかあ違うバグ修正やるから、ひとまずおこう、問題点としては2,3,1の並びのとき
2,1,3としか並び替えがおきないってこと
よし次

現在、シングルスペシャルのAJCC
というレースで確認できると思います。
ギンの蹄鉄はResultHelperMainや
ＲｅｓｕｌｔＭｅｎｕの495行目かHelperのセットを行っている

if( !RaceData.friendData.is_event_user )
 {
        MenuBase.CreateMenu<ResultHelperMain>( ref instanceResultHelperMain, resultHelperMain, this.transform );
        instanceResultHelperMain.SetData();
        TitleBoardManager.Instance.AddCallback( this.ResultEnd ); 
        StartCoroutine( this.ChangePhase( ResultPhase.Helper ) );
      } else {
        ResultEnd();
   }

つまりは助っ人が存在していればHelperを作るよという話し

まあこの話しはいいよもう、問題はSort３だよね
旧転生進化画面ではimaginaryId作ってるけど、確か新進化画面では作ってないんですよ
どの段階でこの値をつっこめばいいのかなということでして、
HorseItemListManageBaseのCreateReincarnationの元からたどっていけばいいんじゃなかな
そういうこともあるけど、まず旧転生進化画面では、どこでimaginaryIdを設定しているのか、これも問題に
なってきた。ああちゃんとメモっとけば良かったなあ。・

まず旧転生進化画面でimaginaryIdを作ってる場所だけど、これはHorseItemListManageBaseの204行面
にｎなる、
まそれは置いといて、まずSort3を修正しようか。。。。。おここ

なんか色々考えたら全部修正できてましたわ、あとパターンA、パターンB、パターンCを入れるのみ
あ駄目だ、なるほど、こんどは132と123のパターンがあるぞ

１３２のﾊﾟﾀｰﾝはどうすれば防げるのか
321と並んでる場合　321 > 312 >132　となるのか、これの解決としては。、

HorseItemListの中、675行目CreateListItemsの中、さらにその中755行目でreincarnationItemを静止してる
この

ちょっと流れだけみていこう
horseItemList 377行目　SortList
>
horseItemList 137行目　delegate内
>
horseListSort 123行目  sort3

最初は0と2番目がid一緒で、でも交換は実行されない（mostUnderが更新されない）
次は0と3番目がidが一緒で、これも交換が実行されない

あああ頭が働かない
もしidが一緒でsplitIdが自分より大きい場合は、自分のすぐ後ろに入力する

まず二段階に分けたほうが確実だわ
問題は一段階目、省略できるところは省略した方がいい

何もしない場合は普通に１から２でそ
でも１つ追加した場合は１から３にしたい、その場合あらかじめcoutを++しておけばいい

というか配列のアウトはforの方で判定してくれるからそこは考えなくていいのか
さ、汚いけどソートは終わったぞ、次は何やればいい？
とにかくさ、今回複数転生進化全般を担当しているわけじゃん、それで一体どこを見ればいいんだ

けっこう広いけど、とりあえず進化合成画面以降のいうことは確実
ソートしかバグがないなんてありえないよなあ常識的に考えて

rarityMaxオルフェーヴルのはずがキャプテンスティーブに、なんで
他に考え付くバグなんてないでﾏｼﾞで、たとえば他の転生進化、まあ他の属性、他のラリｔｙぐらいは見てもいいか

新進化画面のベース馬選択で、ソートしても進化可能数の値が変わらない。

>坂本さん
おはようございます。先日GoogleDriveからいただいたMasterDataのダミーデータですが、問題ないことが確認とれました、有難うございました。
クライアント側は準備が整いましたのでテストをしていきたいと思います。
現在サーバから取得できる最新のMasterDataの方でも複数進化のデータを導入していると思いますが、サーバ側でテスト準備が完了しましたら、お手数ですがご連絡お願いします。

evolutionBase画面で、対象がアイテム不足とレベル不足を併発していても、何故か対象の進化先に転生進化があると、レベル不足しか表示されない
んｎこの問題解決がむずかしいな。。。


nnnnnnnnnnnnnnn
ウェええええええええええええええええええええええ
い
どうするか、まず先にSortやろう、同じIDごとにABCの順で並べることはできんたんだけど
名前順とかスタミナ順とかそれまでのソートが全く機能しなくなった
これは順版の問題なのかな。。。。。。
System.Comparisonの中の条件判定でもっと面倒くさいことしなくちゃいけないのかな。


さあこれどっからどう未ていこうか
まずオレのリスト方はNwDataUserHorseだったはずだ
dだから
System.Action<List<NwDataUserHorse>> fotSort = (horse) =>
{

}
ん？ていうかこのクラスDebug.Logにしか使ってなくね

System.Action<List<TestData>> output = (targetList)=>{
string log = string.Empty;
foreach ( var target in targetList )
{
  log += target.ToString();
  log += "\n";
}
Debug.Log( log );
};


こっからの方が大事なのか、なんでこれ４つもあるんだろ
しかもこれSortにdelegateとして渡してたな、そもそもこの標準クラスはdelegateなのかな
ActionやFuncと一緒で

ああ、これindex1同士index２同士でしか判定していないな。。。
だからオレが実装するのは一つでいい気がする
なんなんだこのComparisonってのは、比較するってあるけど
何をど比較して、比較結果したはどう判定するんだ・
なにこれ比較した結果intを返すの？どうみても帰り値は存在しないんだけど

public delegate int Comparison<in T>(
	T x,
	T y
)

ありました。。。。　intですね

基本的にList.Sortっていうのは問答無用で低い数から順に、いわゆる昇順がデフォルトである
この大前提を知っている必要がある
更にList.Sortの引数に条件を入れることで、それら合致した要素を手前に持ってくる

        // ～ 適当なデータをList<T>と配列に格納する ～ 
        List<Employee> employeeList = new List<Employee>();
        employeeList.Add(new Employee(2, "William Henry Gates"));
        employeeList.Add(new Employee(3, "Steven Paul Jobs"));
        employeeList.Add(new Employee(1, "Lawrence Edward Larry Page"));
         
        Employee[] employeeArray = employeeList.ToArray();
        
        // リストをID順でソートする
        employeeList.Sort((a, b) => a.ID - b.ID);
         
        // 結果、下記の順にソートされます
        // ID=1 Name=Lawrence Edward Larry Page
        // ID=2 Name=William Henry Gates
        // ID=3 Name=Steven Paul Jobs
         
        // 配列を名前の長さが短い順でソートする
        Array.Sort(employeeArray, (a, b) => a.Name.Length - b.Name.Length);
         
        // 結果、下記の順にソートされます
        // ID=3 Name=Steven Paul Jobs
        // ID=2 Name=William Henry Gates
        // ID=1 Name=Lawrence Edward Larry Page

このa.ID - b.ID　や　a.Name.Length - b.Name.Length　みたいに、　この　何かの数値　- 何かの数値
っていうのはSortの定型文なんだな。。。。。 別にマイナスしているわけではないような。。
これ逆にプラスにしたらどうなるんだろ？まあええかそんなことは


とするとオレのスタイルとしてはだよ、別にComparisonつかわんでも。。。勝手に昇順やってくれるんでしょ？


あああ、、、でもList.Sortの引数にはComparisonしか入らないのね。。。。
list.Sort((objA, objB) = >
{
	if (objA.horse_card_id == objB.horse_card_id)
	{
		  {
   			  objA.SplitImaginaryId() - objB.SplitImaginaryId();	
		  }
	}


>{ return obj1.index0 - obj2.index0; };
System.Comparison<TestData> sortIndex0 = (obj1, obj2)=>{ return obj1.index0 - obj2.index0; };
System.Comparison<TestData> sortIndex1 = (obj1, obj2)=>{ return obj1.index1 - obj2.index1; };
System.Comparison<TestData> sortIndex2 = (obj1, obj2)=>{ return obj1.index2 - obj2.index2; };
System.Comparison<TestData> sortIndex3 = (obj1, obj2)=>{ return obj1.index3 - obj2.index3; };

List<TestData> list = new List<TestData>();
list.Add( new TestData( 0, 0, 1, 1 ) );
list.Add( new TestData( 1, 0, 2, 3 ) );
list.Add( new TestData( 2, 0, 3, 5 ) );
list.Add( new TestData( 3, 1, 4, 7 ) );
list.Add( new TestData( 4, 1, 5, 9 ) );
list.Add( new TestData( 5, 1, 6, 2 ) );
list.Add( new TestData( 6, 2, 7, 4 ) );
list.Add( new TestData( 7, 2, 8, 6 ) );
list.Add( new TestData( 8, 2, 9, 8 ) );

list.Sort( sortIndex0 );
output(list);

list.Sort( sortIndex3 );
output(list);

list.Sort( sortIndex0 );
output(list);

list.Sort( (obj1, obj2)=>{

int result = sortIndex1(obj1, obj2);
if ( result == 0 )
{
  result = sortIndex3(obj1, obj2);
}
return result;
} );
output(list);


=====================================
 From: 大竹 克彦 (pzdb/CYCLONE-41/192.168.1.38/cyclone-staff-<bce74b5dfdd0877c>)
  at Mon Apr 04 19:00:15 201	6 (RSA2/認証)(封)
-------------------------------------
class TestData
  {
    public int index0;　順番
    public int index1;　horseid
    public int index2;　
    public int index3;　stamina

    public TestData(int i0, int i1, int i2, int i3 )
    {
      index0 = i0;
      index1 = i1;
      index2 = i2;
      index3 = i3;
    }

    public override string ToString ()
    {
      return string.Format ("[TestData]{0}, {1}, {2}, {3}", index0, index1, index2, index3 );
    }
  }
思考停止してるぞ、もう全然わからん

まず大竹さんの言うとおりに考えよう、先に同じhorseidかどうか考えるのが何より一番優先だと考える
ああ
①
{
	②
	{
		③
		{
		}
	}
}

こういうことなら
この③のグループからソートしなくてはいけないということか
そもそも、この③のグループは、ベース馬が同じはずで
パラメータは全部一緒なんだからさ、特別問題ないんですわ

まず大竹さんのスクリプトでわさ

	





	

list.Sort( (obj1, obj2)=>{

int result = sortIndex1(obj1, obj2);　これがhorseId
if ( result == 0 )
{
  result = sortIndex3(obj1, obj2); これがスピードとかスタミナ
}
return result;
} );

現状バアって渡してる、Listデータをobj1とobj2で個別ごとにソートすることはできるんだろうか・
他の人がやってるところにヒントはありそうだな


public class SortUltimate : SortBase
{
	private SortBase secondSort;
	public SortUltimate(SortBase s) { secondSort = s; }
	public override int Compare(NwDataUserHorse dataA, NwDataUserHorse dataB)
	{
		int evoA = System.Math.Max(dataA.GetMasterData().evolution_id2, dataA.GetMasterData().evolution_id3);
		int evoB = System.Math.Max(dataB.GetMasterData().evolution_id2, dataB.GetMasterData().evolution_id3);
		
		if (evoA > 0 && evoB > 0 || evoA < 0 && evoB < 0)
		{
		return secondSort.Compare(dataA, dataB);
		}
		
		if (evoA > 0 && evoB < 0)
		{
		return -1;
		}
		 else 
		{
		return 1;
		}
	}
}
まずこれをサンプルに考えてみようか、そうすれば答えがでるかも
この中身より呼び出し元が題字なんで和

     listDatas.Sort(new SortUltimate(GetSortClass(CurSortType)));
とありますなあ、GetSortClass(CurSorttype)　この組み合わせ一式は絶対に変更できない
だから何か包み込むしかないんだよ

IComparer<NwDataUserHors

なんか前リストを使わないで頑張ってた一時期と症状が似てるな
前は何が原因だったんだっけ。。。。
たしかそうだな・・・・

オレは何で二回ソート（固めるのと並び変えるの）しなきゃいけないとおもったんだっけ
確か俺のソートでは隣同士しかやってなくて、


今日いうことは

