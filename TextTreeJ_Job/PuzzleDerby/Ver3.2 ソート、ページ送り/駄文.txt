まずソートのクラスどこにあったっけ
たぶんHorseListSortの中だ、ここいじるだけだ

ver3.2.0				プレゼントBOXソート変更	初期を「保管期限順(短)」に。
				ソート記憶	"ソート切り換えした際そのまま記憶してください。
・プレゼントBOX
・チーム編成時選択
・合成ベース
・合成素材
・進化選択
・助っ人選択画面
・ホース売却
・進化アイテム売却
・フレンドリスト
それぞれでソート状態を記憶してください。"


それぞれのCurSortTypeをつくんなくては
前やった作業忘れちゃったけどたしかisSameSkillSortやらなにやら
んんｎ、HorseListManageBaseのCreateの第一引数やな

	if(!isSameSkillSort)
	{
		horseSort.ResetSameSkillSort();
		horseSort.Sorted();
	}

たぶんここの中の関数丸々いらなくなる

まあそれはおいといて

たぶんHorseSortListの
  static public HorseSortType CurSortType
  {
    get { return (HorseSortType)SaveData.HorseSortId; }
    private set { SaveData.HorseSortId = (int)value; }
  }

おいじるだけと思われる。


なんだいじるのSaveDataか
ん？なんか違うな

  public static int HorseSortId
  {
    get { return PlayerPrefs.GetInt( PlayerData.HorseSortId.ToString(), 0 ); }
    set { PlayerPrefs.SetInt( PlayerData.HorseSortId.ToString(), value ); }
  }
  
  private enum PlayerData
  {
    UserId,
    AliasCd,
    BgmFlag,
    SeFlag,
    ElementFlag,
    SkillFlag,
    NwCmdRaceAction,
    GameStatus,
    PointBack,
    UserSortId,
    HorseSortId,
    ItemSortId,
    BlockId,
    SecureCode,
    IsRetry,
    RaceCode,
    RacePage,
    AccountRetry,
    FindSnsId,
    RaceType,
    ModelType,
    PresentSortId,
  }

なにこれぇ。。。。


まあこれは置いといてHorseSortList

  static private List<List<HorseFilter>> horseFilters = new List<List<HorseFilter>>();
  static private List<List<HorseFilter>> temporaryFilters; // 特定の場所で一時的に使うフィルター(転生進化は指定した horse_card_id の馬だけ表示)
  static private List<List<bool>> horseFilterFlags = new List<List<bool>>();

たしか大事なのはhorseFiltersの方だよ、horseFileterFlagsはHorseListSort内でしか
使わないから。。。。。。。


今一種類しかないhorseFiltersを9種類に変更か
enum使おう

なんだ、セーブしてるっつっても再起動したら初期化してるわ


受け取るenum４つ必要か

EnhanceMainのEnhancePhase
FarmMenuのFarmPhase
HomeMenuのHomePhase
SellMenuのSellPhaseか

しかしHomePhaseはプレゼントしかつかわないんだよなあ
まあいいか



public enum HomePhase
{
  Top,
  Present,
  Information,
  Option,
  Collection,
}

public enum EnhancePhase
{
  Top,
  Confirm,
  MaterialSelect,
  Effect,
  Exp,
}

public enum FarmPhase
{
  Top,
  Team,
  Enhance,
  Evolution,
  Sell,
  Farm,
  EvolutionBox,
  NewCollection,
  Collection,
  Tutorial,
}

public enum SellPhase
{
  TypeSelect,
  HorseSelect,
  EvolutionSelect
}

public enum RaceMenuPhase
{
  Top,
  MultiSelect,  // multi 
  HostSelect,   // multi 
  NormalTop,
  NormalRace,
  SpecialTop,
  SpecialRace,
  Helper,
  Confirm,
  RankingEventTop,
  RankingEventRace,

  // multi
  MultiConfirm,		// my team select.
  MultiLobbySelect,	// guest only.
  MultiComment,     // host only.
  MultiLobby		// host only.
}


重要
・プレゼントBOX　　これはいらない×　　単一処理
・進化アイテム売却  SellPhase　　　これいらない×　　単一処理


なんで必要なのは
【HorseListSort】
・チーム編成時選択  FarmPhase
・合成ベース  EnhancePhase
・合成素材    EnhancePhase
・進化選択　　FarmPhase
・旧通常進化
・旧転生進化
・ホース売却  SellPhase

【FriendListSort】
・助っ人選択画面  RaceMenuPhase
・フレンドリスト  FarmPhase

だなあ

うーん・・・
これやりかた失敗したわ。。。。。
あうわ、プレゼントソートはもうスクリプトさえつくってないわ
PresentSort.csの中でComparisonしてる



なんだ、HorseSortListのほかに
LeiListSortみたいなのもあるのか


SortWindow.SetSortDatas　:227
EvolutionListManageBase.ShowSortWindow 　:179
EvolutionListManageBase.PushSortBtn 　169
TitleBoardManager.TouchExtra 　535
UIButton.OnInput 　:323
AutoSpriteControlBase.OnInput 　1175
UIManager.DispatchHelper 　1539
UIManager.DispatchInput　:1354
UIManager.Update　1303


そうか
public class SellEvolutionSelect : EvolutionListManageBase

SellEvolutionSelect選んではいるけど
使ってるのは基底クラスのEvolutionListManageBaseなんだ
ちなみこれを継承しているのは
SellEvolutionSelect以外にEvolutionItemBoxがある
まあ両方とも同じのつかいやいだろ、つまり現状でも多分
同じの使ってんでしょ？
使ってるわ、だから現状、いいんですよなくて
なくていいんです。隔離されてます。

なんだFriendListもFriendListSortいう別管理じゃないですかやだー
あ、でもFriendListSortはHelperでも使ってるわ。。。。
FriendListMain　244
HelperMain　163



ようはHorseListManageBaseつかってるとこの
ｿｰﾄは皆HorseListSortや
ではHorseItemListManageBaseはどうだろうか
あこれはHorseListSoetで共通や、共通や、共通なんや。。。。。


つまりようやくするとだな
二つソートスクリプト
HorseListSortと
FriendListSortに実装が必要なんや
現状、SellLeiには必要ないやろ、そこでしかつかってねえんだからよぉ

HorseListSortのResetSameSkilSort
これも多分いらなくなるなぁ

第二ソートはとりあえずおいておこう

基本リセット官益はHorseListManageBaseにしかないな

EnhanceMain.cs (14, 13):public class EnhanceMain : HorseListManageBase
EnhanceMaterialSelect.cs (9, 13):public class EnhanceMaterialSelect : HorseListManageBase
EvolutionBaseSelect.cs (6, 13):public class EvolutionBaseSelect : HorseListManageBase
FarmMain.cs (4, 13):public class FarmMain : HorseListManageBase
HorseListManageBase.cs (8, 14):public class HorseListManageBase : MenuBase
ReincarnationMaterialSelect.cs (8, 14):public class ReincarnationMaterialSelect : HorseListManageBase
SellHorseSelect.cs (3, 3):

HorseFileterFlagsのbool変えてるとこわかりにくすぎだろこれ
SortWindowの中の
  private void TurnOnAllButtons(List<bool> flags, CommonBtn[] buttons) {
もしくは
  private void TurnOnOneButton(int index, List<bool> flags, CommonBtn[] buttons) {
の
      flags[i] = i == index;

か、わっかりにくっ！！！！！！

あああ、参照が一つのとこさしてるから全部一緒に変わるんだ



あれか
  private enum PlayerData
  {
    UserId,
    AliasCd,
    BgmFlag,
    SeFlag,
    ElementFlag,
    SkillFlag,
    NwCmdRaceAction,
    GameStatus,
    PointBack,
    UserSortId,
    HorseSortId,
    ItemSortId,
    BlockId,
    SecureCode,
    IsRetry,
    RaceCode,
    RacePage,
    AccountRetry,
    FindSnsId,
    RaceType,
    ModelType,
    PresentSortId,
  }

のHorseSortIdの中に


public enum HorseSortType
{
  Name = 0,
  SpeedDesc,
  SpeedAsc,
  StaminaDesc,
  StaminaAsc,
  RecoveryDesc,
  RecoveryAsc,
  CostDesc,
  CostAsc,
  RarityDesc,
  RarityAsc,
  LevelDesc,
  LevelAsc,
  New, 
  Old,
  Element,
  Type,
  Sex,
  Favorite,
}

のいずれかの数値がはいってるのか


いつPlayerPrefのセーブデータを受け取っているかというと
SaveData.cs:176
HorseListSort.cs:53
HorseListSort.cs:154
HorseListManageBase.cs:136
EvolutionBaseSelect.cs:21
EvolutionMain.cs:146
EvolutionMain.cs:120
FarmMenu.cs:360



  static public void UpdateNewHorseIds()
  {
    NewHorseIds = newHorseIds.ToArray();
    IsUpdateNewHorseIds = false;
    FooterManager.Instance.UpdateBadge();
  }

  static public  double[]     NewHorseIds
  {
    get
    {
      string horseIdString = PlayerPrefs.GetString( "BadgeManager_NewHorseIds" );
      if( string.IsNullOrEmpty( horseIdString ) ) return null;
      return System.Array.ConvertAll<string,double>( horseIdString.Split( ',' ), delegate( string val ){ return double.Parse( val ); } );
    }
    set
    {
      string[] stringArray = System.Array.ConvertAll<double,string>( value, delegate( double val ){ return val.ToString(); } );
      PlayerPrefs.SetString( "BadgeManager_NewHorseIds", string.Join( ",", stringArray ) );


どうすればいいのかな
      PlayerPrefs.Save();
    }
  }

ここ一点
  private void TurnOnOneButton(int index, List<bool> flags, CommonBtn[] buttons) {
    for (int i = 0; i < flags.Count; ++i) {
      flags[i] = i == index;
      buttons[i].btn.GetComponent<UIButtonSupport>().normalColor = (i == index) ? Color.gray : darkGray;
    }
  }

EvolutionListManageBase?
あれ、所有進化アイテムもSortWindowを使ってるぞ
やばいな前のやつ消しちゃったよ
解決策が何も思いつかないんだけど
ターンが切り替わる


馬の８つの場面で使われているやつが
HorseListManageBaseで
HorseListSortにつながる


所有アイテム売却と所有進化アイテムで使ってるのが
EvolutionListManageBase
LeiListSortな

問題は両方とも表示ぬSortWindowを使っている点で、
オレSortWindowのアレ消しちゃったから、


とりあえず一体どこいじればいいんだ？
LeiListSortと、あとナニＨｅｌｐｅｒＬｉｓｔＳｏｒｔだっけ？
あ違う、ＦｒｉｅｎｄＬｉｓｔＳｏｒｔだ

カテゴリーをセットしよう
ＥｖｏｌｕｔｉｏｎＬｉｓｔＭａｎａｇｅＢａｓｅ
＞ＳｅｌｌＥｖｏｌｕｔｉｏｎＳｅｌｅｃｔ
＞ＥｖｏｌｕｔｉｏｎＩｔｅｍＢｏｘ


ヘルパーの方はbaseがなくて
＞FriendListMainと
＞HelperListの二つ



ver3.2.0				プレゼントBOXソート変更	初期を「保管期限順(短)」に。
				ソート記憶	"ソート切り換えした際そのまま記憶してください。
・プレゼントBOX
・チーム編成時選択
・合成ベース
・合成素材
・進化選択
・助っ人選択画面
・ホース売却
・進化アイテム売却
・フレンドリスト
それぞれでソート状態を記憶してください。"
				馬選択時のページ送り	ボタンで送るだけでなく、スワイプで送る→画面下にバーを出して、そちらでページ送りをテスト。
				助っ人追加	"現行、デッキ1のリーダーが助っ人として他人召喚されますが、1以外にも現在のデッキも表示。
→助っ人表示が倍に。今使っているデッキがデッキ1の場合は2つ表示。使用するとそのユーザーが消えるではなく、その助っ人が消える。
　(両方消えるではなく、片方のみ消える)"
				ローカルPUSH	出走pt満タン時に通知。
				イベントポイントでガチャ	
				メタップスSDK	決済部分にのみ入れてください
ver3.3.0				ホースポイント	"※パズドラのモンスターポイント
不要な馬売却→ホースポイント
ホースポイントで馬・進化アイテムと交換"







よし、ページ送り見るぞ
ページのボードはListArrowだ、ここを見る

PresentListが動かないスクリプト
動くのがHorseListとHorseItemListか


紛らわしいな
ReincarnationListManageBaseが今使われてなくて
ReincarnationNewBaseSelectがまだ使われてる


HorseListのlistArrowに関するコード全部抜き出すか


HorseList
｛
    if(num>0) {
      scrollList.AddItem(instancelistArrowsBottom.gameObject);
    }

  private void DetachContainer()
  {
    int count = listContainers.Count;
    for( int i = 0; i < count; i++ )
    {
      listContainers[i].transform.position = outOfPosition;
      listContainers[i].transform.DetachChildren(); //これに付いている馬アイコンをはずす
    }
    listContainers.Clear();
    instancelistArrowsTop = null;
    instancelistArrowsBottom = null;
  }

     if(instancelistArrowsBottom == null) {
       instancelistArrowsBottom = Instantiate( listArrows, new Vector3( 480, 0, 0 ), Quaternion.identity ) as ListArrows;
       instancelistArrowsBottom.SetCallBack( TouchPrevPage, TouchNextPage);


  // ページ送り矢印表示
  private void SetArrows()
  {
    int totalHorseNum = filteredHorses.Count;
    
    if(instancelistArrowsTop != null) {
      instancelistArrowsTop.ShowLeftArrow(GetPage(totalHorseNum)>1);
      instancelistArrowsTop.ShowRightArrow(GetPage(totalHorseNum)<GetMaxPage(totalHorseNum));
      instancelistArrowsTop.ShowPage(GetPage(totalHorseNum),GetMaxPage(totalHorseNum));
    }
    instancelistArrowsBottom.ShowLeftArrow(GetPage(totalHorseNum)>1);
    instancelistArrowsBottom.ShowRightArrow(GetPage(totalHorseNum)<GetMaxPage(totalHorseNum));
    instancelistArrowsBottom.ShowPage(GetPage(totalHorseNum),GetMaxPage(totalHorseNum));
  }
｝


PresentList
{

    instancelistArrowsBottom.transform.parent = container.transform;
    instancelistArrowsBottom.transform.localPosition = new Vector3( 10.0f, LayoutAdjuster.CalcOffset(-400.0f), -15.0f );


  // ページ送り矢印の読み込み
  public void InstanctiateArrows()
  {
     if(instancelistArrowsBottom == null) {
       instancelistArrowsBottom = Instantiate( listArrows, new Vector3( 480, 0, 0 ), Quaternion.identity ) as ListArrows;
       instancelistArrowsBottom.SetCallBack( TouchPrevPage, TouchNextPage);
     }
  }

  // ページ送り矢印表示
  private void SetArrows( int totalNum )
  {
    instancelistArrowsBottom.ShowLeftArrow(GetPage(totalNum)>1);
    instancelistArrowsBottom.ShowRightArrow(GetPage(totalNum)<GetMaxPage(totalNum));
    instancelistArrowsBottom.ShowPage(GetPage(totalNum),GetMaxPage(totalNum));
  }
}

PresentListの方が圧倒的にすくないな・・・・
・


いいけど被るな、NumPanelのY軸を42に変えたい。
しおり
元が2.5なのを42に変えてみよう


ああ面倒くさい

HorseList>HorseListManageBase>EvolutionBaseSelect>EvolutionMain
これはきつい、画面切り替わった瞬間が把握できない


あ、ClearListItemsがあるじゃん

やっぱ４０にしよう

問題としてはReincanationBaseSelectに移ったとき
既にInstantiateArrowsは呼ばれた後に
baseのアウト処理が呼ばれてDetouchContainerもよばれ
	if(instancelistArrowsBottom != null)
	{
		Destroy(instancelistArrowsBottom.gameObject);
	}
がよばれてしまうことである。


うううううううううんんんんんんん
起動直後、フラグはしっかりしたものが取れてるんだけど
フィルター情報が絞り込みに反映されていない
どないせっちゅうねん。。。。。
でもsortedはやってるはずなんだよなぁ
sortedやればflag情報から正常な馬データの絞りこみ手に入るはずなんだが

Tutaaegrga
下に移動したまんまスクロール外れると
120.5018
になる、
本当は36のはずなのよ
shopitemのトランスフォームね


TutrialArrow
-85





HorseSelectWindow.SetData :78
HorseListManageBase.ShowSelectWindow 210
EnhanceMain.SelectBaseHorse :106
HorseList.TapSprite  :500
HorseCardSprite.TapButton :739
UIButton.OnInput  323
AutoSpriteControlBase.OnInput 1175

284
336

protected int DefaultSort( NwDataUserData dataA, NwDataUserData dataB )
{
if( dataA.is_friend == dataB.is_friend )
{
	if( dataA.user_id == dataB.user_id )
	{
		return GlobalHelper.SortAsc( dataA.team_id
, dataB.team_id );
	}
	if ( dataA.elapsed_time == dataB.elapsed_time )
	{
		return GlobalHelper.SortAsc( (int)dataA.use
r_id, (int)dataB.user_id );
	}
	return GlobalHelper.SortAsc( dataA.elapsed_time, dat
aB.elapsed_time );
}
return dataA.is_friend ? -1 : 1;
}


全くの謎だよな、割り込むことはないってこと？
まあ確かにuserID一緒ってことはelapsedTimeも一緒ってことだよな
結局最後のelapsedTimeが見た目と違って最優先なんだろ？


一番最初にｿｰﾄにくるif(dataA.user_id == dataB.user_id)
一見これが最優先にみえるよなぁ
でも違うんだわ、結局一番上にくるのは、一番下に書かれてる
return GlobalHelper.SortAsc( dataA.elapsed_time, dat
aB.elapsed_time );
に適合したやつ。
elapsedTimeの優劣がないものの中からreturn GlobalHelper.SortAsc( dataA.team_id
, dataB.team_id );
が行われたりする
普段におif文と全く感覚が逆や。


しかし、まあ今回に限っていえば、userIDが一緒のものの間に違うuserIDが食い込むことは
ないわけだ
だってさ、最優先事項がelapsedtimeな訳だろ
userIDが一緒ってことはelapsedTimeも一緒ってことだから
その間に入り込むことは、elapsedTimeが最優先判断基準だとするならば
ありえないはずだ
どうして硬く結束している同じelapsedTime同士の間に
elapsedTimeを最優先上下基準としているsortの中で
他のelapsedTimeが食い込むことがあるだろうか（いやない）





public class SortBase : IComparer<NwDataUserData>
{
	virtual public int Compare( NwDataUserData dataA, NwDataUserData dataB )  
	{
	return -1;
	}

	protected int DefaultSort( NwDataUserData dataA, NwDataUserData dataB )
	{
		if( dataA.is_friend == dataB.is_friend )
		{
			if( dataA.user_id == dataB.user_id )
			{
				return GlobalHelper.SortAsc( dataA.team_id, dataB.team_id );
			}
			if ( dataA.elapsed_time == dataB.elapsed_time )
			{
				return GlobalHelper.SortAsc( (int)dataA.user_id, (int)dataB.user_id );
			}
			return GlobalHelper.SortAsc( dataA.elapsed_time, dataB.elapsed_time );
		}
		return dataA.is_friend ? -1 : 1;
	}
}
return GlobalHelper.SortAsc( dataA.elapsed_time, dataB.elapsed_time );
  public class SortFavorite : SortBase
  {
    public override int Compare( NwDataUserData dataA, NwDataUserData dataB )  
    {
      if( dataA.is_event_user != dataB.is_event_user )
      {
        return dataA.is_event_user ? -1 : 1;
      }

      if( dataA.is_favorite == dataB.is_favorite )
      {
        return base.DefaultSort( dataA, dataB );
      }
  


nnnnnんんん
デフォルトソートってのがホースリストソートにはないんだよな
ＨｏｒｓｅＳｏｒｔＴｙｐｅniｔ一つ追加した方がもっと面白いのかな

  public class SortBase : IComparer<NwDataUserHorse>
  {
    virtual public int Compare( NwDataUserHorse dataA, NwDataUserHorse dataB )  
    {
      return 1;
    }
  }


  public class SortUltimate : SortBase {
    private SortBase secondSort;
    public SortUltimate(SortBase s) { secondSort = s; }
    public override int Compare(NwDataUserHorse dataA, NwDataUserHorse dataB) {
      int evoA = System.Math.Max(dataA.GetMasterData().evolution_id2, dataA.GetMasterData().evolution_id3);
      int evoB = System.Math.Max(dataB.GetMasterData().evolution_id2, dataB.GetMasterData().evolution_id3);

      if (evoA > 0 && evoB > 0 || evoA < 0 && evoB < 0) {
        return secondSort.Compare(dataA, dataB);
      }

      if (evoA > 0 && evoB < 0) {
        return -1;
      } else {
        return 1;
      }
    }
  }



  public class SortReincarnation : SortBase {
    private SortBase secondSort;
    public SortUltimate(SortBase s) { secondSort = s; }
    public override int Compare(NwDataUserHorse dataA, NwDataUserHorse dataB) {
      int evoA = dataA.SplitImaginaryID
      int evoB = System.Math.Max(dataB.GetMasterData().evolution_id2, dataB.GetMasterData().evolution_id3);

      if (evoA > 0 && evoB > 0 || evoA < 0 && evoB < 0) {
     　　比較対象の両方が究極進化をおもっている、もしくは両方が持っていない
        return secondSort.Compare(dataA, dataB);
      }

	比較対象の片方が究極進化を持っている。
      if (evoA > 0 && evoB < 0) {
        return -1;
      } else {
        return 1;
      }
    }
  }

今回のSortReincarnationでは、horse_idが一緒ｔってことはつまり進化先が複数に分かれている
ってことなんだよね


	
  static private void SortReincarnation(ref List<NwDataUserHorse> listDatas)
  {
	int length = listDatas.Count;
	for(int count = 0; count < length - 1; count++)
	{
		int tmpCount = 0;
		for(int add = 1; count + add < length; add++)
		{
			if (listDatas[count].horse_id == listDatas[count + add].horse_id &&
				listDatas[count].SplitImaginaryId() > 0 &&
			    listDatas[count + add].SplitImaginaryId() > 0)
			{
				NwDataUserHorse tmp = listDatas[count + add];
				listDatas.RemoveAt(count + add);
				listDatas.Insert(count + 1, tmp);
				tmpCount++;
			}
		}
		count += tmpCount;
	}

	for(int count = 0; count < length - 1; count++)
	{
		int mostUnderNum = count;
		int add = 1;

		while(listDatas[count].horse_id == listDatas[count + add].horse_id &&
			  listDatas[count].SplitImaginaryId() > 0 &&
			  listDatas[count + add].SplitImaginaryId() > 0)
		{
			if(listDatas[mostUnderNum].SplitImaginaryId() > 
			   listDatas[count + add].SplitImaginaryId())
			{
				mostUnderNum = count + add;
			}

			add++;
			if (count + add >= length)
			{
				break;
			}
		}

		if(mostUnderNum != count)
		{
			NwDataUserHorse tmp = listDatas[mostUnderNum];
			listDatas.RemoveAt(mostUnderNum);
			listDatas.Insert(count, tmp);
		}
	 }
  }

  
こんなにシンプルですわたし
結局overrideすること前提だもんなこれ
結局これってnarrowの関数なの？ソートの関数なの？
NarrowじゃなくてSort用だな
NarrowはSorted関数呼ばないと実行されない
んで今回はNarrowじゃなくて、旧点生進化画面での
sortのReincarnationの話です
で、このSortのReincarnationは、優先順位的には結構低いはず
一般に用意されてるSortの関数が実行されて、その上で同一の場合
なんかあれするんだ

      return dataA.is_favorite ? -1 : 1;
    }
  }

うーんhorseListSortの全部のクラスにDefaultSort突っ込むと思うと
気が遠くなるな



そもそもホームバナーマネージャーは


243	ver3.1.0(ホームデザイン変更から発生）	ホーム画面	"既によんでいる画像を表示、非表示に変更をかけると
ホームバナー一覧の下の●が重なって表示されてしまいます。"

[12:38:47] 栗田 崇弘: 今ステージの状態でホーム画面にいくと1番目にレジェンドフェスのバナーが見えると思いますがその状態で非表示にしてそのままホースなどのメニューにいきもう1度ホームに戻ると再現確認はできると思います。

必要であれば非表示の対応を行いますので声をかけてください。
よろしくお願いいたします。

bannerMoveTime 8 >> 800