フォトンのバグについて考えよう
まず何からしようか、たぶん落ちるのに関しては
ただの遅延で、リトライをやっていないだけだ
そうだとするとだね

あのパズルが上半分に表示されるバグを研究した方が
効率がいいんじゃないかなあ


通信が切断されました
このままレースうんぬんは絶対見たことある

普通のPhotonVIewとかのRPC内で擬似遅延起こしても
ゲストの退出としか表示されない
いったいどこのブレークポイント貼ったらあのこのママレースをうんたらってでるんだっけ

もしくはRPCじゃなかったかなあ
でも、


NetworkingPeer.ExecuteRpc 　:2283
NetworkingPeer.OnEvents　:2059
ExitGames.Client.Photon.PeerBase.DeserializeMessageAndCallback (inBuff={byte[33]}) in 
ExitGames.Client.Photon.EnetPeer.DispatchIncomingCommands () in 
ExitGames.Client.Photon.PhotonPeer.DispatchIncomingCommands () in 
PhotonHandler.Update


　:125


　　PhotonNetwork.RPC　:2911
　　PhotonView.RPC　:569
　　PhotonManager.SendSyncData 　:157
　　PhotonManager.SuccessCheck 　:116　　問題なし
　　UnityEngine.MonoBehaviour.StartCoroutine 　:62
　　PuzzleLogic.SetMultiSamePieces　:786
　　UnityEngine.MonoBehaviour.StartCoroutine 　:62
　　GameLogic.Start　362


PhotonNetwork.RPC　:2911　　
PhotonView.RPC 　157
PhotonManager.SuccessCheck　116
UnityEngine.MonoBehaviour.StartCoroutine 　62
PuzzleLogic.SetMultiSamePieces 　786
UnityEngine.MonoBehaviour　:62
GameLogic.SetMultiSamePieces 　915
UnityEngine.MonoBehaviour.StartCoroutine (routine={GameLogic}) 　:62
GameLogic.MainLogic　804
GameLogic.Update　715


PhotonManager.ReceivePieceData　181
System.Reflection.MonoMethod.Invoke　:222
System.Reflection.MethodBase.Invoke　:115
NetworkingPeer.ExecuteRpc 　2406
NetworkingPeer.OnEven　:2059
ExitGames.Client.Photon.PeerBase.DeserializeMessageAndCallback (inBuff={byte[210]}) in 
ExitGames.Client.Photon.EnetPeer.DispatchIncomingCommands () in 
ExitGames.Client.Photon.PhotonPeer.DispatchIncomingCommands () in 
PhotonHandler.Update 　125



うーんなんか再現できたけど詳しい内容ようわからんあああ

じゃあもうええわこれは
PhotonのSendがおかしいのか、PuzzleLogicがおかしいのか
なんかSendがおかしい気がするな、
Sendのパズルミノの位置情報ってどうやって渡してるんだ

とりあえずPhotonのSenｄPieceData
から見てみる？
その前の段階PuzzleLogicの SetMultiSamePieces
ですでに得意な能力を１つぐら
い持ってる
いや違う、


可能性としては何がある？
SendPiacedaDataで渡すSendDaaに間違いがある
そもそもこのsendDataに何型なんだ？

P2PDataPiece sendData = new P2PDataPiece();
だ


PuzzleLogic 815行目から
      if(sender)
      {
        P2PDataPiece sendData = new P2PDataPiece();

いきなりわかんねえな、なんだこれ、pieces.Lengthって
いっかいもこれnewされてねえぞ
いくら見てもわからん、これはとりあえずおいておこう
その前に、このP2PDataPiecって関すを見てみよう
        sendData.pieces = new PieceColor[pieces.Length];
        for(int i=0;i<pieces.Length;i++)
        {
          sendData.pieces[i] = pieces[piecesMap[i]].PieceColor;
        }
#if !OLD_MULTI
        PhotonManager.SendPieceData( sendData );

これみてみようか、


なんでこんなに難しいんだ
pieces.Lengthなんて値出てくるわけねえだろ
どこにも数が代入されてないんだから

でも代入されてないってことはありえないよなぁ
あ


  public static readonly int puzzleTotal  = 42;
うーん、本当にぃ？
本当だ　6x7 で４２だ

        P2PDataPiece sendData = new P2PDataPiece();
        sendData.pieces = new PieceColor[pieces.Length];
        for(int i=0;i<pieces.Length;i++)
        {
          sendData.pieces[i] = pieces[piecesMap[i]].PieceColor;
        }

うーん、piecesMapは配列４２まであるはずなんだよなぁ
  private int[] piecesMap = new int[PuzzleConfig.puzzleTotal];

とするとだねぇ、forループかカウントゼロから始まっているから
うーんやっぱなんか、peces.Lenghも４２までないとなんかおかしいきがする
pieceMapは42個のピースの全ての色を覚えているわけだろ？


パズルデータ、左下から左上の42個のデータ、全て
recievePieceに渡している。

重要凄い重要
そもそもsendとrecieveってどこのスクリプトにあるんだっけ
PhotonManagerですなぁああああ

　　public void ReceiveSyncData( int userId )

　　PhotonNetwork.RPC　:2911
　　PhotonView.RPC　:569
　　PhotonManager.SendSyncData 　:157

　　Line170 重要　超重要S
    // ピース情報送信
    public static void SendPieceData( P2PDataPiece data )
    {
    Debug.Log("SendPieceData");
    scenePhotonView.RPC("ReceivePieceData", PhotonTargets.Others, data.pieces);
    }


とりあえず下層的な流れとして一番大事なのは
PuzzleLogicの774行目、SetMutiSamePiecesから
その中の824行目、PhotonManager.SendPiedeData(sendData)がかなり重要

で、そこから
  // ピース情報送信
  public static void SendPieceData( P2PDataPiece data )
  {
    Debug.Log("SendPieceData");
    scenePhotonView.RPC("ReceivePieceData", PhotonTargets.Others, data.pieces);
  }
このP2PDataPieceってのは、なんかよくわからん変数一つと
ピースの情報が入ってるシンプルなやつ、
実質、相手の端末に送る情報はまじでピース情報だけ

  // ピース情報受信
  [PunRPC]
  public void ReceivePieceData( int[] color )
  {
    Debug.Log("ReceivePieceData");
	foreach (var item in color)
	{
	  Debug.Log ("いがああああああ" + (PieceColor)item);
	}
    puzzleLogic.SetReceivePieceData( color );
    ReceiveWait = false;
  }

ここでP2PDataPicesからパズルの色情報42色全てをを受け取って、puzzleLogicの
SetReceivePieceDataに渡す。

んでPuzzleLogicの866行目
SetReceivePieceDataにいくと
んで      pieces[piecesMap[i]].SetPieceColor( (PieceColor)receive[i] );　で
一個ずつピース情報をセットしていく。


んん、ここまでの一連の流れだと、パズルの位置が変わることはありえない
SetAnimationでアニメ変えてるだけだし、

パズルのpositionが変わる可能性があるのは
PuzzleLogciと、ato
Pieces。ｃｓぐらいだわ
いったいどっちが可能性あるんだおるか
更にそのコードの中のどれが一番可能性が高いんだろうか

んんんんｎ、何か、、、
Piece.cｓの350行目

  public void ResetPosition( int x, int y )
  {
    IsMoved = false;
    myTransform.localPosition = new Vector3( PuzzleConfig.pieceSize.x * x,
 -( PuzzleConfig.puzzleHeight - 1 - y ) * PuzzleConfig.pieceSize.y, -1 );
  }
がなんか怪しい感じがする。

バグ情報見ると自分のターンになった瞬間位置がずれるみたいだな


うーんなんか
MultiPlayManager.ReceiveWait = false;
が下記だな


ううん、
puzzleLogicのCheckMatchも怪しいところではあるな
もう一つ怪しいのは
GameLogicのＵｐｄａｔｅ内
    if(MultiPlayManager.MultiPlayFlag && (!(MultiPlayManager.ReceiveWait) && waitSeed == false))
の後だなぁ
いやCheckMatchはシングルプレイでも通るからな、微妙なところか




ほうほう、画像素材から見ていくか
「あなたの順番です」いう画像は、ＭｕｌｔｉＰｌａｙＴｕｒｎＩｎｆｏね
これはMultiPlayInGameManagerてオブジェクトの子要素で
この親と紐付けられている
ただしpublicで代入しているわけじゃなくて
    turnInfo            = multiPlayTurnInfo.GetComponent<MultiPlayTurnInfo>();
って式で代入している。

あなたの順番です！の看板は、ＭｕｌｔｉＰｌａｙＧａｍｅＭａｎａｇｅｒの中の
263行目、StartPlayInfoで呼び出されている。

さらにさかのぼっていくと
  void Update () {
  }
  public void UpdateUI() {
    MultiChatButton.SendLimit = 10;
    MultiPlayInGameManager.multiTimeOverCnt_f = 0;
    if(MultiPlayManager.RestTurn == 0) {
      LHDebug.Log("◆◆◆◆◆自分のターンです◆◆◆◆◆◆");
      PlayTurnInfo();
のPlayTurnInfo();で看板が呼び出されている。


まあこれまるっきり独自でやってみるみたいでわからんな
PhotonHandler見たほうがいいわ

うーん、PhotonHandler.Updateはなんか終了作業のときに使われているみたいだなぁ
ＧａｍｅＬｏｇｉｃ．Ｕｐｄａｔｅの方が正しそうだわ
でもあれ一回みたけどな
見てよくわからんかったわ、あそこからどうやって最初のパズル同期処理に繋がるんだよ


ああでも少し分かったわ、完全にこれ新しくパズルの組み合わせ作られている
前のターンのやつを継承していない
まずパズルの並びを自動生成しているところみつけろや
話しはそれからだ

たぶんPuzzleLogicのＲｅｓｅｔＰｉｅｃｅですね
ここの中のif(isRandame==true)のところが呼ばれている
つまりもっと突き詰めると
          pieces[ index ].Init();　がピース一つ一つの色をランダムで決めている
ちょっと中見てみようか

  public void Init( PieceColor color = PieceColor.Random )
  {
    SetPieceSpriteColor( PieceColorState.Normal, 1.0f );
    state = PieceState.Idle;
    ComboCount   = -1;
    IsCheckRight = true;
    IsCheckUp    = true;
   
    SetPieceColor( color );
  }

なんかenumにRandamって予約文字入れるとランダムに何か突っ込んでくれるみたいよ

しかし謎の構文もいくつかあるなぁ

for( int y = PuzzleConfig.puzzleHeight - 1; y >= 0; y-- )
{
	int row = y * PuzzleConfig.puzzleWidth;
	for( int x = 0; x < PuzzleConfig.puzzleWidth; x++ )
	if( isRandom )
	{
	  pieces[ index ].Init();
	  // Debug
	  pieces[ index ].transform.localPosition = new Vector3
	( PuzzleConfig.pieceSize.x * x, -(PuzzleConfig.pieceSize.y *(PuzzleConfig.puzzleHeight-y-1))  , -1 );
	}

うーんこの構文いろんなところに転がってて訳がわからん
ResetPieseやらResetPositionやら
一番最初の読み込みの段階でResetPiese＞ResetPosition何回も呼ばれてるがな
というか一番最初の読み込みでしかよばれてねえじゃねえかここじゃねえよ
ResetPieseは最初だけ
ReserPositionsはゲーム復帰でしか使われない、

とすると、
FallLogicはゲストでもホストでも毎回呼ばれてる。
でもここはどうなんだろうか・・・・
piecesMapが更新されないままなんかあれやこれややったらどうなる？
はたして空白が生まれるか？
そもそもフリーズして空白ってのは当てにならんよな
それって、フリーズがとければ単純に上から降ってくるってことでしょ？
ユーザーの言うフリーズしてないのに、空白になるってことには合致しない樹がするよ？
実際はピースは埋まってるのに何故かanimationで透明になっているか
もしくは、

はあつらいわかんない

もしくは、問題点をまとめようぜ、自分のターンにくる直前でもう
ブランクができている。
自分のターンにきた瞬間パズルの位置がずれる
だから、スキルはまあ、とりあえず置いておこう
うーん、盤面全部真っ暗ってあるけどどうなんだろ
真っ暗になるとどうなるんだろうか、これ擬似的に押せないかな

puzzleLogicの1249行目
SetColorｓがめっちゃあやしい、あやしいいんわ
そもそも
なんやこれ、チュートリアルとゲーム復帰にしかつかってねえじゃねえか











このrowってナンや？
まずPuzzleConfig.puzzleHeight - 1から見ていこうか
これどうせ定数でしょ
６だってよ、
つまり最初にｙに５が代入されて、　ｙがゼロより多い限り１ずつマイナスされていく
あれこれyが0のときもマイナスしてるじゃねえか
つまり5からー１にyは変わっていくのか

とするとこれなぞだよなあ
new Vector3
	( PuzzleConfig.pieceSize.x * x, -(PuzzleConfig.pieceSize.y *(PuzzleConfig.puzzleHeight-y-1))  , -1 );

なんなのこのわけわからん公式
puzzlesizeは44,44で確定でしょ　とすると代入すると

-44 * (6 - y - 1)   がYの座標？？？
yは5からｰ1まで変遷するから
-44*(6 - 5 - 1) =　ゼロ、　しんでるじゃねえか
最小地は
-44 * ( 6 + 1 - 1)  = - 264 んんんんんんんんんんｎ？

そもそもマイナスって上なのかしたなのか、

重要
マイナスはUnity上では下だ・・・・・・


ううううううううううううううう、Puzzleの構成の初期化
PuzzleLogicのStartからしか実行されてねえぞ
とするとさ、


ううううん、pieceのCopyDataｍ、現在つかわれておりませんｌ。


なんでGameLogicのUpdateが639
行目にあるんだよ


PhotonNetwork.RPC　:2911　　
PhotonView.RPC 　157
PhotonManager.SuccessCheck　116
UnityEngine.MonoBehaviour.StartCoroutine 　62
PuzzleLogic.SetMultiSamePieces 　786
UnityEngine.MonoBehaviour　:62
GameLogic.SetMultiSamePieces 　915
UnityEngine.MonoBehaviour.StartCoroutine (routine={GameLogic}) 　:62
GameLogic.MainLogic　804
GameLogic.Update　715

なんだっけナニしようとしてたんだっけ

















public enum PieceColor
{
  None = -1,
  Pink = 0,
  Red,
  Blue,
  Green,
  Yellow,
  Brown,
  Clear, // 2014/8/1
  Poison, // 2014/8/1
  Special,
  Max,
  Random,
}
コントロール パネル\すべてのコントロール パネル項目\個人設定


んんんんｎ全然ん検討つかねえけど
推測でかたるしかねぇな
わからん、どうしようか、推測するにしても材料がなさすぎる
でも空白ができるとかまでいいかんじじゃない
じゃああれか、同期ｱﾆﾒｰｼｮﾝが途中でとまるとおかしくなるのか

同期ｱﾆﾒｰｼｮﾝは何処でやってるんだ？
とりあえずPirces.cs見てみるか

そういえばなんか新スキルですかとかなんとか御託こいてたな
なんらかのスキル発動のときに生まれるあれか



駄目だこれ、ｱﾌﾟﾛｰﾁを変えよう、なんで位置が変わるかを調べたほうがいい気がする
ＰｈｏｔｏｎＭａｎａｇｅｒの
SendPieceDataやらSendSkillDataやらの中身を変えたり
通信遅延をためしたけど際限できす

そもそもなんでパズルの位置があんなにかわるんだろうか
















んんんとなんか
  public void SetPieceSpriteColor( PieceColorState state, float alpha )
と
  public void SetPieceSpriteColor( PieceColorState state )

この２つがあやしくもある
いや  public void SetPieceSpriteAlpha( float alpha )
が一番あやしいようなきもする　

みたところSpriteAlphaで
  private void SpecialMoveLogic()と
SimpleBanishLogic
  public static bool MultiplayFallWait{get;set;}
ＦａｌｌＭｏｖｅ
でalphaがゼロに設定される可能性はなきにしもあらず


たとえば予想だけど、Banishが呼ばれたのにも関わらず
Fallがその後よばれないとかは？

くそっわかんねえなあ、ここから探すのは止めるか


パズルが透明になるんじゃなくて、位置がずれてるのはどう？
これユーザーのバグレポからも推測できる
有効な筋立てじゃない








はあああああああ
わかるわけねえだろくそやろうがてめえ


16:15だから、19:00をLIMITとすると、あと2:3しかねえぞ
もし位置情報のご入力が問題だとするなら
FallLogicか　　PuzzleLogic.SetMultiSamePieces　:786
だよなああ

あとは何かUpdateで南下やってたような気がしないでもないが



んんん、、ピースの色変えてるところはわかるんだけど
具体的なピースの位置を変えている場所が分からない
SetMultisamePicesでやっているようにも思うけど
今回はターンが自分に回ってきた瞬間に起こるバグだからなぁ

とりあえずドラッグ領域のみ正常な場所にピースが移動するんだろ？
とするとだよ？
とりえ合えずドラッグ時のスクリプオｔの位置を見てみるといいんでは
しおり
んPuzzleLogicの322行目MainLogicの
中あたりがやっぱり怪しい気がしてきたな
なんか958行目  public void StartDrag( Vector3 pos )も怪しいぞ
重要
んんん、このStartDragお通った瞬間まともなマッピングになるんだよなあ

未だにこの  pieceMapってのがよく和漢ね円だけど

public static readonly int puzzleTotal  = 42;
  private int[] piecesMap = new int[PuzzleConfig.puzzleTotal];
piecesMap[ ty * PuzzleConfig.puzzleWidth + x ] = tmpFallMapId[ty];
pieces[ piecesMap [ curIndex ] ].SwapMove( (MoveDir)(curIndex - prevIndex ) );


んんｎなんとなく予想だけど、pieceMapってのはとにかく42配列あって
pieceMap[0]が一番左下のピース、pieceMap[41]が一番右上のピースってことが分かってる
だからｘだのｙだのいう座標は入ってねえんだよ

  /// </param>
  public void StartDrag( Vector3 pos )
  {
    SetDragXY( pos, out curDragX, out curDragY );
	このindexは0 ~　41の値確定だよなあ
　　つまりcurDragx は　0～6確定　curDragY は0～６確定だふざけんななんだこれ
    int index = curDragY * PuzzleConfig.puzzleWidth + curDragX;
    curDragItem = pieces[ piecesMap[ index ] ];
    //dragPiece.CopyData( curDragItem );
    dragPiece.SetColor( (int)curDragItem.PieceColor );
    curDragItem.SetDragMode( true );
    puzzleDragTimer.StartTimer();
    isDrag = true;
  }

ちょっとまてよ、pieceMapってintの配列だよな
一体何の数値情報を格納してんだ

ResetPieceに一番単純な情報があるわ
  public void ResetPieces()
  {
    ResetCombo();
    for( int y = PuzzleConfig.puzzleHeight - 1; y >= 0; y-- )
    {
      int row = y * PuzzleConfig.puzzleWidth;
      for( int x = 0; x < PuzzleConfig.puzzleWidth; x++ )
      {
        int index = row + x;
        piecesMap[index] = index;

つまり、やっぱり位置情報はいってるじゃねえか！

重要
マイナスはUnity上では下だ・・・・・・
で、なんだこれ
しおり
  public static readonly int puzzleWidth  = 7;
  public static readonly int puzzleHeight = 6;
だもんだから
あれ、おかしいな、左下から右上だったとおもうけど
まあとにかく、たぶん初期情報だと
pieceMap[0] = 0, pieceMap[1] = 1, pieceMap[41] = 41
ていうそのまんまの情報が入ってる
つまりこれは移動に使う情報だ。

35, 36, 37, 38, 39, 40, 41
28, 29, 30, 31, 32, 33, 34
ってループかなんだこれふざけんな
だからやっぱり具体的なｘとかｙ座標はいってねえんだよ！！



お、最後にisDragがtrueになるから
MainLogicが動くぞ
   if( isDrag )
    {
      MultiPlayManager.IsInputStarted = true;

      // ドラッグ継続
      if( isInputting )
      {
        int x, y;
        touchWorldPos.z = -3;

        // 現在のドラッグ位置を設定
	たぶんこれも複雑世界座標に対して
 0から　６しか出力されねえんだろ？
        SetDragXY( touchWorldPos, out x, out y );

        // 前回の位置と変更があればチェックフラグをたてる
        if( x != curDragX || y != curDragY ) 
        {
          bool isCanSwap = true;
          if( nextPosIndex <= nextPosTarget )
          {
            if( x == positions[nextPosIndex].x && y == positions[nextPosIndex].y )
            {
              nextPosIndex++;
            }
            else
            {
              isCanSwap = false;
            }
          }
          else if( nextPosTarget != -1 )
          {
            isCanSwap = false;
          }
          
          if( isCanSwap )
          {
            SwapItems ( x, y, curDragX, curDragY );
            curDragX = x;
            curDragY = y;

            if(isSenderMode && !isChange)
            {
#if !OLD_MULTI
              PhotonManager.SendStateData();
#else
              MultiplayPlugin.SendData(new P2PDataThinkingState());
#endif
            }
            if(isEditor && MultiPlayManager.IsMultiOtherTurn && !isChange) {
              MultiPlayManager.InputState = ThinkingState.Inputting;
            }

            //if (isChange == false && BlockMoveCallback != null) {
            //  BlockMoveCallback();
            //}
            isChange = true;
            SoundManager.Instance.PlaySe( SoundManager.SeType.PuzzleSwap, false ); 
          }
        }

        // ドラッグ位置に追従
        touchWorldPos.y += PuzzleConfig.pieceHalfSize.y;
        dragPiece.SetPosition( touchWorldPos );

      }





んんんんんんんんん！？
見えたか？
重要
 pieces[ index ].transform.localPosition = new Vector3( PuzzleConfig.pieceSize.x * x, -(PuzzleConfig.pieceSize.y *(PuzzleConfig.puzzleHeight-y-1))  , -1 );

for( int y = PuzzleConfig.puzzleHeight - 1; y >= 0; y-- )
{
int row = y * PuzzleConfig.puzzleWidth;
for( int x = 0; x < PuzzleConfig.puzzleWidth; x++ )
{
int index = row + x;
piecesMap[index] = index;
if( isRandom )
{
  pieces[ index ].Init();
  // Debug
  pieces[ index ].transform.localPosition = new Vector3
( PuzzleConfig.pieceSize.x * x, -(PuzzleConfig.pieceSize.y *(PuzzleConfig.puzzleHeight-y-1))  , -1 );
}

そうかそうか、piecesは最初からヒエラルキにあるんだ
pieces自体のpsitionは
x = 29, y=-320.8889で
piecesの子要素でx = 0 y = 0 だと一番左上のピースになる
 x = 0 , y = 44 で一番左上から右に一つずれたピース
ｘ=０、y = -220で一番左下のｓピース


 pieces[ piecesMap[row + x] ].StartFall
( new Vector3( PuzzleConfig.pieceSize.x * x, -PuzzleConfig.pieceSize.y *  (PuzzleConfig.puzzleHeight-y-1) , -1 ) );
つまりこのVector３の値は(0, 0, -1 ～　244, 288, -1）の範囲内の値しか指定されない


んん、全ての子要素のｙ軸を+264にするか
親要素のpieces自体のｙ軸を+264するしかない
んん pieces[35] = { 0, 0, -1}なんだろ？
これが pieces[35 = { 0, 264, -1 } になることなんてないだろ

   pieces[ index ].transform.localPosition = new Vector3
( PuzzleConfig.pieceSize.x * x, -(PuzzleConfig.pieceSize.y *(PuzzleConfig.puzzleHeight-y-1))  , -1 );
この式に従うと、indexが　35のときは、y　が　６なので、　PuzzleConfig.puzzleHieght - y - 1　で　０
- PuzzleCongig.piecesSize.y( = 44) * 0 = 0 ね
この値が　+ 264 になるには、　逆算すると
２６４　/ 44 をすると　６ね　でも実質　-6 じゃ無くちゃいけない、
puzzleConfig.puzzleHeightが7だから、 y - 1　の　値が　- 13 っていう途方もない値じゃないといけない
これはありえない　つまりどうにかして　yが　-12 じゃないといけない

子要素一個ずつこの意味不明な値にすることは考えづらいか









タイミングとしては結構はっきりしてて
SendPieceとかRecievePieceの処理のときは特に異状がない
ターンが自分に切り替わった瞬間に異状がでる
PuzzleLogicの中のMainLogicで何か異状が出てるんじゃないかと思う

StartDragの処理がはじまった時に
移動させたピースだけ座標が正常になる

左下の7つの塊のピースが全く一緒なので
やっぱり全てのピースが+264、y軸に移動してる
まるでそこに升目があるかのうように、全てのピースが綺麗な平行移動仕方をしてて
なんかコードを見る限りではそんなことありえない気がしたんで
ピースの親オブジェクトがなんらかの理由で264上に移動してるんじゃないか



-232　pieace0



んんｎもう正直全然わからんよな
もうこのタスクやめたいんだけど、とりあえず自分のターンになる直前の関数が知りたい。
しょうじきもうわかんねえんだけど


puzzleLogicのMainLogic事態は細かにずっととってるんだよな
ただ自分のターンにきたときに
真っ先にMainLogicの中の
    if((!MultiPlayManager.MultiPlayFlag || isSenderMode || isEditor))
の中が呼ばれるってだけで
つまり
重要
MultiPlayManager.MuletiPlayFlag
isSenderMode
isEditor
のいずれかの値を変えている関数を調べればいいんだな

まず
【MultiPlayManager.MultiPlayFlag
あ、これはマルチじゃないとずっと自分のターンってことか
今回はMultiのこと調べてるからここはすっとばしていいな

【isSenderMode】
これあやしくね、これあやしいよな、、もうこれでいいや
C:\Project\PuzzleDerby\PuzDurbAndroid_Trunk_p3\Assets\GameScenes\Puzzle\Scripts\PuzzleLogic.cs (344, 10):    bool isSenderMode = (MultiPlayManager.IsMultiSelfTurn )/*&& multiDragData == null )*/;

変えてる場所はこの一点だな
あ、MainLogic内の直前で変えてるやんけ
 bool isSenderMode = (MultiPlayManager.IsMultiSelfTurn 
だがちょっと待てよ。これ直前なようで直前じゃないぞ
中を見てみると
MultiPlayManagerに富んでてて
  /// <summary>
  /// マルチプレイで自分のターンならtrue.
  /// </summary>
  public static bool IsMultiSelfTurn {
    get {
      if(!MultiPlayFlag) { return false; }
      return RestTurn == 0;
    }
  }
となっている

じゃあこのMultiPlayManagerの中のMultiPlayFlagを変えてる場所はどこか？
あれ、どこでも一切変えてないぞ、ずっとfalseじゃね？
ちょっとprintで見てみるか

あれええ、isSenderModeがどっかで変わってんな？
どこか￥だ
やっぱり、MultiPlayFlagはずっとTrueのまんまだ
とすると、RestTurnを強制0にしてるんでわ
まとにかくこのisSenderMode一択ですな問題点わ
とするとだね

このRestTurnは一体いつ強制ゼロ代入されてるんだ？

いや違う、違うぞ
あれえええええ
 /// <summary>
  /// マルチプレイで自分のターンならtrue.
  /// </summary>
  public static bool IsMultiSelfTurn {
    get {
      if(!MultiPlayFlag) { return false; }
      return RestTurn == 0;
    }
  }
もし	MultiPlayFlagがずっとTrueだったとしたら
MultiPlayManager.IsMultiSelfTurn は問答無用でずっと
ああそうか、ずっとTrueだから
  if(!MultiPlayFlag) { return false; }
は無条件ですっ飛ばされるんだ
じゃあやぱRestTurn==0じょう条件式が鍵なんだけど
RestTurnもこれまた値を変えているところを見たことがないのう

あ、RestTurnもプロパティか
  public static int RestTurn {
    get {
      if(NowPlayerCnt <= 0) { return 0; }
      // プレイ人数、自分は何Pか、自分は何番目か
      return ((NowPlayerCnt + NowPlayerNumber) - TurnNumber) % NowPlayerCnt;
    }
  }
うわ複雑な計算式やってんじゃねえよ面倒癖恵那
でも結局のところNowPlayerNumberがずっとゼロだから、
大事なのはNowPlayerCntとTurnNumberだけだな結局
んでNowPlayerCntは現在プレイヤー総数、２リプレイなら２固定
TurnNumberが０（ホスト）１（ゲスト）の区別だけ
んで結局計算式の結果は０か１しかかえってきいへんよ
まんまTurnNumberの値だね。

じゃあつまりTurnNumberがどこで切り替わってるかを見ればいいのか
すげえいろんなところで切り替えてるけど
一応全部のせるか

MultiPlayerManager
Line131
  /// <summary>
  /// TurnChargeでフラグが立っていればターンを一つ進める.
  /// </summary>
  public static void AddTurn() {
    if(!turnCharge) {return;}
    TurnNumber = (TurnNumber + 1) % NowPlayerCnt;
    turnCharge = false;
  }

ああ実際ここだけかな変えてるの、ほかにもいろいろなところで
変えてはいるけど、今回関係あるのはここだけっぽい
ではこのAddTurnがどこで呼ばれてるかっていうと
GameLogicの二か所で呼ばれているね

GameLogic
Line2577
   private IEnumerator RetryLogic()
Line3710
   public void StartPuzzle()

うん、なんかターンが切り替わる直前にStartPuzzleが呼ばれるみたいですな
ここを研究するか、こっからさらに細かくさかのぼっていくと何とかなりそうだ
んでそのうちStartPuzzleは２つ呼ばれてて

GameLogic
  public IEnumerator ReadyBattle( int step )
と
Line1608
  private void EndEnemyTurn()

基本このEndEnemuTurnがターン切り替わる直前に呼ばれてるような
でもステージ進むときは例外的にReadeYBattle呼ばれるような

アプローチ変えたほうがいいかもなこれ
どこまで細かく巻き戻っても全然わからん
どっかでパズルをいじる関数があるはずなんだけどなあ
なんの関数通ってなかったら並びがかわるはずないもんああ
もう無理これ
穏やかにならない方式の方がたぶん寝ないなこれ

まずStartPuzzle関数ないは目立ったパズルピース操作はなし

とすると、StartPuzzleに飛ぶ前のどこかの段階で
ピース井尻があるはず

ピース井尻って誰だ

スキルテストってどうにかしてどできないかな
スキルのデバックあるんだけどこれ全然機能してないよな


MasterDataからスキルをいじるやら何やら言っていたな
ちょっと見てみるか
うわあリーダースキルが781種
通常スキルが10597種か
まじかよ
全部見るの無理だろ
いやもう面倒くせえな、マルチの方もっと見よう、バグとかの解析が目的じゃなしいにさ


LoadingManagerの  public void PlayFromP2P() // multi
これなんだ
ておいぁあの、あなたのターンですみたいなアニメーションはどこでやってるの？



なんかもうわけわかんねにょな
MultiPlayManagerのUpdateでなんやらかんやらやっているけどお
ああMultiPlayManager以外にも
MultiPlayInGameManagerがあるのか
文字じゃなくて画像データだったわ
「あなたの順番です」とか

なんかもっと良い方法ないかなあ

だらだら駄文書いてみるか
まず現状わかってるのは、
・マルチじゃないと発生しないってこと。
・プレイヤーのターンになった瞬間にピース全てが大きく上に移動するということ
・実際にはピースが移動する前に、いくつかのピースが透明状態になるということ
・大きく移動した状態でも、パズルをドラッグするとそのドラッグ上の軌跡のパズルは
正常な位置で表示されるということ

ちょっとpuzzlefollの関数見てみるか


  public int FallLogic( bool isNoMatch = false )
  {
    int[] fallCount = new int [ PuzzleConfig.puzzleWidth];
    int totalCount = 0;

    for( int y = 0; y < PuzzleConfig.puzzleHeight; y++ )
    {
      int row = y * PuzzleConfig.puzzleWidth;
      for( int x = 0; x < PuzzleConfig.puzzleWidth; x++ )
      {
        int index = row + x;
        Piece piece = pieces[ piecesMap[ index ] ];
        if( piece.IsWaitReplace() ) 
        {
          totalCount++;
          fallCount[x]++;
          piece.ResetPosition( x, PuzzleConfig.puzzleHeight + fallCount[x] );
          PieceColor newColor = PieceColor.Random;
          if( fallColorIndex <= fallColorTarget ) newColor = fallColors[ fallColorIndex++ ];
          piece.ResetDarkPiece();
          piece.SetPieceSpriteColor( Piece.PieceColorState.Normal );
          piece.Reset( newColor );
        }
        else if( fallCount[x] > 0 )
        {
          piece.FallMove( new Vector3( PuzzleConfig.pieceSize.x * x, -(PuzzleConfig.pieceSize.y * (PuzzleConfig.puzzleHeight-1-(y-fallCount[x]) ) ), -1 ) );
          piece.Reset( piece.PieceColor );
        }
      }
    }
    
    if( isNoMatch )
    {
      // diffrence pices
      for( int i = 0; i < PuzzleConfig.puzzleTotal; i++ )
      {
        Piece curPiece = pieces[ piecesMap[i] ];
        InitMatchReRandom( curPiece, i );
      }
    }
    
    List<int> tmpNewFallMapId = new List<int>();
    for( int x = 0; x < PuzzleConfig.puzzleWidth; x++ )
    {
      int tmpFallCount = fallCount[x];
      if( tmpFallCount == 0 ) continue;
      int stackCount = 0;
      tmpNewFallMapId.Clear();
      int[] tmpFallMapId = new int[ PuzzleConfig.puzzleHeight ];
      for( int y = 0; y < PuzzleConfig.puzzleHeight; y++ )
      {
        int index = y * PuzzleConfig.puzzleWidth + x;
        Piece piece = pieces[ piecesMap[ index ] ];
        if( piece.IsWaitReplace() )
        {
          piece.FallMove( new Vector3( PuzzleConfig.pieceSize.x * x, -(PuzzleConfig.pieceSize.y * ( --tmpFallCount ) ), -1 ) );
          tmpNewFallMapId.Add( piecesMap[index] );
          stackCount++;
        }
        else
        {
          tmpFallMapId[y-stackCount] = piecesMap[index];
        }
      }
      
      tmpFallCount = fallCount[x];
      
      for( int ty = 0; ty < tmpNewFallMapId.Count; ty++ )
      {
        tmpFallMapId[ PuzzleConfig.puzzleHeight - stackCount + ty ] = tmpNewFallMapId[ ty ];
      }
      
      for( int ty = 0; ty < PuzzleConfig.puzzleHeight; ty++ )
      {
        piecesMap[ ty * PuzzleConfig.puzzleWidth + x ] = tmpFallMapId[ty];
      }
    }
    return totalCount;
  }



【Piece.cs】
  public void ResetPosition( int x, int y )
  {
    IsMoved = false;
    myTransform.localPosition = new Vector3( PuzzleConfig.pieceSize.x * x, -( PuzzleConfig.puzzleHeight - 1 - y ) * PuzzleConfig.pieceSize.y, -1 );
  }


うーんどうにもPuzzleLogicのMainLogicではない気がしてきたな
自分のターンに移る少し前の段階かなあ




PhotonManager.ReceivePieceData　:181
System.Reflection.MonoMethod.Invoke　:222
System.Reflection.MethodBase.Invoke　:115
NetworkingPeer.ExecuteRpc　2406
NetworkingPeer.OnEvent　:2059
ExitGames.Client.Photon.PeerBase.DeserializeMessageAndCallback (Parameters=) in 
ExitGames.Client.Photon.EnetPeer.DispatchIncomingCommands (Parameters=) in 
ExitGames.Client.Photon.PhotonPeer.DispatchIncomingCommands (Parameters=) in 
PhotonHandler.Update　:125



System.Reflection.MonoMethod.Invoke　:222
System.Reflection.MethodBase.Invoke　:115
この2つが完全にもうヤバイことやってて全然わからない


まずこっから見ていくか、
MonoBehaviorで宣言？珍しいね、Unityのスクリプトの基本システムだよね


PhotonView photonNetview = this.GetPhotonView(netViewID);
MonoBehaviour monob = photonNetview.RpcMonoBehaviours[componentsIndex];



はいはいphotonNetviewのRpcMonoBehaviours自体が
    internal MonoBehaviour[] RpcMonoBehaviours;
で宣言されてるのね、特に不思議なことはやっていない可能性


次これだよな、まずMethodInfoってなんなんだ
ＡｓｓｅｍｂｌｙだからUnityの標準機能か


MethodInfo.Invoke メソッド
オーバーロードの一覧
名前	説明
System_CAPS_pubmethod	Invoke(Object, BindingFlags, Binder, Object[], CultureInfo)	
派生クラスでオーバーライドされた場合は、リフレクションされたメソッドまたは指定したパラメーターを持つコンス トラクターを呼び出します。(MethodBase から継承されました。)
System_CAPS_pubmethod	Invoke(Object, Object[])	
メソッドまたは指定されたパラメーターを使用して、現在のインスタンスで表されるコンス トラクターを呼び出します。(MethodBase から継承されました。)






　前掲のTIPSと同様に、文字列によりメソッドを呼び出す場合にも、まずは呼び出そうとしているメソッドを含んでいるクラスのTypeオブジェクトを取得する。もしそのクラスのインスタンスがすでに作成済みなら、GetTypeメソッドにより、そのTypeオブジェクトを取得できる（以降のコード例はC#の場合。VB.NETの場合は後掲のサンプル・プログラムを参照してほしい）。

SomeClass sc = new SomeClass();
Type t = sc.GetType();

　次に、呼び出そうとするメソッドの名前をパラメータに指定して、取得したTypeオブジェクトのGetMethodメソッドを呼び出す。このメソッドは、MethodInfoクラス（System.Reflection名前空間）のオブジェクトを返す。MethodInfoクラスは特定のメソッドについての情報を表すクラスである。

MethodInfo mi = t.GetMethod("呼び出したいメソッド名");

　最後に、MethodInfoオブジェクトのInvokeメソッドを呼び出せば、メソッドを実行することができる。Invokeメソッドは戻り値をobject型として返すので、メソッドに戻り値がある場合には、通常キャストが必要となる。

object o = mi.Invoke(sc, new object[] { パラメータ…… } );

　Invokeメソッドの第1パラメータには、呼び出したいメソッドを含むインスタンスを指定する。そのメソッドが静的メソッドならばnull（VB.NETの場合はNothing）を指定する。また、第2パラメータには呼び出したいメソッドに渡すパラメータをobject型の配列で指定する。メソッドがパラメータを取らなければnull（Nothing）を指定する。

文字列で指定したメソッドを呼び出すサンプル・プログラム

　以下に、Invokeメソッドを使用したサンプル・プログラムを示す。ここでは、文字列（Stringクラスのインスタンス）に対して、Remove、Substring、IndexOfの3つのメソッドを、メソッド名により実行している。

// methodinvoke.cs

using System;
using System.Reflection;








文字列で指定したメソッドを呼び出すには？

List<MethodInfo> entries = SupportClassPun.GetMethods(type, typeof(PunRPC));
 bool methodsOfTypeInCache = this.monoRPCMethodsCache.TryGetValue(type, out cachedRPCMethods);
this.monoRPCMethodsCache[type] = entries;
cachedRPCMethods = entries;

ああもう完全にUnityの標準機能だな
これ調べるところじゃないわ


MethodInfo mInfo = cachedRPCMethods[index];

object[] inMethodParameters = null;
if (rpcData.ContainsKey((byte)4))
{
    inMethodParameters = (object[])rpcData[(byte)4];
}

if (inMethodParameters == null)
{
    inMethodParameters = new object[0];
}

Type[] argTypes = new Type[0];
if (inMethodParameters.Length > 0)
{
    argTypes = new Type[inMethodParameters.Length];
    int i = 0;
    for (int index = 0; index < inMethodParameters.Length; index++)
    {
        object objX = inMethodParameters[index];
        if (objX == null)
        {
            argTypes[i] = null;
        }
        else
        {
     8

       argTypes[i] = objX.GetType();
        }

        i++;
    }
}

object result = mInfo.Invoke((object)monob, inMethodParameters);
monob.StartCoroutine((IEnumerator)result);




HorseItemList.csの警告を2つ修正
CheckCondition.csの修正

6139 > 6348



あれ6374では異常ないな



しおりサンプル
まずは先ほど取得したTypeよりMethodを取得します。今回はSceneViewのShowを取得します。

var shoeMethod = sceneViewType.GetMethod("Show");

しかし実際にはShowはオーバーロードしているメソッドなので、欲しい引数のメソッドが一発で引けるとは限りません。オーバーロードしてるメソッドは次のように記述します。



    MethodInfo mi1 = stringType.GetMethod("Remove");
うううううううううんんんんんん
つまりstringクラスのRemoveを取得？？
stringにRemoveって関数あったかな、あったな
なんでこんな面倒くさいことしてるんだろうか

  

オーバーロードしてるメソッドは次のように記述します。

var shoeMethod = sceneViewType.GetMethod("Show");

MethodInfo shoeMethod = null;
MethodInfo[] sceneViewMethods = sceneViewType.GetMethods ();

ふむふむ、sceneViewクラスの

foreach (var method in sceneViewMethods) 
{
  if( method.Name == "Show" && method.GetParameters().Length == 0 )
  {
    shoeMethod = method;
    break;
  }
}

これで呼び出すメソッドの定義は取得できました。後はメソッドにメソッドを呼び出すインスタンスを添えて呼び出します。下のコードではシーンビューのインスタンスを既に取得しているとして…こんな感じで呼び出します。最後のnullは引数が無いのでnullです。引数がある場合は配列で渡します。

 shoeMethod.Invoke (window, null);









しおり
しおり
public class MethodInvoke {
  static void Main() {

うーんとつまりは
//んんｎ文字列をmsgに代入　メリークリスマスね
    string msg = "メリー・クリスマス";
//
    Type stringType = msg.GetType();
    // Type stringType = typeof(string); // これでもOK
//これでもＯＫってどういうことだ、メリークリスマスじゃなくても
ストリング型ならＯＫってことか

    // 以下はmsg.Remove(0, 4)と同じ
    //


つまりあれか
string str = "いがらし";
str.Removeと同じかなるほどなあ

つまりこれはsｔｒingType.Removeをを？？
MethicInfo mi1 = staringTYpe.GetMethiod("Remove")
とすることによてmi1に代入してえ
あ違う、確かに
string removed
= (string)mi1.Invoke(msg, new object[] { 0, 4 });


なんだstringType.GetMethoｄって、Removeって名前の関数を
呼ぶってことか、でもそれだと、その前のType とか　GetTypeとかまったく意味ない気がするんだけど
ああいや、stringTypeはすぐ使ってるやんけ なんやわからんけど、
こんなまだるこっしい
    MethodInfo mi1 = stringType.GetMethod("Remove");
 
ううんこれは何やってるんだ？予想としては、Remove(msg,new object[] { 0, 3});
みたいなことやってると思うんだけど
あ違くねこれ、Remove(new object[]{0, 4})やってるんじゃね
戦闘から4文字removeさせる？

これに２バイト文字じゃねえのかな
objectとしてとらえると４文字ってことでいいのか？
   string removed
        = (string)mi1.Invoke(msg, new object[] { 0, 4 });

つまるところ、Remove.Invoke("メリー・クリスマス", new object[]{0, 4})でそ



    Console.WriteLine(removed); // 出力：クリスマス
ええええええ、、、、
出力クリスマスてどういうこと。

    // 以下はmsg.Substring(4)と同じ
    //
    // オーバーロードされたメソッドがあるため
    // パラメータの型によりメソッドを特定
    MethodInfo mi2 = stringType.GetMethod(
                    "Substring", new Type[] { typeof(int) });
    string substring
        = (string)mi2.Invoke(msg, new object[] { 4 });

    Console.WriteLine(substring); // 出力：クリスマス

    // 以下はmsg.IndexOf("クリ")と同じ
    //
    // オーバーロードされたメソッドがあるため
    // パラメータの型によりメソッドを特定
    MethodInfo mi3 = stringType.GetMethod(
                    "IndexOf", new Type[] { typeof(string) });
    int index = (int)mi3.Invoke(msg, new object[] { "クリ" });

    Console.WriteLine(index); // 出力：4
  }
}







using System;
using System.Reflection;

public class MethodInvoke {
  static void Main() {
    string msg = "メリー・クリスマス";

つまりこの段階では何も"メリークリスマス"を入れる必要はないわけだ
とにかくTypeにstringクラスの型を認識させればいい
    Type stringType = msg.GetType();
    // Type stringType = typeof(string); // これでもOK

    // 以下はmsg.Remove(0, 4)と同じ
    //

んで、strringTypeはtype(string)状態になっているから
その中のMethod"Remove"をゲットメゾッドで取得してmi1に入れる

で、String.Removeは第一引数に文字列を、第二引数に削除開始の場所を
んでえ第３引数にっ削除終わりのインッデックスを指定するわけであるからにして
string removed = string.Remove("メリークリスマス", 0, 4);と
string removed = (string)mi1.Invoke(msg, new object[] { 0, 4 );
はこの段階で同一だといえる
    MethodInfo mi1 = stringType.GetMethod("Remove");
    string removed
        = (string)mi1.Invoke(msg, new object[] { 0, 4 });

    Console.WriteLine(removed); // 出力：クリスマス

    // 以下はmsg.Substring(4)と同じ
    //
    // オーバーロードされたメソッドがあるため
    // パラメータの型によりメソッドを特定
    MethodInfo mi2 = stringType.GetMethod(
                    "Substring", new Type[] { typeof(int) });
    string substring
        = (string)mi2.Invoke(msg, new object[] { 4 });

    Console.WriteLine(substring); // 出力：クリスマス

    // 以下はmsg.IndexOf("クリ")と同じ
    //
    // オーバーロードされたメソッドがあるため
    // パラメータの型によりメソッドを特定
    MethodInfo mi3 = stringType.GetMethod(
                    "IndexOf", new Type[] { typeof(string) });
    int index = (int)mi3.Invoke(msg, new object[] { "クリ" });

    Console.WriteLine(index); // 出力：4
  }
}














しおり
なるほど、MonoBehaiviorクラスの何らかの関数を実行するわけだな
Type type = monob.GetType();

ここが何やってるか全然わからん

なんで引数が２つあるんだ？？
推定としては、このtypeはMonoBeheivior型だから


List<MethodInfo> entries = SupportClassPun.GetMethods(type, typeof(PunRPC));
ああああん？？　文字列じゃねえのかよ、GetMerhodsって

Type.GetMethods メソッド (BindingFlags)

.NET Framework (current version) その他のバージョン 
 
派生クラスによってオーバーライドされた場合、指定したバインディング制約を使用して、現在の Type に対して定義されているメソッドを検索します。

ほう、検索の絞り込みか
しかし指定したバインディング検索とはいったい
結局全然わからねえな
SupportClassPunはPhotonやろ、もうわかんないところはわかんないですすめていくしかねえよ正直

まあとにかくSupportClassPunっていうクラスの軟化の関数を取得してるんだよ
なんか一番上見ると
using SupportClassPun = ExitGames.Client.Photon.SupportClass;
てあるな


List<MethodInfo> entries = SupportClassPun.GetMethods(type, typeof(PunRPC));
cachedRPCMethods = entries;
MethodInfo mInfo = cachedRPCMethods[index];

inMethodName = PhotonNetwork.PhotonServerSettings.RpcList[rpcIndex];
inMethodName = (string)rpcData[(byte)3];

if (mInfo.Name.Equals(inMethodName))
object result = mInfo.Invoke((object)monob, inMethodParameters);
この第一引数のmnobってなんだっけな
MonoBehaviour monob = photonNetview.RpcMonoBehaviours[componentsIndex];

結局あれなんだっけ。あれ、
あれか第一引数がなんかあの、あれのinstanceじゃなくちゃいけないのか
型指定された奴のインスタンス
今回はあType type = monob.GetType();で型指定されて

あれ、これMechodInfoと<MethodInfo>.Invokeの型って統一されてなきゃいけないんだっけ
そうだよなたしか
List<MethodInfo> entries = SupportClassPun.GetMethods(type, typeof(PunRPC));
cachedRPCMethods = entries;
MethodInfo mInfo = cachedRPCMethods[index];

で、mInfoには、SupportClassPunクラスのタイプが代入されていると思い焼きや
どうやらSupportClassOPanの中のGetMethodの何かで
MonoBeheiviorクラスを関数何らかの関数が実行されいるようでるぞ。

そうじゃないとこの後ろの
object result = mInfo.Invoke((object)monob, inMethodParameters);
が説明つかんもんな、
問題は一体何の関数が実行されてんのか全然わかんねえことだよ
 
 
いがあああああReceiveSyncData
UnityEngine.Debug:Log(Object)
NetworkingPeer:ExecuteRpc(Hashtable, PhotonPlayer) (at Assets/Photon Unity Networking/Plugins/PhotonNetwork/NetworkingPeer.cs:2406)
 
あんんんんんんんんん？？？？？
ReceiveSyndData???
そんな関数、SupportClassPunにあったっけ？
何かがおかしい
 
SupportClassPun.GetMethods(type, typeof(PunRPC));
 
これが何がどうやって
 
Assemblyないは
 		public static List<MethodInfo> GetMethods (Type type, Type attribute)
 		{
 			List<MethodInfo> list = new List<MethodInfo> ();
 			bool flag = type == null;
 			List<MethodInfo> result;
 			if (flag)
 			{
 				result = list;
 			}
 			else
 			{
 				MethodInfo[] methods = type.GetMethods (BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
 				MethodInfo[] array = methods;
 				for (int i = 0; i < array.Length; i++)
 				{
 					MethodInfo methodInfo = array [i];
 					bool flag2 = attribute == null || methodInfo.IsDefined (attribute, false);
 					if (flag2)
 					{
 						list.Add (methodInfo);
 					}
 				}
 				result = list;
 			}
 			return result;
 		}
 
んで渡される引数は
MonoBehaviour monob = photonNetview.RpcMonoBehaviours[componentsIndex];
 Type type = monob.GetType();
 
 
んんん        PhotonView photonNetview = this.GetPhotonView(netViewID);
で、PhotonViewは
public class PhotonView : Photon.MonoBehaviour
というようにMOnoBehaviourを継承してるわけだ
よって
MonoBehaviour monob = photonNetview.RpcMonoBehaviours[componentsIndex];
は何の違和感もないコードである。
RpcMonoBehavioursはPhotonViewのメンバ変数であるぞよ
して、
    public void RefreshRpcMonoBehaviourCache()
    {
        this.RpcMonoBehaviours = this.GetComponents<MonoBehaviour>();
    }
 
でなんかよくわからんものつっこんでるね
で、普通にカンがればここでしか代入しているコードがないわけですよRefreshRpcMonoBehaviourCahce
 
でもたぶんん
MethocInfoを今こうして使うのならば
photonNetview.RpcMonoBehaviours[componentsIndex];をとおしいの

mInfo.Invoke((object)monob, inMethodParameters);



ううううんｎ Type type = monob.GetType();
で取得すれるかとはMonoBehaiourで継承されたPhotnViewで

List<MethodInfo> entries = SupportClassPun.GetMethods(type, typeof(PunRPC));
で
つまりはSupportClassPun.GetMethods(typeof(PhotonView), typeof(PunRPC)）いうわけかなんじゃそりゃ

なんじゃPunRPCって

#pragma warning disable 1587
/// \file
/// <summary>Reimplements a RPC Attribute, as it's no longer in all versions of the UnityEngine assembly.</summary>
#pragma warning restore 1587

using System;

/// <summary>Replacement for RPC attribute with different name. Used to flag methods as remote-callable.</summary>
public class PunRPC : Attribute
{
}


まそれは置いといて
つまりはSupportClassPun.GetMethods(typeof(PhotonView), typeof(PunRPC)）いうわけかなんじゃそりゃ
 
  		public static List<MethodInfo> GetMethods (Type type, Type attribute)
 		{
 			List<MethodInfo> list = new List<MethodInfo> ();
 			bool flag = type == null;
 			List<MethodInfo> result;
 			if (flag)
 			{
 				result = list;
 			}
 			else
 			{
 				MethodInfo[] methods = type.GetMethods (BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
 				MethodInfo[] array = methods;
 				for (int i = 0; i < array.Length; i++)
 				{
 					MethodInfo methodInfo = array [i];
 					bool flag2 = attribute == null || methodInfo.IsDefined (attribute, false);
 					if (flag2)
 					{
 						list.Add (methodInfo);
 					}
 				}
 				result = list;
 			}
 			return result;
 		}
 
ううううう
MethodInfo[] methods = type.GetMethods (BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
つまりはPhoronView.GetMethodsで条件がInstanceかPublicかNonPublic?もう全部じゃねえか

でえええ
	MethodInfo[] array = methods;
	MethodInfo methodInfo = array [i];
		bool flag2 = attribute == null || methodInfo.IsDefined (attribute, false);
		if (flag2)
		{
			list.Add (methodInfo);
		}
attributeはtypeof(PunRPC)だから
んんんｎ
まあとにかく最終的な結果はNetworkingPeer:ExecuteRpcになるわけで
そしてmethodInfo.IsDefined (typeof(PunRPC), false);
でこれにひっかかったmethodをreturnすると？？


うん？GameLogic、Update()no

    case GamePhase.WaitStartFall :
      startTimer += Time.deltaTime;
      if( startTimer > 0.25f )
      {
        puzzleLogic.StartFall();
        StartGame();
      }
      break;
かあああ

ここからの、StartFall()の

んんｎPuzzleLogicだけで初期化が４つぐらいあるんだけど

StartFall
FallLogic

んんんStartFallが呼ばれないと似たような形にはなるな
GameLogic内でStartFallが呼ばれている場所は
3か所
RetryLogicと
Updataと
OnGUIか
RestyLogicの方は確実にStartFakkがよばれるわけだなあ
UpdateはgamePhaseがcase GamePhase.WaitStartFall :
だとStartFallが呼ばれる
OnGUIはの方はなんだかよくわからない、"Reset"がどうとか言ってるけど 
あれかデバックボタンか？

とにかく的はUpdateからのpuzzleLogic.StartFallに絞られたような気がする
つまりWaitStartFallが代入されずにターンが移る可能性
とすると、WaitStartFallは一体どこで代入される可能性があるのかということ

ｊこれ実はUpdateの    case GamePhase.WaitStart : からのみ発行されてる
とするとWaitStartはどこから代入されてるのか
とりあえず羅列すると
GameStart()
EntryPointConsumption()
EntryPointConsumption()
EntryPointMultiConsumption()



gamePhaseWaitStart
gamePhaseWaitStartFall

gamePhaseBattleReady
gamePhasePuzzle
 gamePhasePuzzleMatch

gamePhasePlayerAttack
gamePhasePlayerAttackEnd

gamePhaseEncountReady


なんやこれWaitStart最初の方にしか行われてないやんけ


gamePhaseWaitStart
>
gamePhaseWaitStartFall
>
gamePhaseStart                StartGame()    Line3470
>
gamePhaseEncountReady   StartNextStep()      StartBroadCast()     ReloadGameScene
>
gamePhasePuzzle              MainLogic()     FastAttack     RetryLogic()     HideSkillWindow()     ShowInvalidateSkill()
                                       OnSkillAttackEnd()       UseSkill()       StartPuzzle()      UnPauseGame()        UseSkill()
>
gamePhasePuzzleMatch     MainLogic()       MultiTimer()      MainLogic_MatchCheck()
>
gamePhasePlayerAttack     PlayerAttack
>
gamePhaseEncountReady   StartNextStep()      StartBroadCast()      ReloadGameScene
>
gamePhaseBattleReady      StartBattle()
>
gamePhasePuzzle              MainLogic()     FastAttack     RetryLogic()     HideSkillWindow()     ShowInvalidateSkill()
                                       OnSkillAttackEnd()       UseSkill()       StartPuzzle()      UnPauseGame()        UseSkill()        
>
gamePhasePuzzleMatch     MainLogic()       MultiTimer()      MainLogic_MatchCheck()
>
gamePhasePlayerAttack     PlayerAttack
>
gamePhasePlayerAttackEnd  PlayerAttack
>
gamePhasePuzzle              MainLogic()     FastAttack()     RetryLogic()     HideSkillWindow()     ShowInvalidateSkill()
                                       OnSkillAttackEnd()       UseSkill()       StartPuzzle()      UnPauseGame()        UseSkill()        
>
gamePhasePuzzleMatch
>
gamePhasePlayerAttack
>
gamePhasePlayerAttackEnd
>
gamePhaseEncountReady
>



パズルが上から一斉に降ってくる関数は
PuzzleLogicのStartFallかFallLogicだけ
StartFallは開始直後、FallLogicはSpecialBlockの時だけ呼ばれる

バグ報告は7/02

7/21  3.1.0
6/27  3.0.2
6/22  3.0.1



ヒエラルキの位置はGaneLogic/Piecesやで
なるほどなあ、ピースのカラーが黒からホワイトになることで
まともに表示されるようになるのかな
ドラッグで移動させた瞬間に表示されるんやなあ
具体的にどの変数でこの改革が加えられるのか


SetPieceSpriteColor( PieceColorState.Normal, 1.0f );
これやな、これでﾋﾟｰｽの色とか透明度が決まる
public enum PieceColorState
{
Normal      = 0x00000000,   // 通常.
Darkness    = 0x00010000,   // 暗闇.
Transparent = 0x00020000,
Mask        = 0x00FF0000,
}


GameLogic.StartBroadCast 　　3459
RaceLogic.EncountReadyStart　563
RaceLogic.RaceStart () 412


StartBroadCast()は毎回呼ばれる
StartNextStepは内部ステージ階層が1上がるごとに呼ばれる


とりあえず上から一斉にﾋﾟｰｽが落ちてくる関数は
PuzzleLogicのStartFallかPuzzleＦａｌｌのどちらかを通る必要がある

それでPuzzleFallの方も一応詳しく調べたんでけども
やっぱりSpecitalBlockが絡んだ流れからじゃないとPuzzleFallには繊維しない
バグ報告してくたユーザーの写真見ると、どう見てもSepecialBlockは絡んでないような気がした

StartFallの方は、GameLogicのgamePhaseにwaitStartが代入された後の
Updateからしか通常は繊維しないので
いろいろそこまでの繊維を調べてみたけどない
また最初の一回しかwaitStartは代入されないはずだけど
意図的に途中でwaitStartを入れてみたりしてみたけど指定の動作にはならなかった。

RetryLogicからStartFallが呼ばれる

gamePhaseにwaitStartが代入されないと上から一斉に
ピースの位置はStartFallの関数の中で到達目標座標のような形で実装されているので
そこのy軸を大きくずらしてみたところ

ユーザーの報告と似たような形にはなったけども、やはりそこの値が変わることはどうもないさそう。ｌ


plateNo = cmdRaceResult.GetData().plate_no;




ver2.6のコード

  /// <summary>
  /// Results the end.
  /// </summary>
  private void ResultEnd()
  {
#if MULTI_PLAY
    if(MultiLobbyStatus.userList != null) {
      MultiLobbyStatus.Finish();
    }
    MultiLobbyStatus.multiType = MultiType.Single;
#endif
    MainMenuLogic.Instance.TouchHome();
  }
