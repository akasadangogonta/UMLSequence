ぇえええええええええええフォトンンンンンンンンンンンンンンン？？？


MultiRaceMenuから追ってみ見るか、もしくはRaceMenu

基本的photonは同期処理につかうんだよなあ


RPC
remote procedure call
ネットワーク上の別の端末の関数等を呼び出す仕組み。
Unityドキュメントより
「RPC は高い信頼性で送信され、順序付けられます」
http://docs.unity3d.com/ja/current/Manual/class-NetworkView.html
呼び出し方
GameObjectの構成

GameObjectｆｆｆｆｆｆｆｆｆｆｆｆｆｆｆｆｆｆｆｆｆｆｆｆｆｆｆｆ
    PhotonView … RPC呼び出しの橋渡し
    Photon.MonoBehaviour継承のクラス … RPCメソッドを実装する
RPCメソッドの実装

public class TestRPC : Photon.MonoBehaviour
{
    [PunRPC]
    public void RPCFunc(string msg, byte[] data, PhotonMessageInfo info)
    {
        Debug.Log("Message : " + msg);
        string dataStr = "";
        foreach(byte b in data) dataStr += b + " ";
        Debug.Log("Data : " + dataStr);
    }
}
※PUN ver1.56からは [RPC] が使えなくなっています。代わりに[PunRPC]を使います。
http://forum.unity3d.com/threads/photon-unity-networking.101734/page-17
v1.56 (16. June 2015)
Changed: The RPC attribute got replaced by PunRPC. 
Search and replace your code for [RPC] and replace it with PunRPC. 
The change is necessary, because the RPC attribute is obsolete in Unity 5.1 and that causes a large amount of warnings at compile time. 
The new PunRPC must be used in all versions of Unity, starting with this PUN version.
RPCメソッドの呼び出し

マスタークライアントは即座にメソッドが呼び出されるが、
ネットワーク越しのプレイヤーには当然呼び出されるまでにラグが発生する。
// RPCを呼び出す
{
    PhotonView view;    // TestRPC ＋ PhotonViewを持つGameObjectから取得する

    // RPCメソッドの引数 object[] の配列にする
    object[] args = new object[]{
            "RPC message",          // 第1引数 : string msg
            new byte[] {1, 2, 3}    // 第2引数 : byte[] data
            };

    // RPCメソッドの名前、引数を合わせる
    view.RPC(
        "RPCFunc",                  // メソッド名
        Photontargets.All,          // ネットワークプレイヤー全員に対して呼び出す
        args);                      // 引数
}
RPCの引数に使える型
byte, int, float 等の値型
byte[], int[], float[] 上記値型の配列
string, string[]
Vecter3, Quaternion
また、以下のドキュメントにPhotonでシリアライズ可能な型の一覧があります。
確認してないですが、おそらく可能だと思われます。
http://doc.exitgames.com/ja/realtime/current/reference/serialization-in-photon

とにかくviewが他社になることがあるしあん


NetworkingPeer.ExecuteRpc 　:2283
NetworkingPeer.OnEvents　:2059
ExitGames.Client.Photon.PeerBase.DeserializeMessageAndCallback (inBuff={byte[33]}) in 
ExitGames.Client.Photon.EnetPeer.DispatchIncomingCommands () in 
ExitGames.Client.Photon.PhotonPeer.DispatchIncomingCommands () in 
PhotonHandler.Update　:125


　　PhotonNetwork.RPC　:2911
　　PhotonView.RPC　:569
　　PhotonManager.SendSyncData 　:157
　　PhotonManager.SuccessCheck 　:116
　　UnityEngine.MonoBehaviour.StartCoroutine 　:62
　　PuzzleLogic.SetMultiSamePieces　:786
　　UnityEngine.MonoBehaviour.StartCoroutine 　:62
　　GameLogic.Start　362


PhotonNetwork.RPC　:2911
PhotonView.RPC 　157
PhotonManager.SuccessCheck　116
UnityEngine.MonoBehaviour.StartCoroutine 　62
PuzzleLogic.SetMultiSamePieces 　786
UnityEngine.MonoBehaviour　:62
GameLogic.SetMultiSamePieces 　915
UnityEngine.MonoBehaviour.StartCoroutine (routine={GameLogic}) 　:62
GameLogic.MainLogic　804
GameLogic.Update　715


PhotonManager.ReceivePieceData　181
System.Reflection.MonoMethod.Invoke　:222
System.Reflection.MethodBase.Invoke　:115
NetworkingPeer.ExecuteRpc 　2406
NetworkingPeer.OnEven　:2059
ExitGames.Client.Photon.PeerBase.DeserializeMessageAndCallback (inBuff={byte[210]}) in 
ExitGames.Client.Photon.EnetPeer.DispatchIncomingCommands () in 
ExitGames.Client.Photon.PhotonPeer.DispatchIncomingCommands () in 
PhotonHandler.Update 　125
とりあえずニパターン記録したぞ、こっから見てくか


ちょっと大事っぽいSetSamePiecesからやってみるか


    MultiplayPluginObject_Base.debug_scene = P2PState.Board;
	P2PState.Boardとはいったい。。。。
	見たところだたのenumっぽいけども

    while(true)
    {
      if(MultiLobbyStatus.userList == null)
	nullのときかあ。。。。
	うーん、なにこれ、そもそももうレースは始まってんだよなあ
      {
        MultiplayPluginObject_Base.debug_scene = P2PState.None;
        MultiPlayManager.ReceiveWait = false;
        PhotonManager.ReceiveWait = false;
        LoadingManager.Instance.PauseFromP2P();
        yield break;
      }

      // ダイアログが出ていないときはインジケーターを回す
	うーんダアログってなんだろうなあ
      if(!CommonWindow.Instance.IsActive && !CommonWindow.Instance.gameObject.animation.isPlaying && !LoadingManager.Instance.IsPlaying())
      {
        MultiPlayManager.ReceiveWait = true;
        LoadingManager.Instance.PlayFromP2P();
      }

	うーん、もしかしてこの関数そもそもGUest専門か？
	この条件式、自分のターンかHostのターンかとしか分岐してないぞ、
	自分がGuestであること前提か？
      bool sender = (sender_true_host_false_turn) ? MultiPlayManager.IsHost:MultiPlayManager.IsMultiSelfTurn;

      if(sender)
      {
        P2PDataPiece sendData = new P2PDataPiece();
	P2PDataPieceとは一体。。。
	P2PResponce.csの中に入ってるけども
	まるで沸け分からんな
	うーん、P2PDataPieceはP2PObjectを継承してて
	p2pObjectは
	/// <summary>
	/// 送信データの基底クラス.
	/// </summary>
	とある。
	このそうしんんデータってのは何処に送信するんだ？
	サーバか？まあサーバだよな

        sendData.pieces = new PieceColor[pieces.Length];
        for(int i=0;i<pieces.Length;i++)
        {
          sendData.pieces[i] = pieces[piecesMap[i]].PieceColor;
	なんとなーくだけど分かった着たな。
        }
        PhotonManager.SendPieceData( sendData );
	ほう、なんだかわからんが、少しわかってきたな
	  // ピース情報送信
	  public static void SendPieceData( P2PDataPiece data )
	  {
	    Debug.Log("SendPieceData");
	    scenePhotonView.RPC("ReceivePieceData", PhotonTargets.Others, data.pieces);
	  }
	これ中身な、そのSendPieceDataの
	これcallStaticから見ると呼ばれてないから、明らかに相手の端末におっくってるよな？そうじゃないのか？
	
	うーーーーんもしやこれ重要、PhotonTargets.Othersがあれか、ああいうことか？
	じゃあSendPieceDataやった側はReceivePieceData受け取ることはないのか？

	そうだね、もう決定だ、
      }
      else
      {

        if( PhotonManager.ReceiveWait )
        {
          yield return null;
          continue;
        }
      }
      break;
    }


    MultiPlayManager.ReceiveWait = false;
    LoadingManager.Instance.PauseFromP2P();

    yield break;



なんだ何すればいいんだっけ、そうだあれだ
とりあえずRPCの第二引数のOtherなんたらとか調べよう


/// <summary>Enum of "target" options for RPCs. These define which remote clients get your RPC call. </summary>
/// \ingroup publicApi
public enum PhotonTargets
{
    /// <summary>Sends the RPC to everyone else and executes it immediately on this client. Player who join later will not execute this RPC.</summary>
    All,
    /// <summary>Sends the RPC to everyone else. This client does not execute the RPC. Player who join later will not execute this RPC.</summary>
    Others,
    /// <summary>Sends the RPC to MasterClient only. Careful: The MasterClient might disconnect before it executes the RPC and that might cause dropped RPCs.</summary>
    MasterClient,
    /// <summary>Sends the RPC to everyone else and executes it immediately on this client. New players get the RPC when they join as it's buffered (until this client leaves).</summary>
    AllBuffered,
    /// <summary>Sends the RPC to everyone. This client does not execute the RPC. New players get the RPC when they join as it's buffered (until this client leaves).</summary>
    OthersBuffered,
    /// <summary>Sends the RPC to everyone (including this client) through the server.</summary>
    /// <remarks>
    /// This client executes the RPC like any other when it received it from the server.
    /// Benefit: The server's order of sending the RPCs is the same on all clients.
    /// </remarks>
    AllViaServer,
    /// <summary>Sends the RPC to everyone (including this client) through the server and buffers it for players joining later.</summary>
    /// <remarks>
    /// This client executes the RPC like any other when it received it from the server.
    /// Benefit: The server's order of sending the RPCs is the same on all clients.
    /// </remarks>
    AllBufferedViaServer
}



まずリトライ処理って入ってるんだっけなぁ
