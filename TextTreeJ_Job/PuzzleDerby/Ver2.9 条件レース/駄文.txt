RaceMenuからRaceConfirmに移って実際のエラーの確認するんだけど
エラーというかConfirmで決定を押せるかどうかの判定か
この際にさ、今回新たに実装する同一ホース禁止、限定ホース、限定カードはさ
現在レースに参加しようとしている馬のデータ一式上げなくちゃいけない
この実装方法をどうするか、でもよく考えても見ると、メス馬限定レースとかも
現在参加しようとしているチームの情報を判定しているんだよな
そっからパクればいいのか

RaceConfirmItemの中にIsLeaderFemaleというのがある
まあここでﾘｰﾀﾞｰにメスがいるかどうか確認しているわけですな
でもこれただのbool型なんですわ
つまり他の関数でboolを代入しているだけ
これの代入はCalcStatusという関数でやっている。RaceConfirmItemの
117行目、更にそこから、具体的には140行目のif(horseData.GetMasterData().sex == HorseSex.Female)で女かどうか判定してるわ。。。

更に後ろの195行目でも性別を判定している。これはリーダーかどうかの違いだな
iが0だと一番目のホースってことでリーダー判定している。
あ違うわ、自分のホースとヘルパーホースの違いだ、でもそうすると変だな
自分の選択ホースは最大で5個しかないはずなのに
なんか十回も二十回もループしてた気がするなんでだ
あああ、全てのチームチェックしてんのか
RaceConfirmのCreateDataで
    Dictionary<int,NwDataTeamDetail> datas = UserDataManager.Instance.GetTeamDatas();
    teamNum = datas.Count;
てやってるわ。。。。。。。

とするとさ、今参加しようとしているチームはどうやって判定してんだ
このISLeaderFemaleはチームごとに設定してるのか
んｎなんか51行目に怪しいコードがあるな
 UseTeamId = UserDataManager.Instance.GetUseTeam().id;
これで仕様するチームIdを取得してんのね

んんん、ホースとカードの判定方法ってどうやってんのかね
たぶんNwDataUserHorseの、horse_card_idとhorse_card_rarity_idで判定してるんだろうな
たぶん前者がカード指定（狭い範囲指定）、後者がホース指定（広い範囲指定）
まあどっちにしろうけとる情報intだわな

CalcStatusはあれですな、引数がわかりにくい
  private void CalcStatus( double[] horseIds, NwDataUserHorse helperHorse )
これはさ、大引数は、ひとつのグループの全てのホースIDやで
つまり最大数5ですこの配列。大して第二引数は、これヘルパーホースです。
つまりはさinstanceRaceConfirmItems = new RaceConfirmItem[teamNum];
RaceConfirmItemが一つのﾁｰﾑなわけよ

めんどくさ
conditionValueの位置は
まずJSONとしてはrace_listという名前のJSONから
NwDataRaceListのNwDataRaceDataの中のNwDataStageDataの中のconditionValueですわ
まあ内訳みると
normal_race_list
event_race_list
rankin_event_race_list
new_normal_race_list
new_event_race_list
new_special_race_list
jockey_event_version
があって
それぞれの中の、あいやジョッキーイベント以外の
配列の中の、更にstage_listという配列変数の中に
condition_valueがある。
まぎらわしいのわ、実際にRaceMenuで使うのはRaceData.csの中の
ConditionValueなんだよな、一体どこで代入してんだか
あ
全部で5箇所ぐらいで代入してんな
まずRaceMenuの中のTouchNormalSubRaceTitle
そしてTouchEventSubRaceTitle
そしてTouchRankingEventSubRaceTitle
他の2つは違うｃｓファイルで
まず一つはMultiLobbySelect.csの中のTouchCallback
もう一つはMultiLobbySekectItemの中のConditionLimitCheck
なんや最後の2つはめんどうくさい
とりあえず上３つのことだけ考えとけばいいんとちゃうか？

取りあえず喫緊の問題としては、JSONのrace_listから送られてきた情報が
どういう経緯をたどって最終的にRaceDataのcondition_valueに代入されるかということだな
なんか最初はRacrSubListItemから代入されるもんだと思ってけど
このスクリプトを通るルートが極端に少ないから、それ以外にもあると思われる

うーん、RaceListから受け取ってんのかな
このスクリプトの中に
get { return NetworkManager.Instance.GetCmd<NwCmdRaceList>().GetData().Nor
malRaceDatas; }
ってあるからな,とりあえずNwCmdRaceListにrace_listの情報が代入されるのは確実なんだよ

わかった一括して全てのデータをRaceDataに渡しているわけじゃない
必要なときに必要な分の情報だけ、NwCmdRaceDataのdataから受け取っている。（NwCmdRaceDataのdataには全ての情報が入っている）

C:\Project\PuzzleDerby\PuzDurbAndroid_Trunk_p3\Assets\GameScenes\Common\Plugins\General\TitleBoardManager.cs (543, 79):    NwDataRaceList raceList = NetworkManager.Instance.GetCmd<NwCmdRaceList>().GetData();

C:\Project\PuzzleDerby\PuzDurbAndroid_Trunk_p3\Assets\GameScenes\Common\Scripts\Network\Race\NwCmdRaceList.cs (50, 25):  public NwDataRaceList GetData() { return data; }

C:\Project\PuzzleDerby\PuzDurbAndroid_Trunk_p3\Assets\GameScenes\RaceMenu\Scripts\MultiLobbySelectItem.cs (131, 79):    NwDataRaceList racelist = NetworkManager.Instance.GetCmd<NwCmdRaceList>().GetData();

C:\Project\PuzzleDerby\PuzDurbAndroid_Trunk_p3\Assets\GameScenes\RaceMenu\Scripts\RaceEventList.cs (81, 46):    List<NwDataRaceData> datas = cmdRaceList.GetData().EventRaceDatas;

C:\Project\PuzzleDerby\PuzDurbAndroid_Trunk_p3\Assets\GameScenes\RaceMenu\Scripts\RaceList.cs (12, 66):    get { return NetworkManager.Instance.GetCmd<NwCmdRaceList>().GetData().NormalRaceDatas; }

C:\Project\PuzzleDerby\PuzDurbAndroid_Trunk_p3\Assets\GameScenes\MainMenu\Scripts\MainMenuLogic.cs (236, 51):        jockeyEventVersionLoader.Load( cmdRaceList.GetData().jockey_event_version, gameObject,

C:\Project\PuzzleDerby\PuzDurbAndroid_Trunk_p3\Assets\GameScenes\MainMenu\Scripts\MainMenuLogic.cs (286, 49):      jockeyEventVersionLoader.Load( cmdRaceList.GetData().jockey_event_version, gameObject, this.InRaceList );

C:\Project\PuzzleDerby\PuzDurbAndroid_Trunk_p3\Assets\GameScenes\MainMenu\Scripts\RaceMenu.cs (225, 23):      if(( cmdRaceList.GetData().GetSpecialRaceList() != null && cmdRaceList.GetData().GetSpecialRaceList().Length > 0 )||

C:\Project\PuzzleDerby\PuzDurbAndroid_Trunk_p3\Assets\GameScenes\MainMenu\Scripts\RaceMenu.cs (225, 77):      if(( cmdRaceList.GetData().GetSpecialRaceList() != null && cmdRaceList.GetData().GetSpecialRaceList().Length > 0 )||

C:\Project\PuzzleDerby\PuzDurbAndroid_Trunk_p3\Assets\GameScenes\MainMenu\Scripts\RaceMenu.cs (226, 23):         ( cmdRaceList.GetData().coopplay_event_my_race_list != null && cmdRaceList.GetData().coopplay_event_my_race_list.Length > 0 )) //ver.1.6.4

C:\Project\PuzzleDerby\PuzDurbAndroid_Trunk_p3\Assets\GameScenes\MainMenu\Scripts\RaceMenu.cs (226, 84):         ( cmdRaceList.GetData().coopplay_event_my_race_list != null && cmdRaceList.GetData().coopplay_event_my_race_list.Length > 0 )) //ver.1.6.4

C:\Project\PuzzleDerby\PuzDurbAndroid_Trunk_p3\Assets\GameScenes\MainMenu\Scripts\RaceMenu.cs (323, 40):      this.InNormalSubList( cmdRaceList.GetData().GetNormalRaceList()[0], cmdRaceList.GetData().GetNormalRaceList()[0] );

C:\Project\PuzzleDerby\PuzDurbAndroid_Trunk_p3\Assets\GameScenes\MainMenu\Scripts\RaceMenu.cs (323, 86):      this.InNormalSubList( cmdRaceList.GetData().GetNormalRaceList()[0], cmdRaceList.GetData().GetNormalRaceList()[0] );

C:\Project\PuzzleDerby\PuzDurbAndroid_Trunk_p3\Assets\GameScenes\MainMenu\Scripts\RaceMenu.cs (447, 49):      jockeyEventVersionLoader.Load( cmdRaceList.GetData().jockey_event_version, gameObject, TouchMultiSelectMain );

C:\Project\PuzzleDerby\PuzDurbAndroid_Trunk_p3\Assets\GameScenes\MainMenu\Scripts\RaceMenu.cs (472, 20):    if( cmdRaceList.GetData().GetSpecialRaceList() != null && cmdRaceList.GetData().GetSpecialRaceList().Length > 0 )

C:\Project\PuzzleDerby\PuzDurbAndroid_Trunk_p3\Assets\GameScenes\MainMenu\Scripts\RaceMenu.cs (472, 74):    if( cmdRaceList.GetData().GetSpecialRaceList() != null && cmdRaceList.GetData().GetSpecialRaceList().Length > 0 )

C:\Project\PuzzleDerby\PuzDurbAndroid_Trunk_p3\Assets\GameScenes\MainMenu\Scripts\RaceMenu.cs (1505, 37):        coopRaceExecId = cmdRaceList.GetData().coopplay_event_my_race_list[0].stage_list[0].race_exec_id;

C:\Project\PuzzleDerby\PuzDurbAndroid_Trunk_p3\Assets\GameScenes\MainMenu\Scripts\RaceMenu.cs (1508, 37):        coopRaceExecId = cmdRaceList.GetData().coopplay_event_request_race_list[0].stage_list[0].race_exec_id;

C:\Project\PuzzleDerby\PuzDurbAndroid_Trunk_p3\Assets\GameScenes\RaceMenu\Scripts\RaceRankingEventList.cs (65, 24):    datas = cmdRaceList.GetData().CoopplayEventMyRaceDatas;

C:\Project\PuzzleDerby\PuzDurbAndroid_Trunk_p3\Assets\GameScenes\RaceMenu\Scripts\RaceRankingEventList.cs (72, 24):    datas = cmdRaceList.GetData().CoopplayEventRequestRaceDatas;

C:\Project\PuzzleDerby\PuzDurbAndroid_Trunk_p3\Assets\GameScenes\RaceMenu\Scripts\RaceRankingEventList.cs (78, 24):    datas = cmdRaceList.GetData().RankingEventRaceDatas;

C:\Project\PuzzleDerby\PuzDurbAndroid_Trunk_p3\Assets\GameScenes\RaceMenu\Scripts\RaceRankingEventList.cs (107, 24):    datas = cmdRaceList.GetData().CoopplayEventMyRaceDatas;

C:\Project\PuzzleDerby\PuzDurbAndroid_Trunk_p3\Assets\GameScenes\RaceMenu\Scripts\RaceRankingEventList.cs (135, 24):    datas = cmdRaceList.GetData().CoopplayEventRequestRaceDatas;


さてやるかあ、さしあたって何やればいいのかな、とりあえず遷移図でも作るか

んで今回さしあたって一番重要なのはRaceMenuだろ？一括レース情報はNwDataRacerListに保存されて、その中にあるstage_listがおそらくNwDataRaceDataに保存されて、そこから更にローカルのRaceDataに代入されて、それからようやくRaceMenuに使われるということだと思う。
ちょっと見てみるか
  Line880,950,1025付近
  NwDataRaceListのNwDataRaceDataの中のNwDataStageDataの中の
  パラメータをRaceDataに移している
  正確にはRaceSubListItemの中のNwDataStageDataで宣言された
  dataの中身をRaceDataに移している。ちなみにRaceDataはほとんどstatic変数で
　構成されている。


やべええ、何かジョッキーイベントのJSONでエラー出てるけど理由和漢ねえよ
あこれあれか、取りあえず気にしなくていいか、ははは・・・・
とにかくｊSONを見てみよう

そういうことか・・そういうことか
どこで一体指定ホースが表示されんのかなと思ったけど
これあれか、確か記憶だとリストの下部に表示されてたな

んんん、NwDataStageDataの中のsub_titleが表示されんねんな・・・・・

あれええ、RaceDataに代入されるタイミングが独特だな
ヘルパーホース選ぶ画面でおそらく代入されている
つまりそれ以前はRaceDataのconditionValuとかは使えないってことか

>坂本さん
おつかれさまです。遅ればせながら条件レースのテストをやっているのですが、今現在もサーバの方ではcondition_valueは配列になっていますでしょうか？受け取ったJSONによりますと、条件レースは指定カード限定（リーダー）で、con


NwDataMultiLobbyDataなんだこれは、なんで似たようなの二つもあるんだ
ちょっとまてよ、これもしかしてなんか・・・・
もしかしてマルチでもうううううううううううううんん

うわ面倒くせえ、rairty_idなんて外から見えねえじゃねえか

で、結局RaceDataの代入はどこで、あ、忘れてた

さ、まあだいたい終わったからね、次はラベルの設定やね
同じカードスプライトつこうてるなら、そう難しくはないはずやけどね	
さて一体どこから手をかけていけばいいのか
まずどの段階で、うーん

たぶん最初のヘルパーホース選択画面は、RaceMenuの中のinstanceHelperListを使って描画している。まあようはHelperListですな。HelpeListはまたMenuBaseを継承している。


>坂本さん
おはようございます。条件レースですが、JSONのcondition_valueの配列が配列になっていることを確認し、こちらのスクリプトもそれに合わせたものに変更しました。ありがとうございました。
次に2点ほど確認事項があります。今回の条件レースでは指定ホースと指定カードという言葉が出てきますが、プログラム的には指定ホースがhorse_rarity_group_id、指定カードがhorse_card_idのことで間違いないでしょうか？
また今テストで渡されているcondition_valueが8、condition_typeは1ですが、JSONのsub_titileが設定されていないので、画面にどういう条件レースなのか表示されない状況です。この点はまだ気にする段階ではないでしょうか？お手数ですがよろしくお願いします。

まああああじかあああ、ヘルパーホースに使われてるNwDataUserDataってさ、id情報が足りねえんだけど、と思ったけどたりたわ

NwDataUserDataの中のNwDataUserHorseを使えばいいのか

まず今俺がやろうとしていることなんだけ、SETDATAを探していた樹がするんだが
ああそうだ、条件レースの条件の表示だ

なんだこれびっくりだな
sub_title.Textに設定されている文字列が、日本語じゃない
sub_title : "4e2d7d1a30fb30ea30fc30c030fc98a896505b9a"

なにこれ、これが結果的に中級・リーダー風限定されるらしい
sub_title : "4e0a7d1a30fb30c130fc30e098a896505b9a"
これだと上級・チーム風限定　めんどくせえ
ていうか意味わからん
UNICODEで4E0Aが上に当たるらしいですよ
なんだかよく分からんが、JSONで文字列渡すときはUNICODEなのか、んでしたが4e2dですな

うわあああ、これhorse_group_id突っ込むところ多すぎて面倒くせえぞ
present_list　NwCmdPresentReceive

    { typeof(NwCmdHorseEnhance),      new UrlData( "POST", true, "http://", "farm_horse_powerup", 9 ) },
    { typeof(NwCmdHorseEvolution),    new UrlData( "POST", true, "http://", "farm_horse_evolution", 10 ) },
    { typeof(NwCmdHorseReincarnation), new UrlData( "POST", true, "http://", "farm_horse_reincarnation", 53 ) },


farm_horse_powerup, farm_horse_evolution, farm_horse_reincarnation, mission_receive , shop_gacha_exec, race_helper_list, race_result, coopplay_race_result, shop_point_recovery, multiplay_lobby_search, multiplay_player_search, friend_list, friend_request_list, present_receipt, user_search

>坂本さん
おつかれさまです。sub_titileの件了解しました。

horse_card_group_idの件ですが、JSONのuser_dataは起動直後に一回呼ばれるのみなので、ゲーム中、馬一式のデータを渡す箇所がある、ほぼ全てのJSONに入れ込む必要があると思われます。たとえばトレーニング時のfarm_horse_powerupの中のenhance_horse、shop_gacha_execの中のall_horses、present_receiptの中のhorsesなどです。
これらのJSONの馬データにhorse_card_group_idが入っていないと、ローカルに0が代入されてしまうため、再起動を経由しない限り、条件レースで正常に同じ馬の判定が出来ないと思われます。
数が大変多いのですが、検索した結果によりますと、以下のJSONの中の馬データに入れ込む必要があります。
farm_horse_powerup, farm_horse_evolution, farm_horse_reincarnation, mission_receive , shop_gacha_exec, race_helper_list, race_result, coopplay_race_result, shop_point_recovery, multiplay_lobby_search, multiplay_player_search, friend_list, friend_request_list, present_receipt, user_search
お手数ですがよろしくお願いします。


{ typeof(NwCmdMissionRewardReceive),new UrlData( "POST",   true, "http://", "mission_receive", 61 ) },

    { typeof(NwCmdGachaAction),    new UrlData( "POST",   true, "http://", "shop_gacha_exec", 19 ) },

    { typeof(NwCmdHelperList),     new UrlData( "POST",   true, "http://", "race_helper_list", 5 ) },


    { typeof(NwCmdRaceResult),     new UrlData( "POST",   true, "http://", "race_result", 7 ) },

    { typeof(NwCmdCoopRaceResult), new UrlData( "POST",   true, "http://", "coopplay_race_result", 51 ) }


    { typeof(NwCmdEntryPointRecovery), new UrlData( "POST", true, "http://", "shop_point_recovery", 16 ) },

    { typeof(NwCmdMultiLobbySearch),            new UrlData("POST", true, "http://", "multiplay_lobby_search", 103, true) },

    { typeof(NwCmdMultiPlayerSearch),           new UrlData("POST", true, "http://", "multiplay_player_search", 106, true) },


    { typeof(NwCmdFriendList),        new UrlData( "GET",    true, "http://", "friend_list", 20 ) },
   { typeof(NwCmdFriendRequestList), new UrlData( "POST",   true, "http://", "friend_request_list", 24 ) },

{ typeof(NwCmdPresentReceive),    new UrlData( "POST",   true, "http://", "present_receipt", 27 ) },

{ typeof(NwCmdUserSearch),        new UrlData( "GET",    true, "http://", "user_search", 28 ) },



POST:http://stg.api.derby.pzga.jp/version1.0/present_list
UnityEngine.Debug:LogWarning(Object)
LHDebug:Log(String) (at Assets/GameScenes/Common/Plugins/General/LHDebug.cs:169)
NetworkManager:MakeWWW() (at Assets/GameScenes/Common/Scripts/Network/Common/NetworkManager.cs:316)
<Connect>c__Iterator20:MoveNext() (at Assets/GameScenes/Common/Scripts/Network/Common/NetworkManager.cs:344)
UnityEngine.MonoBehaviour:StartCoroutine(IEnumerator)
NetworkManager:RegistCmd(Type) (at Assets/GameScenes/Common/Scripts/Network/Common/NetworkManager.cs:279)
NwCmdBase:Exec() (at Assets/GameScenes/Common/Scripts/Network/Common/NwCmdBase.cs:219)
NwCmdPresentList:ExecCmd() (at Assets/GameScenes/Common/Scripts/Network/Friend/NwCmdPresentList.cs:23)
PresentList:RemoveListItem(Int32) (at Assets/GameScenes/HomeMenu/Scripts/PresentList.cs:267)
PresentList:<SuccessReceiveAll>m__15E(Int32) (at Assets/GameScenes/HomeMenu/Scripts/PresentList.cs:327)
CommonWindow:CallBtnDelegate(Int32) (at Assets/GameScenes/Common/Scripts/CommonWindow.cs:214)
<Set>c__AnonStorey167:<>m__51() (at Assets/GameScenes/Common/Scripts/CommonBtn.cs:20)
<SetCallbackWithSound>c__AnonStorey159:<>m__8(IUIObject) (at Assets/GameScenes/Common/Plugins/General/ExtensionClass.cs:92)
UIButton:OnInput(POINTER_INFO&) (at Assets/UnityAssets/EZGUIandSM2/Plugins/EZ/GUI/Controls/UIButton.cs:323)
AutoSpriteControlBase:OnInput(POINTER_INFO) (at Assets/UnityAssets/EZGUIandSM2/Plugins/EZ/GUI/Support/AutoSpriteControlBase.cs:1175)
UIManager:DispatchHelper(POINTER_INFO&, Int32) (at Assets/UnityAssets/EZGUIandSM2/Plugins/EZ/GUI/Management/UIManager.cs:1539)
UIManager:DispatchInput() (at Assets/UnityAssets/EZGUIandSM2/Plugins/EZ/GUI/Management/UIManager.cs:1354)
UIManager:Update() (at Assets/UnityAssets/EZGUIandSM2/Plugins/EZ/GUI/Management/UIManager.cs:1303)


これ覚えと請うぜ
	//ラベルの貼り付け
if(isImpossibleRun)
{
  leaderCard.SetStatus( HorseCardSprite.Status.Unavailable );
  leaderCard.SetLabelStatus(CardLabelType.NoRace);
}

頭のこんがりぐあいがすごい、絡み合いすぎて沸け分からん
とりあえずさ、今helperListからhelperBordにやっている処理を、おんなじかんがじで
raceConfirmからraceConfirmItemにやるだけでしょ？何でこんなにこんがらがってんだ
しかもhelperListからhelperBordより簡単だと思うよやるの
まずCheck関係の場所を正確に覚えよう

RaceMenuのStarRaceから
RaceConfirmのCheckSameOver()
そこから更にRaceConfirmItemのCheckMatchjSameID
なるほど


むかつくほど頭がこんがらがってるぞ、一体何が最適なんだ


なんか相当面倒くさいい・・・・・

とくに

helperListからどうやってraceConfirmItemの中の関数にアクセスできるんやろか
いやはっきりいって無理や炉、
だって助っ人選んでるときはまだraceConfirmItemが生成されてないから
じゃあRaceConfirmはどうだろうか？いやこれも望み薄いな
となりますと、やはり独自に作るしかないではありませぬか

やばいマルチがわからない、
calcStatusが呼ばれていない、もう一回マルチの遷移を見直さないと駄目だ・・・・
まずmultiConfirmItemのsetDataは呼ばれている
これは間違いない、ただしその下にあるcalcStatusが呼ばれていない
とするとだよ、どうやって、どこでleaderFemaleに値が代入されているかということになる。
ちなみにRaceConfirmでは、SetDataの中でthis.CalcStatusで呼んでいる。

>大阪さん
おつかれさまです。スクリプトを見るとマルチの方では条件レースをやっていないように思うのですが、今回の条件レースのアップデートでは、マルチは触る必要がない認識で合っていますでしょうか？

了解しました。ひとまずマルチの方でも一通りの準備は整えておきます。よろしくお願いします。

まずいなやる気がだだ下がりだ、もう返りたい、もう少し頑張るか

なるほどなあ
なんだこのマルチのtailってのは、とりあえずマルチってのは自分が最初の3頭だけ、
そしてもう3頭が誰かさんってことじゃあないのか
この計算でいくと、最初の値は
    pageMax = maxTeamNum;
    int no = 0;
	this.CalcStatus( horseIds, friendHorses);
    NwDataUserHorse[] horses = new NwDataUserHorse[5];
    for(int i = 0; i < 5; i++) {
      horses[no] = UserDataManager.Instance.GetHorse(horseIds[i]);
      if(horses[no] == null/* || no >= 3*/) {
        int tail = 4 - (i - no);

4 - (0 - 0)で
その後の
        cardSprites[tail].SetData1((SaveData.RacePage == RaceType.Ranking) ? -2 : -3/*tail*/, null, cardCallBack, cardCallBack);
        cardSprites[tail].gameObject.SetActive(false);
では、
つまるところcardSprites[4]にsetdataしていることになる
これはおかしくないか？cardSpritesの5個目に入れてる
もうシングルとかわんねええじゃん。


    pageMax = maxTeamNum;
    int no = 0;
	this.CalcStatus( horseIds, friendHorses);
    NwDataUserHorse[] horses = new NwDataUserHorse[5];
    for(int i = 0; i < 5; i++) {
      horses[no] = UserDataManager.Instance.GetHorse(horseIds[i]);
      if(horses[no] == null/* || no >= 3*/) {
        int tail = 4 - (i - no);
        cardSprites[tail].SetData1((SaveData.RacePage == RaceType.Ranking) ? -2 : -3/*tail*/, null, cardCallBack, cardCallBack);
        cardSprites[tail].gameObject.SetActive(false);
      } else {
        cardSprites[no].SetData1((SaveData.RacePage == RaceType.Ranking) ? -2 : -3/*no*/, horses[no], cardCallBack, cardCallBack);
        cardSprites[no].gameObject.SetActive(true);
				cardSprites[no].OmitLabelCampaignSpecificRace(RaceData.RaceId);
        if(no <= 2) {
          cardSprites[no].SetEnable();
        } else {
          cardSprites[no].SetDisable();
        }
        no++;
      }
    }

いやその前にさ、if(horses[no] == null
ってあるでしょ？
さらにその前にhorses[no] = UserDataManager.Instance.GetHorse(horseIds[i]
)とありますな？

horsesIdsはSetDataで渡された引数
さらにその引数の私元をみると
    Dictionary<int,NwDataTeamDetail> datas = UserDataManager.Instance.GetTeamDatas();
    teamNum = datas.Count;
とある。

つまりこのhorseIdsは紛れもなく自分自身の馬チームの情報である。
その馬チームの一番目の馬ﾃﾞｰﾀがhorses[0]に代入されるわけですなあ
しかしてみて、一番最初のif ( horsres[no] == null)なるは、もう自分のチームの馬が一等もいないということにならんか？
なるほど、整頓か
間に隙間があっても前に詰めるいう訳か
隙間の空白は最後列（horses[4]）に移動させる

        if(no <= 2) {
          cardSprites[no].SetEnable();
        } else {
          cardSprites[no].SetDisable();
        }
        no++;

これなるは簡単であるな、自分のチームの馬3投目以降は、暗くするいうことじゃｙ


    if(MultiLobbyStatus.multiType == MultiType.Host) {
      errorReason = RaceData.CalcStatus(new NwDataUserHorse[3]{horses[0], horses[1], horses[2]}).errorReason;
    } else {
      errorReason = "";
    }
    staminaNameText.Text = TextManager.GetText("race/confirmTotalStamina");
    staminaValueText.Text = GetTotalStamina(horses).ToString();
    NwDataUserHorse leaderHorse = cardSprites[0].GetData();
    if(leaderHorse.GetMasterData().master_leader_skill_data != null) {
      leaderSkillName.Text = string.Format(TextManager.GetText("common/horse/leaderSkillFormat"), leaderHorse.GetMasterData().master_leader_skill_data.name);
      leaderSkillDetail.Text = leaderHorse.GetMasterData().master_leader_skill_data.description;
    } else {
      leaderSkillName.Text = TextManager.GetText("common/horse/noLeaderSkillFormat");
      leaderSkillDetail.Text = "";
    }


これなるはなんぞや、HOStとGUESTで対応が変わるいうことかえ
ホストだと何かようわからんエらーだ寸か？しかしホストだとエラー出すってどういうことだ

まず何しようか、とりあえずinstantceRaceConfirm、RaceConfirmItemのSetDataと
instanceMultiConfirmのCreateData、ＭｕｌｔｉＣｏｎｆｉｒｍＩｔｅｍのＳｅｔＤａｔの違いをみていかなくては、
まず前者、シングルレースの流れは、
RaceMenuのTouchSubRaceTitle
ここでコールバックのTouchHelperを設定
TouchHelperの中から
ＲａｃｅＭｅｎｕのSetConfirm
ＲａｃｅＣｏｎｆｉｒｍのCreateData
RaceConfirmItem

RaceMenuのTouchSubRaceTitleからじかに
MultiConfirmのＣｒｅａｔｅＤａｔａ
MultiConfirmItem

つまりもう流れが全然違うんだよね
multiの方が何本か処理抜かしてるか
厳密に言うとシングルレースでもTouchSubRaceTiｔeは通ってる
TouchSubRaceTitleの中で、switch文があって
その中で    case MultiType.Single:　であれば
一度HelperＨｏｒｓｅ画面をはさむため、すぐにはいかない
んｎ、結局俺何がしたいんだっけ

そうだ、その○○ConfirmItemを作成するCreateDataに渡す引数が異なっているんだ
たしかRaceConfirmImteのＣｒｅａｔｅＤａｔａの方がHelperホースが入る分
引数が多い。

してみるとさ、シングルのhelperにあたるのがマルチの共闘馬なんでしょ？
その馬の情報はどっから持ってきてるんだ？
引数に入れてはないのか
これやべえな、現状どっからもとってきてねえじゃねえか
しかしマルチレース自体はやってるんだから、とってきてねえってことはありえねえだろ
俺の見落としか
なんか不安になってきたんだけど、そもそも今このMultiConfirmItemって通ってるの？

ホスト時は具体的なレースを選んだ瞬間にTouchSubRaceTitle()が呼ばれて
MultiConfirmをCreateする
ゲスト時は「マルチ」を選択した次の画面で「レースに参加する」を選んだ時点で
  void TouchSubRaceTitle(){が呼ばれて
MultiConfirmをCreateする


そうか、マルチはＣｏｎｆｉｔｒｍ画面の更に咲きがあるんだな。。。
とりあえずConfirmの次にRaceMenuのＭｕｌｔｉＣｏｍｍｅｎｔへ？
いやMultiCommentはただのオブジェクトか・・・・？いや違うか・・・
でその次にMultiLobbyにはいってようやくレーススタート
ゲスト時だとそもそもロビーがなくて入れないことが多い

じゃああれか、他人のチームの馬情報はMultiLobbyじゃないのか

まあつまりはさ、つまりはさ、
confirm画面の出走不可の表示はそんなに難しくないってことなのだよ
ただ第二の問題としてはどこでCheckMultiConditionをぶちこむかってことなんだよな
ちなみにこれに対応するシングルレースの関数ｊは、
もうStartRaceって関数なんですよね
しかしるにつきましてStartRaceはどこでよばれているかというのを確認しますと
SetConfirmという関数で、RaceConfirm画面の作成を行うと同時に
コールバックを設定している。
instanceRaceConfirm.CreateData( RaceData.ChapterName, RaceData.StageName, data, StartRace, curRaceId );

と、と、としますとだね、やはりうーん、でもなああ。、。
MultiConfirmでチェックするほうがいいのか、MultiLobbyでチェックするほうがいいのか
でもまあ、まず一度MultiConfirmではじいてもいいんじやないか
むしろそっちの方がいいと思う。
とするならば一体どこにおくべきか、やはりMultiConfirmを作成するところでcallbackとして
仕込むのがよかろうよ
しかしねCheckMultiConditionは本当にConditionをチェックするだけの関数だけども
果たしてStartRaceはどうか
うーん、明らかにチェック以外のことを多くやってはいるが、しかしこれ、まあシングルの場合はレース直前のことだから当たり前だよな。これはマルチにおいてはＭｕｌｔｉＬｏｂｂｙでやるのが相応しい内容であろう
1030
とするとTouchSubRaceTitle()のＣase Multi何かするとよい
比較するとMultiが
Line1030付近
instanceMultiConfirm.CreateData(RaceData.ChapterName, RaceData.StageName, MultiLobbyStatus.multiType, TouchMultiConfirm);
大してSingleがが
Line1145付近
instanceRaceConfirm.CreateData( RaceData.ChapterName, RaceData.StageName, data, StartRace, curRaceId );

ちょっと待てよ、なぞなんだけどもさ
条件レースがないときも、シングルでは条件判定してるよな、
そういう場合ってどういう挙動してるんだ
なるほど、カテゴリにはNoneとかあるから問題ないわ、switch文を素通りするだけだ
public enum Category
{
  None = -1,
  None0,
  Sex,
  Cost,
  Element,
  Type,
  Rare,
  Same,
  Horse,
  Card
}
ん、ちょっと待てよ、ゲストのときはそもそもこのCheckMultiConditionとおらねえぞ
じゃあどこで判定するんだ、いやちょｒとまてよ
とりあえず喫緊の問題としてはさ、ホストとゲストで画面遷移が全然違うことなんだよ
ホストの場合レースを選んでからまず自分の提出するチームを選ぶけど
ゲストの場合はチームを選んでから現在部屋があるレースを選ぶんだよ
だからさ、もしあのmultiConfirm画面に出走不可を実装するとしてもさ
それはホストに対する遷移にしか実装しちゃだめだよね、ゲストではまだレースを選んでないわけだから
とすると、同じMultiConfirm画面でもホストとゲストで表示される画面の仕様が異なることになる
とすると一つの可能性として、ゲスト時はチームではなくレースに出走の可否表示をいれることになるね
どうする、まず自分の中で方向性決めようや、どっちが親切やと思う

まずホスト側の立場に立てばLobbyを待たずにConfirmではじいた方が圧倒的に親切やろな
せっかくチームが集まったところで実は自分のチームが条件外でしたとか萎えるからな
とすると、ゲストのときの表示の使用が変わるざるを得ない、しかしまあ、それでもしゃあないか。。。？
じゃあそういう感じで実装進めますか・・・？
ちなみにマルチのホストを選んだときってどこでRaceDataにConditionぶちこんでんだ？

 TouchMultiSelect

TouchMultiSelec

んんん、MultiLobbyItemって３で限定なの？最大６つじゃねえのか


おつかれさまです。現状16日までに実装できるか分からないのですが、マルチでの「出走不可」のラベルの表示で、これは最後の確認画面であるロビーでのみ出す方向でしょうか？
またはその前段階の、自分のチームから３馬を選ぶ画面でも表示した方がいいでしょうか？お手数ですがよろしくお願いします。

出走不可は表示しておいて、ロビーには遷移できるという認識であってますでしょうか。
例えば仮に３頭目が出走不可であっても、最後のロビーで３人あつまれば自分のチームは先頭２馬のみ出走ということになり、出走条件がクリアできてしまう可能性もあります。
それともやはり３頭とも出走条件をクリアしていないとロビーには進めないようにするべきでしょうか。
長々と失礼しますがよろしくお願いします。

>大阪さん

>大阪さん
ご解答有難うございます。さらに３つほど確認したい事がありますので、よろしくお願いします。

条件チェックの意味なのですが、これはルームには遷移させないという事で合っていますでしょうか。
また現在こちらで実装している仕様ですと、シングルの助っ人で出走不可は表示して暗くしていますが、それを選んでも最後の出走確認画面には進めます。ここもやはり遷移はさせないようにすべきでしょうか。
またさきほど思ったのですが、シングルレースでは必ず助っ人を選択しなければいけないですが、助っ人が全員出走条件を満たしていないということはありえますでしょうか。

お手数ですがよろしくお願いします。



チェック事項
race_list　ない
user_data　○
farm_horse_powerup　○
farm_horse_evolution　○
farm_horse_reincarnation　○
mission_receive　○
shop_gacha_exec　○
race_helper_list　　○　
friend_request_list　○
present_receipt　○
user_search　○
friend_list　　○
multiplay_lobby_search　別件では×
multiplay_race_result　別件につき遷移不可
multiplay_race_result_announce　上に同じ

とりあえずマルチやろかマルチは先のmultiplay_lobby_searchが解決しないと何も確認できない、後回しや

>坂本さん
お忙しい中失礼します。マルチでも条件レースの予定があるということで、condition_valueを配列にする必要が他のところにもありまして、multiplay_lobby_search
の中のcondition_valueを配列にしていただけないでしょうか。よろしくお願いします。

race_list

multiplay_lobby_search






まず何をどうするか考えよう
サーバとの関係を調べる言う手も\\temona
まずどのスクリプトを調べればいいんだろうか
まずどの変数に突っ込んでんのか調べるか
そうだMultiLobby画面の、変数３つ
めんどうくせえなこれ

鍵はNwDataMultiUserDataですなあ
ここで馬情報を受け取って代入している。ちょっと代入の流れみてみるか

      NwDataMultiUserData data = (list != null && i < list.Count) ? list[i] : null; 
      multiLobbyItems[i].SetData((list != null) ? list.Count : 0, data, ShowCardDetail);

おそらくだけど、自分の想定だと
JSONの「multiplay_player_search」からNwCmdMultiPlayerSearchの中の
NwDataMultiUserListへ情報が流れて、
その中のNwDataMultiUserData[]を実際に使う。この配列はそれぞれ参加する人数だけ増える。
さらにこのNwDataMultiUserDataの中の NwDataUserHorse[]が
一人の人間が提出した３つの馬の思われる
これがたぶん  multiLobbyItems[1]、もしくは  multiLobbyItems[2]に入る情報である。問題はこの細かな代入までの流れ。
うーん最初にｸリエイトしたときはMutilobbyは
    RefleshUserData(null, -1);で第一引数がnullなんだよな
この第一引数がnullだろ
  multiLobbyItems[1]にもなにも入らんぞ。一体因数はいつはいるんだ。
うーんわからん、本当にわからん、一帯に何をすればいいんだ

あ、ReloadPlayer()のときに    
var cmd = GetCmd<NwCmdMultiPlayerSearch>();がよばれて
その後でRfrleshUserDataが行われているな
むしろこれが普通なんじゃねえの。

うーん、CreateDataの段階ではlistがnullだから
multiLobbyItemsに何も入らなくて、
その後でどこかでReloadPlayer(）実行されて
結果ようやくmultiLobbyItemsに代入されるわけか

みるとReloadPlayerが行われている場所はw三箇所だな
まず一つ目、これCreateDataの後ろのほうでやってたわ
つまりやっぱり初期化で代入してんだわ
あともう一つがReLoad()ってとこの中に二箇所あるわ
ReLoadはUpdateの中で呼ばれている

    if(reloadTimer < 0) {
      reloadTimer = RESEARCH_TIME;
      Reload();
    }

んんよくわからん
とりあえず初期化だけ考えておけばよかろう
んん199行目、      List<NwDataMultiUserData> list = cmd.GetUserList();
ってあるけど
このNwDataMultiUserDataはの中のUserListは、一体いつ打ち込まれたんだ


んんMultiLobbyのReloadPlayerの一番したに
 cmd.ExecCmd();というのがあるね。
みたところここでしか、NwDataMultiUserDataに値を代入していないようだけど


んんんｎReloadPlayerの中身ってほとんどSetCallbackなんだなあ
  public void SetCallBack( NwSuccessCallback cbSuccess, NwFailedCallback cbFailed = null )
  コールバックの中身はこれね

    cmd.SetCallBack(() => {
      if(!Login) {
        Login = true;
        LoadStop();
      }
      List<NwDataMultiUserData> list = cmd.GetUserList();
      RefleshUserData(list, cmd.GetSubCaptainId());
      if(cmd.IsReady()) {
        reloadPause = true;
        if(LimitCheck()) {
//         gameStart();
          StartCoroutine(MatchAPICycle());
        } else {
          if(errorReason != "") {
            CommonWindow.Instance.SetDatas(errorReason, (idx) => {
              CommonWindow.Instance.PlayCloseAnim();
              ErrorLogout();});
            Transform curObject = (MenuBase.CurMenuBase != null) ? MenuBase.CurMenuBase.transform : null;
            CommonWindow.Instance.PlayOpenAnimAfterCloseAnim(curObject, true);
          } else {
            if(multiType == MultiType.Host) {
              LoadStop();
            }
            ErrorLogout();
          }
        }
      } else {
        bool isLimit = LimitCheck();
        if(!reloadPause && multiType == MultiType.Host) {
          decideBtn.controlIsEnabled = (list != null && list.Count >= 2 && isLimit && /*!subcaptainIsNotFound.IsNotFound &&*/ !subcaptainIsNotFound.IsSending);
        }
        reloading = false;
      }
    }, (err) => {
      APIError(cmd, ErrorLogout);
    });

なんだこのむちゃくちゃな構文、どこが始まりでどこがおわりなんだ
まあでも文法的にみて
SetCallBack( NwSuccessCallback cbSuccess, NwFailedCallback cbFailed = null )
の第二引数は
(err) => {
APIError(cmd, ErrorLogout);
});
ここらへんだろうなあ、しかし、この構文はナンなんだ、これが無名関すいうやつやろか
このerrなんてどこにも宣言されてないし、名前は何でもいいのかな

まあそれは置いといて、第二引数の割り当てはまだ分かるよ
問題は第一引数な、むちゃくちゃ長居上に構文も意味わからん
    cmd.SetCallBack(() => 
{
      if(!Login)
　　 {
        Login = true;
        LoadStop();
      }
      List<NwDataMultiUserData> list = cmd.GetUserList();
      RefleshUserData(list, cmd.GetSubCaptainId());
      if(cmd.IsReady())
　　 {
        reloadPause = true;
        if(LimitCheck())
　　　 {
//         gameStart();
          StartCoroutine(MatchAPICycle());
        }
　　　 else
　　　 {
          if(errorReason != "")
　　　　 {
            CommonWindow.Instance.SetDatas(errorReason, (idx) =>
　　　　　 {
              CommonWindow.Instance.PlayCloseAnim();
              ErrorLogout();});
            Transform curObject = (MenuBase.CurMenuBase != null) ? MenuBase.CurMenuBase.transform : null;
            CommonWindow.Instance.PlayOpenAnimAfterCloseAnim(curObject, true);
          　}
　　　　　 else
　　　　　 {
       　　     if(multiType == MultiType.Host) 
　　　　　　　{
         　　     LoadStop();
    　　        }
            ErrorLogout();
      　    }
        　}
      　}　
　　　 else
　　　 {
        bool isLimit = LimitCheck();
        if(!reloadPause && multiType == MultiType.Host) {
          decideBtn.controlIsEnabled = (list != null && list.Count >= 2 && isLimit && /*!subcaptainIsNotFound.IsNotFound &&*/ !subcaptainIsNotFound.IsSending);
        }
        reloading = false;
      }
    },



nnnnnnなんかなんとなくわかった、もうめんどうくせえ
まあでもこのSetCallbackはコールバックの設定だからな
実際に実行しているわけじゃない、実行されるのはもっと後
だから実質、最初にこのReloadPlayrに来たときは
cmd.ExecCmd();が実行されると考えてみていいんじゃないかな・・・・・
いや待てよ、今度実際にコールバックがどこで実行されるか考えてみよう

ああこれ駄目だわからん
うわあ参ったな、いろんなものGetCmdしてんな
    var cmd = GetCmd<NwCmdMultiPostSubcaptain>();

まずまとめると、キーワードは

multiplay_player_search
NwCmdMultiPlayerSearch
NwDataMultiUserList
NwDataMultiUserData[]
NwDataUserHorse[]

まずmultiplay_player_serchが呼ばれるのはどこの段階か

んｎ、とりあえずmakeDataが呼ばれるのは、ゲストの場合
MultiLobbySelectItemがクリックされた瞬間だな
その直後にＲｅｌｏａｄＰｌａｙｅｒで設定されたコールバックも呼ばれているね
なんだこれ、、、
ホストの場合はちょっと変わってんな、ReloadPalayerが呼ばれた後に
MakeDataが呼ばれてる

あごめんおんなじだった、
つまりどちらの場合も、ReloadPlayerの中の
一番下、cmd.ExecCmd();がよばれたときにはじめてNwCmdMultiPlayerSearchの中の
ＭａｋｅＤａｔａが呼ばれる。
ExecCmdってのはMakeDataを呼ぶための関数なんだな
んでなんだかわからんけどその直後に設定されたコールバックが呼ばれている
おそらく、サーバからの応答が来た時点で呼ばれるのがこのコールバック
つまりNwCmdMultiPlayetrSearchで言えば132行目のcbSucces、もしくはcbFailed
しかし実際にはこれは更に親クラスのsuccessCallBackとfailedCallbackに代入される
つまり、サーバから応答はこのsuccesCallBackかfailedCallbackに二元化されるわけだ
今回のネットワークにかんして言えば、ExceCmdが呼ばれたらほぼ間髪なくサーバ
から応答が着てる

ちょっとタイミングずらしてみようか
ああ、これ別に用がなくてもずっとループしてんのか・・・・・
そもそもExcecCmdとはナンなのか、情報を送っているのか、貰っているのか
いや、両方なんじゃないか？前は送っていることもあったじゃん
今回に関して言えば、おそらく貰っているだけ。、

前に一度イベントレース関連でサーバ側にコンボ数とか新たに情報を送ったことがあるので

どこでゲストがホース情報を渡しているのか
おそらくJSONの
multiplay_guest_entryの中の
スクリプトで言うとNwCmdMultiGuestEntrymの中の
base.SetIntParam("use_team_id", UserDataManager.Instance.GetUseTeamId());
で渡している

とするとやはり、ホストの方は3頭選出画面で、プログラムの方ではじけるけど、コストに関してのみ3頭選出の時点ではじくことはできない
これはゲストが入るルームを選択することになった瞬間に、すでにmutiplay_guest_entryで

あれ、ホストはどこではじいてるっけ。
ああ確かMultiConfirmだったな

んん、どこでGuestの場合、if文処理すればいいんだ。


  private IEnumerator ChangePhase( RaceMenuPhase phase )
  {
    if( curMenu != null ) curMenu.Out();
    while( !MenuBase.IsFinished ) yield return 0;
    
    TitleBoardManager.Instance.GetRacePhase( curPhase );
    curPhase = phase;
    switch( curPhase )
    {
    case RaceMenuPhase.MultiSelect      : curMenu = instanceMultiSelect; break; // multi
    case RaceMenuPhase.HostSelect       : curMenu = instanceHostSelect; break;  // multi
    case RaceMenuPhase.NormalTop        : curMenu = instanceRaceNormalList; break;
    case RaceMenuPhase.SpecialTop       : curMenu = instanceRaceEventList; break;
    case RaceMenuPhase.NormalRace       : curMenu = instanceRaceNormalSubList; break;
    case RaceMenuPhase.SpecialRace      : curMenu = instanceRaceEventSubList; break;
    case RaceMenuPhase.Helper           : curMenu = instanceHelperList;      break;
    case RaceMenuPhase.Confirm          : curMenu = instanceRaceConfirm;     break;
    case RaceMenuPhase.RankingEventTop  : curMenu = instanceRankingEventList; break;
    case RaceMenuPhase.RankingEventRace : curMenu = instanceRankingEventSubList; break;
    // multi
    case RaceMenuPhase.MultiConfirm     : curMenu = instanceMultiConfirm; break;
    case RaceMenuPhase.MultiLobbySelect : curMenu = instanceLobbySelect; break;
    case RaceMenuPhase.MultiLobby       : curMenu = instanceLobby; break;
    case RaceMenuPhase.MultiComment     : curMenu = instanceMultiComment; break; //2014.11.19
    }

んんこれ重要　なんか考えたら大分一本化できそうだな

MenuBaseConditionFlag
と
ConfirmItemConditionFlag
をつっくて一本化するか
RaceStart()とCheckMultiConditionも一本化しよう


いま条件判定のスクリプトが凄い分散している
まずRaceMenuでは
RaceStart（）と最後のCheckMultiCondition
あと若干だけど、その上の

  private void CheckMultiCondition(MultiConfirmCheckCallback Success )
  {

スクリプト一本化難しい
curPhaseをCreateDataするときに渡せば一番簡単だけど、それはやりたくない
どうにか良い方法はないもんか。delegate使ってなんとかできないかな・・・・
ｘ

Line709   void TouchLobbySelect(MultiLobbySelectItem lobbyItem) {


Line165
NwCmdMultiGuestEntry

ホスト
ＮｗＣｍｄＭｕｌｔｉＬｏｂｂｙＣｒｅａｔｅ
NwCmdMultiPlayerSearch

ゲスト
ＮｗＣｍｄＭｕｌｔｉＬｏｂｂｙＳｅａｒｃｈ


>坂本さん
おはようございます。長いですがマルチの条件レースでの相談になります。
condition_category1から8までの条件の内、大抵のものはローカル側だけで条件に合わないユーザーを追い出すことができると思うのですが、コスト制限と同一ホース禁止の条件は、ユーザー同士の馬が集まってチームが決定してからでないと判断ができないように思います。
ホストが自分の馬3頭を選ぶ段階、またはゲストがルームを選ぶ瞬間で、コストオーバーや同一ホースがいるかの判断がローカル側で難しいです。
例えばある部屋にゲストが二人がほぼ同時に入ってきたとして、２人目の段階ではコスト条件を満たしているものの、３人目が入ってきたことで構成が変わってコストオーバーしてしまうとします。
その場合は、３人目の視点で見てその人が部屋に入れないようにするのが、簡潔で最適な方法だと思います。
現在の仕様ではそうなっていないと思いますが、仮にゲストのローカル側が事前に現在のルームのチーム構成をサーバから受け取って知ることができたとしても、２人目に間髪いれず３人目が入ってきた場合、通信は一瞬で終わるわけではないので、３人目は２人目が入る前のチーム構成を取得してしまう可能性があります。
なので個人的には手を尽くしてもローカル側でこの２つの条件レースのチームの追い出しを実装するのが難しく感じます。
この２つに関してはサーバ側で処理を実装していただいて、条件に合わない場合multiplay_guest_entrｙで何かエラーを送ってもらうのが良いと思うのですが、もしくは、他に提案がありましたらよろしくお願いします。


よししょうがない仕事するか
とりあえず直近としては、あかん思考停止や・・・・
とりあえず階層したCheckMultiCondition()をつかってマルチのゲストの追い出しができるか考えてみよう
まあ予想ではたぶん無理やな，でも考え見ようや
まあこれっていうのは、関数に飛んだ先でも分かるけどさ、
ん、もしかして出来るのか？

UseTeamIdの0から2番目で判断すればいいんのんか？
Lo
まあそれはいいとして、どうやってこれから入ろうとするルームのレースのcondition見ればいいんだ？もうね、わからないんですよ、
ＧｅｔＤａｔａでいいのか？

とりあえず現状認識でいくとNwDataMultiLobbyListのなかの
NwDataMultiLobbyDataのcondition情報が欲しい、本当に欲しい
そしてNwDataMultiLobbyListにデータを送っているのは
NwCmdMultiLobbySearch である

とりあえずNwCmdMultiLobbySearchのＧｅｔＬｏｂｂｙＬｉｓｔでルームの情報は取得できる、じゃあどうするの？今でしょ！

やり方としては2通り考えられる
Lin561のInLobbySelect
もしくLine715のTouchLobbySelec
んん、まあ結局はＧｅｔＣｍｄで取得すればいいだけだからな

どっちでも出来るようなな気もしてる
ん、InLobbySelectで、ＮｗＣｍｄＬｏｂｂｙＳｅｒａｒｃｈのクラスは取ってきているけど、その中の豊富な情報はほとんど使われていない。
というか過去に使われたことがあるんでしょうか
つかってんじゃねえかだまされた
nstanceLobbySelect.CreateData(cmd.GetLobbyList(), MultiLobbyStatus.lobbyKey, (lobbyItem) => {

CreateDataで使ってんのな、まあそりゃそうだよな
というかさ、もういいよ、
やっぱりさ、TouchLobbySelectでやろうぜ




ようし作業に戻るか、一体何をどうすればいいんだっけ

 NwCmdMultiLobbySearch cmd = NetworkManager.Instance.GetCmd<NwCmdMultiLobbySearch>();
cmd.GetLobbyList(),
List<NwDataMultiLobbyData> lobby,

      instanceLobbySelect.CreateData(cmd.GetLobbyList(), MultiLobbyStatus.lobbyKey, (lobbyItem) => {


んんなんかそう考えるｍんんｎでもパネルをクリックするまでどの
ロビーＩＤか分からんからなあ


どうしようか迷ったなあ
今俺がはじこうとしているところはMultiLobbySelect画面なんだよなあ・・・
いじろうとしているところはMutiLobbySelectの画面だけど、実際いじるのは、RaceMenuなんだよなあ、たぶん、たぶんそうだよな
もしくはRaceMenuからMultiLobbyにとんで、そこの内でチェックしてもいいっで

この TouchLobbySelectがクリックされたときは、instanceLobbySelectとinstanceLobbyは生成されているはずなんだ、だからそっちでもチェックはできる、いい加減RaceMenu長すぎだから、どこかで分割するのもありだとは思うよ。しかしあまあ、やっぱ面倒くさいな
dakara
  public  MultiLobbySelect multiLobbySelect;
  private MultiLobbySelect instanceLobbySelect;
  public  MultiLobby multiLobby;
  private MultiLobby instanceLobby;


 NwCmdMultiLobbySearch cmd = NetworkManager.Instance.GetCmd<NwCmdMultiLobbySearch>();
List<NwDataMultiLobbyData> lobby = cmd.GetLobbyList(),
で現在のロビーを取得して、
void TouchLobbySelect(MultiLobbySelectItem lobbyItem) {

ん？ちょっとまって、アフォかきさま！
この引数のlobbyItemの中のdataにcondition関係全部はいってんじゃねえかところで今選択しているチームはどうやってみるんだっけ？
なんかUserDataManagerのUseTeamなんたら見るんだよなあ



んんまいったなあ、大体完成かと思ったら
TouchLobbySelectが押される直前に何か通信行ってるわ
つまりMultiLobbySelectItemが押された瞬間にあの関数にいってる
わけではないということだ。だとしたら、その前段階でちゃんとチェックしない
うんInLobbySelectが呼ばれているね・・・

了解しました。引き続きよろしくお願いします。

>>大阪さん
おつかれさまです。マルチのゲストで入った場合の条件レースについてなのですが、実装しテストしてみたところ下記のようなユーザーに不親切な見た目になってしまいました。
選択するルームのパネルに条件を載せるのが一番良いと思うのですが、そのスペースがない状態です。こちら3.0で画像の差し替えなどの対応の予定がありますでしょうか？お手数ですが宜しくお願いします。

なんで二回目以降に限ってラベル表示されんだよ意味わかんねえ春日
理由がわかんねえ意味和漢ねえ理由が和歌ねねえ

とりあえず整理すると、LobbySelectItemを作ってるところは
raceConfirmの50行目付近とMultiConfirmの100行目付近
ここで全てのチームのパネルを作成している
その後にRaceConfirmItem、もｓくはMultiConfirmItemのSetDataの
したのほうで、SetLabelStatusというのが呼ばれる
ここから、親クラスとなるConfirmItemBaseのSetLabelStatusへといき
そのしたのほうでCheckConditionクラスを作成
CheckConditionクラスSetDataを行うことで、
isRannableHorseのデータを作成、それをConditionItemBaseの
isRannabelHorseにコピー

これやべええなあ。。。。。
難しい
チームって前倒しで受け取るわけじゃないだろ？
user_teamのデータって、真ん中に空白があったら何が入ってるんだろ
仮にnullが入ってるとしよう、いや、というかさ、たぶん入ってるだろnullそうじゃないと色々難しいじゃん

なんかなんとなく解決していってるな、後はさ、
マルチの方だけ、nullの4投目5投目に馬が入ってない場合、見た目空白になることだ、これなんでだろうなあ。。。。
そもそもあの描画ってどこでやってんだ


なんてこったバグがみつかってしまたよ
んんんん、でも下の子クラス（EvolutionBaseSelect）で再びfotterをいじるのも

あれところでHelperHorseの情報ってどこで渡してんだ？
不思議なのはラベルの貼り付けには成功しているんだけど。条件判定には失敗しているところだ、条件判定ではHelperHorseは考慮されていない。
というか前はどうだったっけ？
前はコストオーバーの判定にHelperHorseを考慮に入れてたっけ？
ソースを見て判断するしかねえな、前の
そうか２．８．５では一番したの関数はマルチのあれだ
この時点で俺が調べるのはStartRaceだ
まあでも for( int i = 0; i < 5; i++ )で６回ループした後にcostを＋＝してるから、ヘルパーもあるんだろうねえ・・・・・
しかし、っていうことは今までもさ、ん？
まあいいやもう面倒くせえ。。。。

なんだこれ。。。。いつhelperHorseのでーた入手してんだ？
あ、RaceMenuのSetConfirmで代入してますな。。。。
そうかSetConfirmでｺﾝﾌｨﾙﾑ画面作っているときはヘルパーデータ渡しているけど、Checkでは渡してねえんだ・・・・

ええと俺何してたんだっけ。。。。
なんかだいたい終わった気がするんだけど気のせいだっけ
あそうだ、
ほうレース出走前に確認するコストは、ヘルパーを抜いたコストなんだなあ。。。。
まあそれが堅実よな


>こちらについては他のルールと異なってくるので、
>修正をお願い致します。
了解しました。修正していきます。
>こちらはデッキ選択の10択画面で表示されるのでしょうか。
>それとも最終確認画面で表示されるのでしょうか。
10択画面の方になります。


途中馬がいないと、先頭3馬選出で前にずれこむんだな
まいったね、どうも。。。
これはどういう方向で調整すればいいんやろ
ずれないようにするか、もしくは、ずれてもそれにあわせる
うーん、ずれた分にあわせたほうがいいね。。。。


うーんう＾ん
なんかバグが増えてしまったわ
これスクロールなんてどうやって修正するんだよ
サンプルプログラムなんてのぞめそうにねえぞ
自分で解読するしかねえな。。。。

とりあえず怪しいのはoverallList.csの中の
scrollだよな
さらにその
うわー全然わからん
	scrollList.ScrollWheel(50);
でやってみたけどウゴかねえ。。。。。
なんだこれ
どうやってscrollの初期位置ウゴか寸や
なんかやり方悪い気がするな
これじゃ終わるの相当かかるぞ
どうしよう検索してもわからん

だまされたあああ、
説明書通りやっても上手くいかない
horseList.scrollList.ScrollToItem(10, 0);
これで本来は上手くいくと思うんだけどなあ
これで検索してみるか

よっしゃ、いくで、どこのスクリプト動かせばいいんだっけ
Multiのどっかだな、マルチのー、、、、、、

1 Sex,　　　
 2 Cost,　　　
 3 Element,
｛
　条件：ｔype2, value1,2
　シングル問題なし
　マルチ問題なし
｝
 4 Type,　　　
 5 Rare,　　　
 6 Same,　　
{
　条件：特になし
　シングル問題なし　horse_card_idで判定していたのをhorse_card_group_idに変更
　マルチ問題なし　マルチはsameやらないです。。。｝
}
 7 Horse
{
　条件：type2, value6(カネヒキリ)｝
　　　　  type2, value6(カネヒキリ）,564(ヘイロー）,145（オリヴェーフル）
　　　　　type1, value6,145
　シングル問題なし　textの呼び出しが間違い。"InvalidHOrsesHorse"ではなく"InvalidHorsesHorse"だった。
　マルチ問題なし　マルチはsameやらないです。。。
}
 8 Card
　条件：type1, value412(カネヒキリ）,1834(オリフェーヴル）、2258（オリフェーヴル)
　　　　  type2, value412(カネヒキリ）,1834(オリフェーヴル）、2258（オリフェーヴル)
　シングル問題なし　
  マルチ問題なし
｛




HelperListの条件判定は96行目のEjectHorseCheckでやってんだな
そんでNwDataUserHorseの中の、ここでしか使わない関数で判定してる
これは無駄だわ
んん？ヘルパーのエラーウィンドウは何処でだしてたんだっけ？
そもそもTouchHelperの引数２つは何処で渡されているかわからない
ああれかHelperBoard.csの155行目か

ようっしゃ、確認はもうええやろ。。。。。

とりあえず今日のタスクは3つやな
大坂さんに例のあれを聞く、スクロールバー、ページ移動。


>大坂さん
おつかれさまです。先週の進化合成の表示の話しの続きになります。
ある程度実装はすんだのですが、転生進化に必要な馬が一つのみで、それが使用中もしくはお気に入りのときに、アイテム不足と判断するかで表示が少し変わってしまいます。（画像の①と②）
アイテム不足とするとこの前のベース馬選択にも変更が必要になります。どちらにするべきでしょうか？お手数ですがよろしくお願いします。

まいったなあ、、、ｌ、eovolutionPanelのせいで

HorseListManageBaseの118行目
何故か売却画面でpanelTypeがEvolutionになってる、なぜ
イーギーゴア　12２38
sellHorse

おかしいな、俺が進化合成の画面でいじったのはEvolutionBaseSelectとReincarnatonConfirmだけのはずだ
なんでReicarnationNewBaseSelectにも影響が出てるんだ？同一親か？
んｎHorseListManageBaseはいじってないからなあ
他に関係ありそうなものとしては、UserDataManagerとかNwDataUserHorseになっちゃうか。ぎりぎりHorseItemListも関係ありそうな感じがする

なんだこれ、HorseItemListの1284行目
TouchNextPageにshortItemListとかあるぞ、、、
逆になんでTouchPageにはあってCreateにはないんだ

後は今やらなくちゃいけない問題として、RecarnationSelectの表示がおかいし件、前は一切アイテム不足とかの表示なかｔったのに

きた、とりあえず目盛っとこう、所持数限界13５ぐらい、原所持数104ぐらいのときに、ヘイローの転生進化合成馬５体x4ぐらいやった
だけど現所持数が増えてないように見える
つまり今所持数限界を微妙に超えてるか越えてないか微妙なところ

listMaxNumは135ですなあ、
isRemoveはfalseですなあ
問題はhorseDatasがCount104で、でもUnknownなところなんだよなあ

とりあえず流れとしては
HorseLisrManageBaseの107行目
horseList.Create( this.horseDatas, horseSort.GetHorseFilters(), listMaxNum, isRemove );　から
HorseListの1３４行目
のCreateに移る

ちょっと他のプロジェクトで見てみようか
他のプロジェクトでも現所持数104で最大135になっとるな
つまりヘイローのあれ突っ込む前は80前後だったってことか
いやちょっと待てよ、今見たけど、つっこんだはずのﾍｲﾛｰの馬が一切
追加されてなかった
あ、他のプロジェクトでもhorseDataはCount以外
Unknown type 'System.Collections.Generic.CollectionDebuggerView`1, mscorlib.dll'だったわ
なんかLIST情報とかはデバックで表示されないのか
とりあえずあの一体一体の馬の顔はどうやって作成してんだ？
HorseListで作ってることで間違いないよな
ただパッと見たかんじそういうスクリプトないんだよなああ
あるとしたら絶対にInstantiateしてるはずだよな？
あHorseListで一杯Instantiateしてたわあ

まず569行目のCreateListItems　もうここで確定だろ
686行目で「はずす」アイコン作成したいる。まあがしかし、俺には今かんけいないだろう
694牛目
 // 馬が存在しないときは下地だけの空白のスプライトを設定
 HorseCardSprite cardSprite = Instantiate( baseCard ) as HorseCardSprite;
これは少し関係ありそう。


これ１だとどうなるんだ

sex
element
type
horse
card

この５つでvalueをチェックする
しかしよ、まあsexは別として他の要素でvalueがゼロ以下になることあるか？
















MultiConfirmItem
で使ってないErrorMessage

MultiLobbySelectItem
で使われているErrorMessage



CheckConditionAtConfirm()
マルチげすとでもここと折るよ



	//マルチでゲストの時はConfirm画面で制限レース判定しない、この次のロビー選択画面で行う
	if(CheckConditionAtConfirm() == true || MultiLobbyStatus.multiType == MultiType.Guest)
	{
		TouchMultiConfirmSuccess(); 
	}