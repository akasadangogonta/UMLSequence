名前まちがってないよなあ
net.raharu.localnotifyplugin.localNotification"
net.raharu.localnotifyplugin.localNotification"

名前同じなのになんでぬｌｌPTRｋが


MultiLobby.csの
２０７行目に飛んでエラーのコモンウィンドウが表示される
ということはあ



/*
  private bool CheckConditionAtConfirm()
  {
	NwDataUserHorse[] useTeamHorses = null;// = UserDataManager.Instance.GetUseTeamHorses();
	int multiTeam = UserDataManager.multiRaceTeamMax;

	int num = multiTeam;
	useTeamHorses = UserDataManager.Instance.GetUseTeamHorses();
	useTeamHorses = UserDataManager.Instance.CollectFrontSortTeam(useTeamHorses, num);

	
	return CheckConditionCommon(useTeamHorses);
  }

  private bool CheckConditionCommon(NwDataUserHorse[] useTeamHorses)
  {
	if(RaceData.ConditionCategory <= 0)
	{
		return true;
	}
	
	CheckCondition checkClass = new CheckCondition();
	
	checkClass.SetData(RaceData.ConditionCategory,
	                   RaceData.ConditionType,
	                   RaceData.ConditionValue,
	                   useTeamHorses);
	
	bool flag = checkClass.CheckAndCreateErrorWindow(this.transform);
	
	checkClass = null;
	return flag;
  }*/

Height197　と　 276　　かあ。。。
これ自動計算した方がいいな、児童で中央に

197とy軸が-260
276だとy軸が-300
つまりHeightが約+80されると、y軸は-40下げる


つまりだね、まあその前に同じところ通ってるか確認しよう

SetDataは通らないことがあるけど
PlayOnAnimは絶対にと通る、つまりはここで自動計算だ簡単なはずだ



currentSortType

4:3斤の蹄鉄購入画面と３
HorseShoeMain -270>-250
Shopmemu -288 > -260

	#if UNITY_EDITOR
	//#elif UNITY_ANDROID
	AndroidJavaClass m_plugin = new AndroidJavaClass("net.raharu.localnotifyplugin.localNotification");
	//if(m_plugin != null)
	{
		m_plugin.Call("sendNotification", "AndroidPlugin Notification is called", 1L, 1);
	}
	#endif






















com.unity3d.plugin.downloader.UnityAlarmReceiver
まずこのプラグインどこにあるかだよなあ










	ninegates 	

2013/04/26


こんにちは。

自分も以前に同様の疑問を抱き、ちょろっと調べたことがありました。
結局はっきりとした理由は分かりませんでしたが、
stackoverflowにて同じような「多くの人が :remote 付けてるけど必要あんの？」という投稿があったのを見つけました。

http://stackoverflow.com/questions/4311069/should-i-use-android-process-remote-in-my-receiver

ここで回答者のddewaeleさんは、別プロセスにすることで利点と欠点それぞれあるけども、
通常使う分には別プロセスにする必要はないよと回答しており、その回答は多くの賛同を集めていました。
これを見て自分は Receiverには":remote" はよっぽどの理由がなければ特に付けなくていいんだなと思っています。

また、AlarmManagerを説明しているサイトで android:process=":remote" を記述しているところが多いのは、
AlarmManagerを使うSDK付属のサンプルソース（ApiDemos）で上記の記述があったので、
とりあえずそれに則って記述したのだと思います。
よって、説明を書いた人はなぜremoteを記述する必要があるのかは恐らく分かっていないと思われます。

つまるところ、元凶？のAlarmManagerのサンプルソースを書いた人の意図がどうだったのかになるんでしょうが、
一過性の処理だしメインスレッドをブロックしないよう、remoteつけちゃえと軽い気持ちで付けたんだと自分は勝手に思っとります。

以上、多分に間違っている可能性はありますが、一応ご参考までに。

2013年4月24日水曜日 18時08分54秒 UTC+9 Naoya Morikawa:
AndroidManifest.xml に記述する <receiver> 内の android:process にて疑問が湧きましたので投稿させて頂きます。

AlarmManager にセットしたアラームを処理するためには、マニフェスト内に以下の様なタグを記述するかと思います。

<receiver
  android:name=".AlarmReceiver"
  android:process=":remote" />

android:process については、コロンで始まる文字列を設定しておくとアラームの処理を別プロセスにて行うようになると認識しております。

この別プロセスについてなのですが、AlarmManager について説明されているサイトをいくつか拝見したところ、暗黙的に android:process=":remote" を記述されている所が多く見受けられました。しかし、レシーバ内の処理を見ても、特に別プロセスで処理を行わなければならないようなロジックは組まれておりません。

AlarmManager を使用する場合、別プロセスにて行わなければならないような特別な理由が何かあるのでしょうか？

 


Naoya Morikawa 	

2013/04/27


ninegates様

stackoverflowの投稿も含め、大変参考になりました。

アラームが実行される度に別プロセス分のリソースが確保されてしまうのが気がかりだったのですが、
本来の意味で別プロセスにしたい場合のみ記述するということで特に問題はなさそうですね。

サンプルソースにつきましても大変納得致しました。
SDKに付属しているとなると、理由が明確でなくても、とりあえず記述しておこうとしてしまう気持ちも分かる気がします。
（分からない部分については調べて理解しようとする、という人がもっと増えてくれれば、android を取り巻く技術環境も
向上するのではないかと個人的には思っていますが…）

お忙しい中、ご返信頂き誠にありがとうございました。

2013年4月26日金曜日 19時23分56秒 UTC+9 ninegates:
- 引用テキストを表示 -


1466416929868
1466416939868



サーバからRecoveryTime貰ってるのは３点のみだな
GameLogicの
  public void EntryPointConsumption()
  private void EntryPointMultiConsumption()　の二つ
GameControllerの
  private void LoadCollectionData()

apiとしてはそれぞれ

あ違うわ、一番したGameControllerの奴は違う
実際はGlobalConfig.recoveryTimeにapiで情報を受け取っている
そこから更に
  public int    GetRecoveryTime()    { return GlobalConfig.recoveryTime; }
を介して、HeaderManagerで処理をしている。
これは間違いない

GlobalConfigのrecoveryTimeに代入しているのは
NwDataRaceRun  "race_run"
NwDataRaceResult  "race_result"
NwDataMyData  "user_data"　の３つ



#elif UNITY_ANDROID
    GCM.Initialize();
    GCM.SetErrorCallback ((string errorId ) => {} );
    GCM.SetMessageCallback((Dictionary<string, object> table ) => {} );
    GCM.SetRegisteredCallback ((string registrationId) => { GlobalConfig.registrarionId = registrationId; } );
    GCM.SetUnregisteredCallback((string registrationId) => {} );
    GCM.SetDeleteMessagesCallback((int total) => {} );
    
    string registId = GCM.GetRegistrationId();
    if( registId == "" )
    {
      string[] senderId = { GlobalConfig.androidProjectId };
      GCM.Register( senderId );
    }
    else
    {
      GlobalConfig.registrarionId = registId;
    }

ここら辺が怪しいな
とりあえずレシーバーのクラス名を見よう



com.kskkbys.unitygcmplugin.UnityGCMBroadcastReceiver

ほーーーーーーんん
こんなかにUnity起動のコードがあるはずだ



//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by Fernflower decompiler)
//

package com.google.android.gcm;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.util.Log;
import com.google.android.gcm.GCMBaseIntentService;
import com.google.android.gcm.GCMRegistrar;

public class GCMBroadcastReceiver extends BroadcastReceiver {
    private static final String TAG = "GCMBroadcastReceiver";
    private static boolean mReceiverSet = false;

    public GCMBroadcastReceiver() {
    }

    public final void onReceive(Context context, Intent intent) {
        Log.v("GCMBroadcastReceiver", "onReceive: " + intent.getAction());
        String className;
        if(!mReceiverSet) {
            mReceiverSet = true;
            className = this.getClass().getName();
            if(!className.equals(GCMBroadcastReceiver.class.getName())) {
                GCMRegistrar.setRetryReceiverClassName(className);
            }
        }

        className = this.getGCMIntentServiceClassName(context);
        Log.v("GCMBroadcastReceiver", "GCM IntentService class: " + className);
        GCMBaseIntentService.runIntentInService(context, intent, className);
        this.setResult(-1, (String)null, (Bundle)null);
    }

    protected String getGCMIntentServiceClassName(Context context) {
        return getDefaultIntentServiceClassName(context);
    }

    static final String getDefaultIntentServiceClassName(Context context) {
        String className = context.getPackageName() + ".GCMIntentService";
        return className;
    }
}


これがGCMrecieverの中身、パッと見何も変わったことしているように見えないが
やっているとしたらもう
        GCMBaseIntentService.runIntentInService(context, intent, className);
ここしかねえよな
GCMBaseIntentServiceは同じjarファイル内のクラスだから
そこをちょっと見てみると
private static final Object LOCK = GCMBaseIntentService.class;

   static void runIntentInService(Context context, Intent intent, String className)
 {
        Object var3 = LOCK;
        synchronized(LOCK)
　　　 {
            if(sWakeLock == null)
	 {
                PowerManager pm = (PowerManager)context.getSystemService("power");
                sWakeLock = pm.newWakeLock(1, "GCM_LIB");
       　     }
        }

        Log.v("GCMBaseIntentService", "Acquiring wakelock");
        sWakeLock.acquire();
        intent.setClassName(context, className);
        context.startService(intent);
    }
これかああ

やっぱこのcontext.startServiceが怪しいよな



package com.google.android.gcm;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.util.Log;
import com.google.android.gcm.GCMBaseIntentService;
import com.google.android.gcm.GCMRegistrar;

public class GCMBroadcastReceiver extends BroadcastReceiver {
    private static final String TAG = "GCMBroadcastReceiver";
    private static boolean mReceiverSet = false;

    public GCMBroadcastReceiver() {
    }

    public final void onReceive(Context context, Intent intent) {
        Log.v("GCMBroadcastReceiver", "onReceive: " + intent.getAction());
        String className;
        if(!mReceiverSet) {
            mReceiverSet = true;
            className = this.getClass().getName();
            if(!className.equals(GCMBroadcastReceiver.class.getName())) {
                GCMRegistrar.setRetryReceiverClassName(className);
            }
        }

        className = this.getGCMIntentServiceClassName(context);
        Log.v("GCMBroadcastReceiver", "GCM IntentService class: " + className);
        GCMBaseIntentService.runIntentInService(context, intent, className);
        this.setResult(-1, (String)null, (Bundle)null);
    }

    protected String getGCMIntentServiceClassName(Context context) {
        return getDefaultIntentServiceClassName(context);
    }

    static final String getDefaultIntentServiceClassName(Context context) {
        String className = context.getPackageName() + ".GCMIntentService";
        return className;
    }
}



ちょっとOnRecieveの中身くらべてみよか
こっちがGcm
    public final void onReceive(Context context, Intent intent) {
        Log.v("GCMBroadcastReceiver", "onReceive: " + intent.getAction());
        String className;
        if(!mReceiverSet) {
            mReceiverSet = true;
            className = this.getClass().getName();
            if(!className.equals(GCMBroadcastReceiver.class.getName())) {
                GCMRegistrar.setRetryReceiverClassName(className);
            }
        }

        className = this.getGCMIntentServiceClassName(context);
        Log.v("GCMBroadcastReceiver", "GCM IntentService class: " + className);
        GCMBaseIntentService.runIntentInService(context, intent, className);
        this.setResult(-1, (String)null, (Bundle)null);
    }

こっちがnotification
    public void onReceive(Context context, Intent intent) {

        //値の取得
        String title = intent.getStringExtra("Title");
        String detail = intent.getStringExtra("Detail");
        Integer id = intent.getIntExtra("ID", 0);

        Log.i("Unity", "ReceiveNotification:" + String.valueOf(id));

        // intentからPendingIntentを作成
        PendingIntent pendingIntent = PendingIntent.getActivity(context, 0, intent, PendingIntent.FLAG_CANCEL_CURRENT);

        // LargeIcon の Bitmap を生成
        final PackageManager pm = context.getPackageManager();
        ApplicationInfo applicationInfo = null;
        try {
            applicationInfo = pm.getApplicationInfo(context.getPackageName(), PackageManager.GET_META_DATA);
        } catch (PackageManager.NameNotFoundException e) {
            e.printStackTrace();
            return;
        }
        final int appIconResId = applicationInfo.icon;
        Bitmap largeIcon = BitmapFactory.decodeResource(context.getResources(), appIconResId);

        // NotificationBuilderを作成
        NotificationCompat.Builder builder = new NotificationCompat.Builder(context);
        builder.setContentIntent(pendingIntent);
        builder.setTicker(title);  //ステータスバーに届くテキスト
        builder.setSmallIcon(appIconResId);           //アイコン
        builder.setContentTitle(title);       // タイトル
        builder.setContentText(detail);              // 本文（サブタイトル）
       // builder.setLargeIcon(largeIcon);              //開いた時のアイコン
        builder.setWhen(System.currentTimeMillis());  //通知に表示される時間(※通知時間ではない！)

        // 通知時の音・バイブ・ライト
        builder.setDefaults(Notification.DEFAULT_ALL);
        builder.setAutoCancel(true);

        // NotificationManagerを取得
        NotificationManager manager = (NotificationManager) context.getSystemService(Service.NOTIFICATION_SERVICE);
        // Notificationを作成して通知

        manager.notify(id, builder.build());
    }




".GCMIntentService";




public class MyReceiver extends BroadcastReceiver {  
    @Override  
    public void onReceive(Context context, Intent intent) {  
        Intent i = new Intent(context, Main.class); 
        i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        context.startActivity(i);
    }   
}

ReceiverをManifestで定義する
BOOT_COMPLETEDを受けるためのフィルターと、パーミッションが必要です。
       <receiver android:name=".MyReceiver" android:permission="android.permission.RECEIVE_BOOT_COMPLETED">
           <intent-filter>
               <action android:name="android.intent.action.BOOT_COMPLETED"/>
                <category android:name="android.intent.category.DEFAULT" />  
           </intent-filter>  
       </receiver>












      <receiver android:name="com.kskkbys.unitygcmplugin.UnityGCMBroadcastReceiver" android:permission="com.google.android.c2dm.permission.SEND" > 
          <intent-filter> 
              <action android:name="com.google.android.c2dm.intent.RECEIVE" /> 
              <action android:name="com.google.android.c2dm.intent.REGISTRATION" /> 
              <category android:name="jp.co.landho.puzzlederby" /> 
          </intent-filter>  
      </receiver> 
      <service android:name="com.kskkbys.unitygcmplugin.UnityGCMIntentService" /> 


intent指定するならもうUnity関係ないってよ。。。。
どういうことだってばよ

jp.co.landho.puzzlederby

com.unity3d.player.UnityPlayerActivity


-23 16:48:50.913  29533-29533/? I/Unity﹕ Context.PackageName = jp.co.landho.puzzlederby
06-23 16:48:50.913  29533-29533/? I/Unity﹕ Intent.Package = null
06-23 16:48:50.913  29533-29533/? I/Unity﹕ Intent.ClassName = android.content.Intent





public class IntentActivity extends Activity implements OnClickListener{
    /** Called when the activity is first created. */
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
 
        //buttonを取得
        Button btn = (Button)findViewById(R.id.Button01);
        btn.setOnClickListener(this);
    }
 
    //インターフェイスを実装 implements OnClickListener
    public void onClick(View v) {
        Intent intent=new Intent();
        intent.setClassName("org.jpn.techbooster.demo.intent","org.jpn.techbooster.demo.intent.SubActivity");
        intent.putExtra("org.jpn.techbooster.demo.intent.testString", "!TEST STRING!");
 
        startActivity(intent);
    }
}


<application android:icon="@drawable/icon" android:label="@string/app_name">
    <activity android:name=".IntentActivity" android:label="@string/app_name">
 
        <intent-filter>
            <action android:name="android.intent.action.MAIN" />
            <category android:name="android.intent.category.LAUNCHER" />
        </intent-filter>
    </activity>
    <activity android:name=".SubActivity"></activity>
</application>


public class SubActivity extends Activity {
    /** Called when the activity is first created. */
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.sub);
 
        Intent intent = getIntent();
        if(intent != null){
            String str = intent.getStringExtra("org.jpn.techbooster.demo.intent.testString");
            Toast.makeText(this, str, Toast.LENGTH_LONG).show();
        }
    }
}

task adbConnect(type: Exec) {
commandLine 'adb', 'connect', '192.168.200.92'
}


adb install -r Untitled.apk
pause











java.lang.Error: FATAL EXCEPTION [main]
    Unity version     : 4.7.2f1
    Device model      : SHARP SH-01G
    Device fingerprint: DOCOMO/SH-01G/SH-01G:4.4.4/SB080/01.00.03:user/release-keys
    Caused by: java.lang.RuntimeException: Unable to start receiver net.raharu.localnotifyplugin.NotificationReceiver: java.lang.NullPointerException
            at android.app.ActivityThread.handleReceiver(ActivityThread.java:2615)
            at android.app.ActivityThread.access$1900(ActivityThread.java:157)
            at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1366)
            at android.os.Handler.dispatchMessage(Handler.java:102)
            at android.os.Looper.loop(Looper.java:136)
            at android.app.ActivityThread.main(ActivityThread.java:5232)
            at java.lang.reflect.Method.invokeNative(Native Method)
            at java.lang.reflect.Method.invoke(Method.java:515)
            at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:805)
            at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:621)
            at dalvik.system.NativeStart.main(Native Method)
     Caused by: java.lang.NullPointerException
            at net.raharu.localnotifyplugin.NotificationReceiver.onReceive(NotificationReceiver.java:38)
            at android.app.ActivityThread.handleReceiver(ActivityThread.java:2581)
            at android.app.ActivityThread.access$1900(ActivityThread.java:157)
            at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1366)
            at android.os.Handler.dispatchMessage(Handler.java:102)
            at android.os.Looper.loop(Looper.java:136)
            at android.app.ActivityThread.main(ActivityThread.java:5232)
            at java.lang.reflect.Method.invokeNative(Native Method)
            at java.lang.reflect.Method.invoke(Method.java:515)
            at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:805)
            at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:621)
            at dalvik.system.NativeStart.main(Native Method)






defaultSoundName	デフォルトのサウンド名を取得（読み込み専用）。
変数

alertAction	アクションボタンやスライダーのタイトル。
alertBody	アラートが通知されたときに表示するメッセージ。
alertLaunchImage	ユーザーがアクションボタンをタップするとき、アプリ起動時の画
applicationIconBadgeNumber	アプリアイコンのバッチとして表示される数。
fireDate	通知をする時間。
hasAction	アラートアクションが表示されているかの確認。
repeatCalendar	アラートが表示されたときに再生されるサウンドを含むファイル名
repeatInterval	カレンダーを更新する間隔。
soundName	アラートが表示されたときに再生するサウンド名。
timeZone	タイムゾーン。
userInfo	カスタム情報を dictionary クラスで作成し、設定する。
コンストラクタ

LocalNotification	新規のローカル通知を作成します


releaseのパッケージ名やで。。。。
jp.co.netdreamers.puzzlederby



 void Start () {
 
     // Unity Local Notifications are only support on iOS
     if (Application.platform == RuntimePlatform.IPhonePlayer) {
         NotificationServices.RegisterForLocalNotificationTypes (LocalNotificationType.Alert | LocalNotificationType.Badge | LocalNotificationType.Sound);
 
         // Test notification
         LocalNotification notification = new LocalNotification ();
         notification.alertBody = "Hello World";
         notification.alertAction = "Alert Action";
         notification.hasAction = true;
         notification.applicationIconBadgeNumber = -1;
         notification.fireDate = DateTime.Now.AddSeconds (10);
         Dictionary<string,string> customData = new Dictionary<string, string> ();
         customData.Add ("gem_bonus", "2");
         customData.Add ("coin_bonus", "3");
         notification.userInfo = customData;
         NotificationServices.ScheduleLocalNotification (notification);
 
         StartCoroutine (ReceiveLocalNotifications ());
     } 


>>村井さん
おはようございます。
プッシュ通知の件で今更なのですが、iOSの方では現在
サーバから通知というのは行っていますでしょうか？
サーバ側と文言やバイブなど仕様を統一したいと思っていたのですが、
私の端末の方で何故か確認できませんでした。

お手数ですがよろしくお願いします。




public class localNotification/* extends IntentService*/
{
    public Activity activity;

    private static int lastNotificatinId = -1;

    /*
    protected localNotification() {
        this("DynamicSenderIds", (String[]) null);
    }

    private localNotification(String name, String[] senderIds)
    {
        super(name);
    }
    public final void onHandleIntent(Intent intent)
    {
        Log.i("Unity", "onHandleIntent called");
    }*









cationAtRecovery() GameController:OnApplicationPause(Boolean)   (Filename: /Users/builduser/buildslave/unity/build/artifacts/iPhonePlayer-armv7-il2cppGenerated/UnityEngineDebug.cpp Line: 56)  Unity try to set LocalNotification UnityEngine.Debug:Internal_Log(Int32, String, Object) UnityEngine.Debug:Log(Object) LocalNotifyManager:SetLocalNotification(String, String, Int32) LocalNotifyManager:SetLocalNotificationAtRecovery() GameController:OnApplicationPause(Boolean)   (Filename: /Users/builduser/buildslave/unity/build/artifacts/iPhonePlayer-armv7-il2cppGenerated/UnityEngineDebug.cpp Line: 56)  Access LocalNotification in IPHONE UnityEngine.Debug:Internal_Log(Int32, String, Object) UnityEngine.Debug:Log(Object) LocalNotifyManager:SetLocalNotification(String, String, Int32) LocalNotifyManager:SetLocalNotificationAtRecovery() GameController:OnApplicationPause(Boolean)   (Filename: /Users/builduser/buildslave/unity/build/artifacts/iPhonePlayer-armv7-il2cppGenerated/UnityEngineDebug.cpp Line: 56)  -> applicationDidEnterBackground() -> applicationWillEnterForeground() -> applicationDidBecomeActive() Now RecoveryTime: GetRecovetyTime = 360 UnityEngine.Debug:Internal_Log(Int32, String, Object) UnityEngine.Debug:Log(Object) GameController:OnApplicationPause(Boolean)   (Filename: /Users/builduser/buildslave/unity/build/artifacts/iPhonePlayer-armv7-il2cppGenerated/UnityEngineDebug.cpp Line: 56)  Now RecoveryTime: GetIntervalTime = 447 UnityEngine.Debug:Internal_Log(Int32, String, Object) UnityEngine.Debug:Log(Object) GameController:OnApplicationPause(Boolean)   (Filename: /Users/builduser/buildslave/unity/build/artifacts/iPhonePlayer-armv7-il2cppGenerated/UnityEngineDebug.cpp Line: 56)  Now RecoveryTime: Result = -87 UnityEngine.Debug:Internal_Log(Int32, String, Object) UnityEngine.Debug:Log(Object) GameController:OnApplicationPause(Boolean)   (Filename: /Users/builduser/buildslave/unity/build/ar




UnityEngine.Debug:Log(Object) LocalNotifyManager:SetLocalNotifitifacts/
iPhonePlayer-armv7-il2cppGenerated
/UnityEngineDebug.cpp Line: 56)  PlaySe=ButtonTap UnityEngine.Debug:Internal_Log(Int32, String, Object) UnityEngine.Debug:Log(Object) SoundManager:PlaySe(SeType, Boolean) <SetCallbackWithSound>c__AnonStorey16A:<>m__8(IUIObject) EZValueChangedDelegate:Invoke(IUIObject) UIButton:OnInput(POINTER_INFO&) AutoSpriteControlBase:OnInput(POINTER_INFO) UIManager:DispatchHelper(POINTER_INFO&, Int32) UIManager:DispatchInput() UIManager:Update()   (Filename: /Users/builduser/buildslave/unity/build/artifacts/iPhonePlayer-armv7-il2cppGenerated/UnityEngineDebug.cpp Line: 56)  -> applicationWillResignActive() Now RecoveryTime: GetRecovetyTime = 360 UnityEngine.Debug:Internal_Log(Int32, String, Object) UnityEngine.Debug:Log(Object) GameController:OnApplicationPause(Boolean)   (Filename: /Users/builduser/buildslave/unity/build/artifacts/iPhonePlayer-armv7-il2cppGenerated/UnityEngineDebug.cpp Line: 56)  Now RecoveryTime: GetIntervalTime = 485 UnityEngine.Debug:Internal_Log(Int32, String, Object) UnityEngine.Debug:Log(Object) GameController:OnApplicationPause(Boolean)   (Filename: /Users/builduser/buildslave/unity/build/artifacts/iPhonePlayer-armv7-il2cppGenerated/UnityEngineDebug.cpp Line: 56)  Now RecoveryTime: Result = -125 UnityEngine.Debug:Internal_Log(Int32, String, Object) UnityEngine.Debug:Log(Object) GameController:OnApplicationPause(Boolean)   (Filename: /Users/builduser/buildslave/unity/build/artifacts/iPhonePlayer-armv7-il2cppGenerated/UnityEngineDebug.cpp Line: 56)  SetLocalNotification:RecoveryTime == 0 UnityEngine.Debug:Internal_Log(Int32, String, Object) UnityEngine.Debug:Log(Object) LocalNotifyManager:SetLocalNotificationAtRecovery() GameController:OnApplicationPause(Boolean)   (Filename: /Users/builduser/buildslave/unity/build/artifacts/iPhonePlayer-armv7-il2cppGenerated/UnityEngineDebug.cpp Line: 56)  -> applicationDidEnterBackground(


たぶん、現在の出走ポイントがEntryPoint
回復までの時間がRecoveryPoint


HeaderManagerのUpdateRecoveryPointの呼び出し数
59, 247, 273, 423, 451

HeaderManagerのGetEntryPoint
73, 188, 253, 335, 341

HeaderManagerでUserDataのUpdataEntryPointが呼ばれているのは2点
247、273

UpdateEntryPoint()の最後の行
なので途中で    if(( recoveryRestTime <= 0 ) || (entryPoint >= maxEntryPoint))　があれば
returnして遂行されない

recoveryRestTime = 回復までの全時間
最大値以上ってことは、recoveryRestTimeは０か０以下だなあ
とするとまあ基本減っていくのみなんだよな、