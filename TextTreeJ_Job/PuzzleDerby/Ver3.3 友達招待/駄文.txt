MultiComment.cs　か

MultiCommentItem


しかし    base.SetIntParam("room_comment", commentId); //2014.11.18を与えて
まともな条件にあたるんですかね、でも、うーん


これ変わってんな
NwCmdMultiLobbyCreateで取得するdataがNwDataMultiLobbyIdなんだ
しかもこのNwDataMultiLobbyIdに格納されてるのint型一戸だけ

しかし不思議だよな
どんな順番に変えても正常なLobbyIdが返ってくる？
いやどうなんだろ・・・・・






  void TouchMultiConfirmSuccess() {
    Debug.Log("TouchMultiConfirm");
    MultiLobbyStatus.lobbyKey = instanceMultiConfirm.LobbyKey;
    switch(MultiLobbyStatus.multiType) {
    case MultiType.Host:
//      MultiLobbyStatus.hostFormation = SaveData.GetFormation(UserDataManager.Instance.GetUseTeamId() - 1);
//      InLobbyConnect();
      InLobbyComment(); //2014.11.18 ロビーにコメントをつけるため、それを選択させる
      break;
    case MultiType.Guest:
      InLobbySelect();
      break;
    default:
      LHDebug.Log("error ReceMenu:TouchMultiConfirm() : multiType==" + MultiLobbyStatus.multiType);
      break;
    }



  void InLobbyComment() {
    Debug.Log("InLobbyComment");
    MenuBase.CreateMenu<MultiComment>(ref instanceMultiComment, multiComment, this.transform);
    instanceMultiComment.SetCallback(() => {
      curCommentId = instanceMultiComment.GetCurrentCommentId();
      Debug.Log("Comment="+curCommentId);
      if ( curCommentId == (int)RoomCommentID.Password )
      {
        // パスワード設定に遷移.
        OpenPasswordWindow( MultiType.Host, (text) => {
          MultiLobbyStatus.lobbyKey = text;
          InLobbyConnect();
        } );
      }
      else
      {
        InLobbyConnect();
      }
    });
    StartCoroutine(ChangePhase(RaceMenuPhase.MultiComment));
  }


  void InLobbyConnect() {
//   LoadingManager.Instance.Play( true );
   
    Debug.Log("InLobbyConnect");
    RaceVersionCheck(() => {
      NwCmdMultiLobbyCreate cmd = NetworkManager.Instance.GetCmd<NwCmdMultiLobbyCreate>();
      cmd.SetCallBack(() => {
        MultiLobbyStatus.lobbyId = cmd.GetLobbyId();
#if !OLD_MULTI
        CreateRoom();
#else
        InLobby(TouchLobbyCancel_Host);
#endif
      },
     (err) => {
        if(err == NetworkError.Inconsistent) {
          AssertManager.Instance.SetInconsistentError(cmd, cmd.GetError().ToString());
        } else {
          AssertManager.Instance.SetConnectFailed(cmd);
        }
      });
      cmd.ExecCmd(curRaceId, curStageId, curCommentId+1); // コメントは (0～n -> 1～n+1)
    });
  }


うーん、RaceMenuのInLobbyCommentの中のSertCallbackで
MultiCommentクラスにcallbackを渡している
このcallbackはdecideボタンを押したときに発動する

んでこの渡しているcallbackの実態は
ああデリゲートで渡してるわ
 instanceMultiComment.SetCallback(() => {
      curCommentId = instanceMultiComment.GetCurrentCommentId();
      Debug.Log("Comment="+curCommentId);
      if ( curCommentId == (int)RoomCommentID.Password )
      {
        // パスワード設定に遷移.
        OpenPasswordWindow( MultiType.Host, (text) => {
          MultiLobbyStatus.lobbyKey = text;
          InLobbyConnect();
        } );
      }
      else
      {
        InLobbyConnect();
      }
    });
んんんんんんんんんんんんんんん

まあ結局inLobbyConnectに飛ぶだけですな
とするとこのcallbackの実態はRaceMenu.InLobbyConnectと言うことができる

んんんんｎどうもなあ
どうやってMultiCommentからMultiLobbyに移動するかわからない
InLobbyConnectはLobbyIdを取得してるだけやで
ディサイドボタン押してもID取得するだけでMultiLobbyに繊維するコードがない

そういうときはMultiLobbyのinから逆にたどってみるんだぜ
inは無理だったからCreateDataからだな
CreateDataの一つ前はRaceMenu.InLobby
その一つ前はRaceMenuMulti.OnJoinedRoom
うわあ、ここの遷移きついわ、SendMasseageだ

SendMonoMessage(PhotonNetworkingMessage.OnJoinedRoom); //Always send OnJoinedRoom
NetworkingPeer.SendMonoMessage(PhotonNetworkingMessage.OnJoinedRoom);

PhotonNetwork.ConnectUsingSettings( GlobalConfig.PhotonVersion );

つまりこれか、このPhotonNetworkを使って間接的にPHASEの移行をしているのか面倒くせえ
しかしそれにしたってなあ

MultiLobbySelectItemか
例えばほすとがフレンド限定を選ぶと？
ん？これじょうけんに関係ねえや。。。。


public class NwDataMultiLobbyData 
{
  public int lobby_id;
  public string race_id;
  public string race_name;
  public string stage_name;
  public string difficulty;
  public string nickname;
  public int rank;
  public int distance;
  public int condition_category;
  public int condition_type;
  public int[] condition_value;
  public int host_formation;
  public bool is_geo_campaign_incentive;
  public string sub_title;
  public int[]  condition_values_array;
  public int room_comment; // 2014.11.18 コメント"誰でも気軽に!"などの指定
  public bool is_friend_lobby; // 2015.2.2 友達がホストか
  public bool is_neighbor_multi;
  public int lobby_key;
  // 限定ルール追加
  public int	special_terms_id = 0;				// 限定ルール(0:通常,1:コンテニュー不可,2:時間制限,3:ターン制限)
  public int	special_terms_value = 0;		// id=2:制限時間(秒), id=3:ターン数

  public int    unuse_block;
// public int use_entry_point;
 
  public NwDataUserHorse leader;
}


この中に秘密があるんでは・・・・・？

はいはいわかたよ
NwCmdMultiLobbyCreateでcommentを送って
ゲスト側は
NwDataMultiLobbyDataのcommentを受け取って
そのロビーのゲスト条件を知るわけだ

ううんそうか、intで送ってるわけか
つまりサーバと歩調を合わせないとうまく条件判定が機能しないわけか




  None = -1,        // 非表示.
  AnyOne,           // 誰でも.
  LeaderMoreThan4,  // リーダー☆4以上.
  LeaderMoreThan5,  // リーダー☆5以上.
  LeaderMoreThan6,  // リーダー☆6以上.
  LeaderMoreThan7,  // リーダー☆7以上.
　FriendOnly,       // フレンド限定.
  Password,         // パスワードあり.
  
から

  None = -1,        // 非表示.
  AnyOne,           // 誰でも.
  Password,         // パスワードあり.
  InviteLine,       // Line招待プレイ.
  FriendOnly,       // フレンド限定.
  LeaderMoreThan4,  // リーダー☆4以上.
  LeaderMoreThan5,  // リーダー☆5以上.
  LeaderMoreThan6,  // リーダー☆6以上.
  LeaderMoreThan7,  // リーダー☆7以上.


URLに埋め込む？どうやって？
あとこれ新しいボタン必要だよね

            <intent-filter>
                <action android:name="android.intent.action.VIEW" />
                <category android:name="android.intent.category.DEFAULT" />
                <category android:name="android.intent.category.BROWSABLE" />
                <category android:name="jp.co.landho.puzzlederby" /> 
                <data android:scheme="derby" />

androidのjarからderby:を指定するとアプリが起動される
このURLに、ん？なんでルームURLて、招待URLて
URLを押すとゲームが起動？　たぶん
スキーマURLってまともなhttp的なURLじゃねえよな
たぶん本当にderby:だけだと思うけど、これにパスワードを入れ込む？？？？？


iOSカスタムURLスキーム一覧

 アプリ名	 カスタムURLスキーム
 メール	 mailto:
 電話	 tel:xxx-xxxx-xxxx
 iTunes	 http://itunes.apple.com/jp/genre
 iBooks	 itms-bookss:
 Maps	 maps:
 リマインダー	 x-apple-reminder://
 Twitter	 twitter:
 Evernote	 evernote:root

んんんんんんんんんんんんんんんんんん

URLスキームに埋め込む？？？？？？


単純にderby:以外にも同時に情報を渡せるのかな

スキームでアプリを起動させることはできても
起動後の動作の制御までできるものなのか

たとえば

1
myapp://myapp.jp/comment/view/801
というURLでアプリが起動された場合,

1
comment/view/801
が欲しいですよね.

これらの { comment, view, 801 } を List で抜く方法をメモします. (よく使うと思うので自分用メモ)


へえええええ
つまり　derby:までがカスタムスキーマで
そのあとはは例えばderby:multi/room/108433
とかどうとでもできるわけだ
どっちにしろアプリは起動すると

やべえなわかんねえ


ここでは起動時のURLスキーム名をキーにしてSharedPreferencesにintのフラグを保存し、
Unityで使用している開始時のアクティビティUnityPlayerProxyActivityへ遷移するようにしています。


GetAppLaunchUrl

>>村井さん
お疲れ様です。急ぎではないですがVer3.3のマルチ招待ユーザー限定に関しての相談になります。

メンバー受付中の右に設置する「招待」のボタンの画像素材なのですが、
こちらもネットドリーマーズさんの方で用意していただけるという認識で大丈夫でしょうか？

お手数ですがよろしくお願いします。



>>村井さん
たびたび失礼いたします。
現在ドライブに上がっているver3.3の素材のicon_friendですが、
画像の縦横のサイズを他のショップ画面のアイコンに合わせて84x84にしてもらうことは可能でしょうか？
スクリプトの方では個別にサイズ調整をしていないので現在の素材ですと縦に引きのばれてしまう状況です。

お手数ですがよろしくお願いします。



まだ途中段階


>>村井さん
了解しました、急ぎではないので大丈夫です。よろしくお願いします。



EvolutionListManageBaseではIn()でせっとしてるね
  public override void In ()
  {
    switch( panelType )
    {
    case PanelType.NumPanel    : FooterManager.Instance.ShowNumPanel(); break;
    case PanelType.SelectPanel : FooterManager.Instance.ShowSelectPanel(); break;
    }

	base.SetOutCallback( itemList.ClearBottomArrow );
    TitleBoardManager.Instance.InBoard( TitleBoardType.Sort, LeiListSort.GetSortName(), this.PushSortBtn );
//    TitleBoardManager.Instance.InBoard( TitleBoardType.WithBackBtn );
    CommonScrollBar.Instance.SetData( itemList.scrollList );
    base.In ();
  }
  


    TitleBoardManager.Instance.InBoard( TitleBoardType.Sort, LeiListSort.GetSortName(), this.PushSortBtn );


  public void InBoard( TitleBoardType type, string subName = "", DefaultCallback extraCallback = null, 
　　　　　　　　　　　　　　DefaultCallback extraSubCallback = null )
  {
    this.TitleBoardType = type;
    this.subName.Text   = subName;
    this.extraCallback  = extraCallback;
    this.extraSubCallback  = extraSubCallback;
    this.SetType();
    if( IsBoardOut )
    {
      IsBoardOut = false;
      titleBoard.GetComponent<Animation>().Stop();
      titleBoard.GetComponent<Animation>().Play( "BoardInAnim" );
    }
  }



なんでちゃんと消してるのに毎回特定の箇所でﾎﾞﾀﾝが表示されるんだ

ホームが画面ではちゃんと消えてる
そのあとの遷移で必ず出現する。；




commentはどこで保存してるんやろか

マルチロビーでTitleBoardType.InviteMultiRaceをセットすりゃいいんだな
    TitleBoardManager.Instance.InBoard( TitleBoardType.Sort, LeiListSort.GetSortName(), this.PushSortBtn );


問題はLineMainをそのまま引用するかどうかだよな
そのまま使った場合何がどうなるんだ
まず無難にLineMainにはスクリプトが３ついてて
LineMainとFacebookControler, TwitterContorlerの３つ
LineMainの名甘味もFacebokkやﾒｰﾙを使ったやりとりがいっぱいあるんで



LinMain.TouchLine

ん？これFacebokkControllerもTwitterControllerも両方使ってないんじゃ


ぬむたい、頭が働かない腹立つ

まじで間に合わねえぞ気合いいれねえと
まず現状のLineMainと、現在実装したSNSサポートの違いは何なんだ
まず文言は100%違うでしょ、これは確定

あと何が違うの？なんかすきー仕込むんだ宇アdな

これは意志力の弱さじゃねえの、脳に心が負けtるよな

集中力が10分しかもたなくあなった、あとは全部眠たい
10分どころじゃねえな５分だ


サーバから送られてくる友達招待の文言
オルフェーヴル、ディープインパクト歴代レジェンドに挑め！
【パズルダービー】
[ゲームDL]
http://derby.pzga.jp/official/
招待ID : 9154-7533-3618
8/23/2016 11:34:56 AM

ちなみにこの文言が格納されているの  wCmdBasicInfoの .sns_post_text.Replaceやで
同時にNwDaBasicinfoの新作


こんかい実装する内容はこちら

パズダビのマルチで一緒に遊ぼう!
・「シナリオ名」+「レース名」
　+「レースサブタイトル」
・招待URL(ルームURL)
上記URLをタップすると一に遊べるよ!

まだプレイしていいない人は
こちらからインストールしてね!
・攻略URL(http://derby.pzga.jp/official)
・招待ID

[パズルダービー]


オルフェーヴル、ディープインパクト歴代レジェンドに挑め！
【パズルダービー】
[ゲームDL]
http://derby.pzga.jp/official/
招待ID : 9154-7533-3618

メール：
タイトルは文字化けしてなぜかみえなかった
あれでも作成されたメール見ると[パズルダービー]になってるな
本文は上記とっしょ
twitter:
これもタイトルはわからず
本文上記一緒
LINE


>>坂本さん
お疲れ様です、マルチの招待レースに関する相談になります。

SNSで送る文言
友達招待で


GetAppLaunchUrl


了解いたしました、よろしくお願いします。

  void InLobbyComment() ＞　  void InLobbyConnect() {　＞　  void InLobby(DefaultCallback cancelCallback)



  void TouchMultiSelect(RaceMultiSelectItem selectItem)　＞
  void TouchMultiSelectMain( ) {　＞
  void TouchMultiConfirm()　＞
  void TouchMultiConfirmSuccess() {　＞
  void InLobbyComment() {



>>村井さん
お疲れ様です、マルチ招待レースのゲストに送る文言なのですが
twitterの文字制限の140文字というのが意外に余裕がなく、
twitterのみ、もしくは一括して文言を修正する必要があるかもしれません。

下記がテスト用に作成された文言になります。




パズダビのマルチで一緒に遊ぼう!
・砂のスピード自慢 かしわ記念 曜日限定(木曜)
・招待URL(アプリ起動)
上記URLをタップすると一緒に遊べるよ!

まだプレイしていいない人は
こちらからインストールしてね!
・攻略URL(http://derby.pzga.jp/official)
・招待ID 4939-7859-8579





180文字はいってる

>>坂本さん、村井さん
了解いたしました。URLだけ受け取ると勘違いしておりました。
お時間おかけして申し訳ないです、お手数ですが引き続きよろしくお願いいたします。


パズダビのマルチで一緒に遊ぼう！
・「シナリオ名(難易度)」
・URL
上記URLをタップすると一緒に遊べるよ！

まだのプレイしていない人は
http://derby.pzga.jp/official


タイトル画面をタップするまで何もapi動かさねえのか
まずお知らせ元年前



了解いたしました、3周年記念の方がもちろん大事なので問題ないです。
よろしくお願いします。


もしかしてﾌﾟﾚｲﾔーデータがない場合、もしくはアップデートがある場合は
自動でタイトル画面スキップやってくれないのか？
どういう条件のときにタイトル画面で止まるのかわからない
とりあえずそれは置いといて、お知らせボードまでに読み込むapi全部記録していくぞ
とそれはおいといて、もしタイトル画面で止まった場合、APIは一切読み込んでないよその時点では


api
appli_start
appli_login
user_data
horse_card_history

4つだけ、じゃあタイトル画面で止まる
実機で確認しても条件わかんねえからもうスクリプトみるしかねえ
脳みそが難しいことがえると拒否反応を起こす

まず俺は何がしたいんだよ
全然思い出せない。そうだどうせなら豆板醤と辛みそｔｐ
いや違う違う、TitleMenuののタップ条件だ。。。。
37分勝手に眠る
39:31秒
40:39秒
42:09　ちょいね
42:56秒ｎ
43:18秒
44:14
45・5449s
　<C:\Users\cyclone-staff\Desktop\Unity4.7.2.lnk>

かk難が得ただけ意識が飛ぶ


なんかTitleOpening複雑な階層構造しとるな
TitleOpeningの子にSkipOpeningってオブジュエクトがある
このSkipOpeningをTitleOpening/LaterObject/locoが持ってたりする。

なんでこんな簡単なことができないんだアニメーションを飛ばすことができない

アニメーションはTitleLogiｃからアクセスすることができない
もう面倒くせえまじでなんなんだよ

ああああああすげええわずらわしい

というか本来このappliStartの前に始まってほしいんだよ

OpeningSKipのCHeckAccountからTitleLogicのCheckAccountに飛ぶんだだけど
このOpeningSkipのCheckAccountga
どっかた飛んできたかわからない。


Multiでしたの「レースに参加」ボタンを押したときの遷移
RaceMenu.  void TouchMultiSelect(RaceMultiSelectItem selectItem)
そのあと　    isMulti = (selectItem.buttonType != MultiSelectButtonType.Single);を通って
TouchMultiSelectMainを実行しているね

だけどタイトルからｼジャンプしようとすると
MainMenuLogic.ChangeMainMe() => RaceMenu.In() => RaceMenu.InMultiSelect
Inから入っても絶対にTouchMultiSelectには入らないのか


じゃあ自分でつくるしかないじゃん。


でかいマルチボタンを押す　＞　  void TouchMultiSelect(RaceMultiSelectItem selectItem)

あれ、メンバーを募集とレースに参加はHorseSelect画面か


でレースに参加をおすとうわマジか、汎用か
ここでもTouchMultiSelectが使われるのかなるほど

TouchMultiSelectMainの中に４つに分岐するのか

    switch(selectItem.buttonType) {
    case MultiSelectButtonType.Single:
    case MultiSelectButtonType.Multi:
    case MultiSelectButtonType.Host:
    case MultiSelectButtonType.Guest:


public class RaceMultiSelectItem : MonoBehaviour {
  private MultiSelectItemTouchCallback itemTouchCallback = null;
  public MultiSelectButtonType buttonType;



やっぱり遷移がかっこわウイ、もっと一般的に遷移してほしい。


DurectEbterNhktuCibfurn > Play
TouchMultiSelectMain > Pause
DeirectEditorMultiWindow > FriendListAPi > Pause
TouchMultiSeectMain > Pause

どういうわけかアウトが呼ばれていない
いや呼ばれているんだけd、
フッター使ったときだけ正常に呼ばれない






正常な遷移
General\FooterManager.cs:84
Scripts\MainMenuLogic.cs:371
UnityEngineMonoBehaviourBindings.gen.cs:60
MainMenuLogic.cs:525
RaceMenu.cs:2026

おかしい遷移
MainMenuLogic.cs:365



>>村井さん
お話しのついでになのですが、マルチ招待レースに関しまして、
招待URLをクリックした際にまだアプリを初回起動さえしていない場合には、
まずユーザデータ作成とチュートリアルを終えさせてからマルチのレースに
ジャンプさせるという形で問題ないでしょうか？

お手数ですがよろしくお願いします。






もう何をどうすればいいのかわからない
どっからアカウント作成してるのかわからない
とりあえずTouchAccount()が肝な漢字がするよ
ああ、アカウントデータ作成はRegisterMainか

あGameControllerのegistUserDataがなんかあやしいな
ここでLoadScene("Register")やってる


  public void StartUser()
  {
    LHDebug.Log( "StartUser" );
    if( TutorialManager.CheckTutorialPhase( TutorialPhase.Register ) || SaveData.UserId == -1 )
    {
      RegistUserData();
    }
    else
    {
      Login();
    }
  }


基本起動時の流れはGameController>TitleLogic>GameControllerやな
TitleLogicのTapToStartの中のGaeContoroller.Instance.LoadDatasで
GameControllerのLoadDatasに飛ぶ
理論的にはこのLoadDataに連なる関数群の中でRegisterのシーンも呼ばれるし、
アカウントの作成も行われるはず、

となるとうやっぱり遷移が難しいな

やっぱりGameControllerの中のStartUserの中で
if文分岐がああって、ここで作成かログインか決まる
このif文の内容が、



チュートリアルの直前
RegisterMain.EndConnection



ん、このTutorialMenuってスクリプト、もしかして
最初のチュートリアル専用のスクリプトか


  private void PlayPhase1()
  {
    FooterManager.Instance.SetInfoText( "TutorialPhase1" );
    if ( TutorialManager.InTutorialFromHelp() )
    {
	  // ヘルプの方から来た場合のみメッセージを出さずに即レースへ遷移.
      GoRace();
    }
    else
		{
			StartCoroutine( SetCommonWindowSelect() );
			//StartCoroutine( SetCommonWindow( this.TapPhase1 ) );
		}
  }
  

PlayPhase1で「いいえ」を押すと、
SetCommonWindowSelectに進んで、その中のTutorialSkipからGameControllerのLoadDatasに入る。


つまりTutorialやったあとはまたStartUser()にもどってくるのか


どういうことだ？LoginCmdからLoadUserを通らずにいきなりMultiConfirmに飛んだぞ
関数でいうとRaceMenuのTouchMultiSelectMainだ
直前の関数はGameControllerのFinishingLoadだ

このTouchMultiSelectMain、どっかで使ってたと思うんだよな


正確にはあれだ
GameController.FInishingLoad>
LoginMenu.In>
RaceMenu.TouchMultiSelectMainだ
なるほど納得

しかしなあ、とすると、まあそれは置いといて
やっぱりクラス変数使うなら、んん






#import "UnityAppController.h"

char* __getShemeStrings()
{
    return [ExpandAppController __getSchemeStringsInner];
}

char* MakeStringCopy(const char* string)
{
    if (string == NULL) return NULL;
    char* res = (char*)malloc(strlen(string) + 1);
    strcpy(res, string);
    return res;
}


@interface ExpandAppController : UnityAppController
@end
@implementation ExpandAppController
- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication 
static id scheme = @””;

annotation:(id)annotation
{
    NSString* message = [url absoluteString];
　　scheme = message;
    return YES;
}

+(NSString*) __getSchemeStringｓInner
{
     return scheme;
}

@end

IMPL_APP_CONTROLLER_SUBCLASS(ExpandAppController)


＞五十嵐さん

マルチ招待の件、お待たせしており申し訳ありません。

ひとまずステージに下記の流れで準備してみましたが、問題がないかご確認いただけますでしょうか。

-------------------------
①ホストが「招待」ボタン押下で、下記APIにアクセス

API名:

multiplay_lobby_create(

multiplay_lobby_create

multiplay_invite_message

リクエストパラメータ:

lobby_id ⇒ ロビーID

レスポンス:

message ⇒ レース名やURLなど、招待の際に貼り付ける文章

②貼り付けたURLをタップで一旦フロント(http://stg.derby.pzga.jp/?pid=multi_invite&code=xxxxxのような形です)に遷移

③フロントから下記の形でゲーム起動

derby://multi_invite?code=xxxxx
※今公式サイトのTOPなどで使っている「ゲーム起動」は、derby://backとなっているかと思います

④③の形でゲーム起動する場合は、下記のAPIにアクセス

API名:

multiplay_invite_entry

リクエストパラメータ:

code ⇒ ③で渡すxxxxxの部分

レスポンス:

is_host_player ⇒ 自分がホストプレーヤーかどうか(ホストプレーヤの場合true、ゲストの場合falseを返します)
lobby_id ⇒ 対象のロビーID

⑤ホストかゲストかで下記の通り遷移を分ける

ホストの場合：「メンバー受付中」の画面(multiplay_player_search)に遷移。④で返したlobby_idがリクエストパラメータに

ゲストの場合：「出走ホース確認」画面に遷移。続く「メンバー参加」画面(multiplay_lobby_search)にアクセスする際、④で返したlobby_idをリクエストパラメータに付けていただけますでしょうか

-------------------------

お手数おかけしますが、宜しくお願い致します。




＞五十嵐さん

LINEに貼り付けた場合を想定すると、ホストもゲストも貼り付けたURLをタップすると②の流れに乗っかると思うので、ホストゲスト共にそのまま③④と進む。

ホストがURLタップせずアプリに戻った場合は、特に処理は不要で「メンバー受付中」の画面でゲスト待ちの状態になる。

という流れを想定しているのですがこれで伝わりますでしょうか？

multiplay_lobby_create


>>坂本さん
お疲れ様です。



>>坂本さん
お疲れ様です、ホスト側での話なのですが、multiplay_invite_entryはどのタイミングで通信
すればよいでしょうか？
お手数ですがよろしくお願いします。

レスポンスでlobby_idが返ってくるのですが、

>>坂本さん
仕様の方了解いたしました、引き続きよろしくお願いします。

、マルチ招待の時は
ロビーを作るときに通常のmultiplay_lobby_createではなく



>>坂本さん
お疲れ様です、apiのタイミングと遷移の時系列などに不安がありまして確認になります。
流れとしては下記の認識で問題ないでしょうか？

①ホスト側が条件設定で「招待ユーザー限定」画面で決定をボタンを押したとき、
multiplay_invite_entyで通信
②





EnhanceEffect　＞　EnhanceExp
EnhanceEffect.SetData ＞
EnhanceAnim.AnimationFinished () in C:\Project\PuzzleDurbyGit\netd-puzzlederby-develop\program\client\Assets\GameScenes\EnhanceAnim\Scripts\EnhanceAnim.cs:239
EnhanceConfirm.EndEffect () in C:\Project\PuzzleDurbyGit\netd-puzzlederby-develop\program\client\Assets\GameScenes\Farm\Scripts\EnhanceConfirm.cs:814
UnityEngine.MonoBehaviour.StartCoroutine (routine={EnhanceConfirm}) in C:\buildslave\unity\build\artifacts\generated\common\runtime\UnityEngineMonoBehaviourBindings.gen.cs:60
EnhanceConfirm.ChangePhase () in C:\Project\PuzzleDurbyGit\netd-puzzlederby-develop\program\client\Assets\GameScenes\Farm\Scripts\EnhanceConfirm.cs:138
EnhanceEffect.Out () in C:\Project\PuzzleDurbyGit\netd-puzzlederby-develop\program\client\Assets\GameScenes\Farm\Scripts\EnhanceEffect.cs:98


無難にsetDataとoutでいいよもう


ReincarnationEffect.SetData > ReincarnationResult.Out



lobbyId使ってるところどこだ
まずNetworkManager
あstaticだから引数で渡さなくてもいろんなところで使ってるわ。。。。
NwCmdMultiPlayerSearch






NwCmdMultiMatchReadyAnnounce.ExecCmd



>>坂本さん
お疲れ様です、追加で質問で申し訳ないのですが、ホストがマルチ招待に遷移していく過程で
multiplay_lobby_createとmultiplay_invite_messageのレスポンスで受け取るlobby_idは、同じものになるという認識で合っていますでしょうか？



まず最初にやること、ホストが、招待のあれやらこれやら
あれしたときにあれすること


ホストの流れ
RaceMenuMulti.
InLobbyConnect > ....... > OnJoinedLobby > OnJoinedRoom　> MultiLobbyCreateData

ゲストはたぶん
RaceMenuMulti
JoinRoom に進む





NetworkManager.Connect (Parameters=) in C:\Project\PuzzleDurbyGit\netd-puzzlederby-develop\program\client\Assets\GameScenes\Common\Scripts\Network\Common\NetworkManager.cs:412

NetworkManager.Parse (Parameters=) in C:\Project\PuzzleDurbyGit\netd-puzzlederby-develop\program\client\Assets\GameScenes\Common\Scripts\Network\Common\NetworkManager.cs:474

NetworkManager.FailedLogic (Parameters=) in C:\Project\PuzzleDurbyGit\netd-puzzlederby-develop\program\client\Assets\GameScenes\Common\Scripts\Network\Common\NetworkManager.cs:610

NwCmdBase.CallDelegate (Parameters=) in C:\Project\PuzzleDurbyGit\netd-puzzlederby-develop\program\client\Assets\GameScenes\Common\Scripts\Network\Common\NwCmdBase.cs:491

MultiLobby.ReloadPlayer.AnonymousMethod__32B (Parameters=) in C:\Project\PuzzleDurbyGit\netd-puzzlederby-develop\program\client\Assets\GameScenes\RaceMenu\Scripts\MultiLobby.cs:234

MultiLobby.APIError (Parameters=) in C:\Project\PuzzleDurbyGit\netd-puzzlederby-develop\program\client\Assets\GameScenes\RaceMenu\Scripts\MultiLobby.cs:551

AssertManager.SetInconsistentError (Parameters=) in C:\Project\PuzzleDurbyGit\netd-puzzlederby-develop\program\client\Assets\GameScenes\Common\Plugins\General\AssertManager.cs:101

MultiLobbyのReladPlayerで
<NwCmdMultiPlayerSearch>()にコールバックでエラーが返る
そうするとコンモンウィンドウが出て退出・
ちょっと待てよ、NwCmdMultiPlayerSearchてサーバの話だよな
でも、ルームがあるかどうかphotonの話だよな

でももうこのapi投げる前からNetowrkmanagerでエラーが出ることはきまっているんだ　
だとすると、この前の処理でもうエラーが決定しているのだから


いや違う. NwCmdMultiPlayerSearchのExecCmdが一番最初なんだ
そこでサーバからエラーが返ると、
なんかExecCmdを呼ぶと自動でNetworkManagerが呼ばエルみたいだな


  void OnJoinedLobby()
  {
    Debug.Log("OnJoinedLobby");
    if( roomType == RoomType.Create )
    {
      // 3人部屋
	    PhotonNetwork.CreateRoom( MultiLobbyStatus.lobbyId.ToString(), new RoomOptions() {maxPlayers = 3}, null );
    } else {
      PhotonNetwork.JoinRoom( MultiLobbyStatus.lobbyId.ToString() );
    }
  }
 
  // 部屋に入った
  void OnJoinedRoom()
  {
    Debug.Log("OnJoinedRoom");

    needUnlockInput = false;  // 正常終了時は、InLobbyの先でunlockするので、ここでする必要はない.
    if( roomType == RoomType.Create )
    {
      InLobby(TouchLobbyCancel_Host);
      //OnPhotonCreateRoomFailed();
    } else {
      InLobby(TouchLobbyCancel_Guest);
    }
  }

ほーん、なるほどねえ、つまりHostでJoinすればいいだけか

一度でた部屋をhostとして入り直すことは無理っぽいよ

とすると、ロビーＩＤのほかにどのチームを選んでるか、どのレースを選んでるのかも保存しなくちゃいけねえじゃねえか
仮にJumpで直接起動するならよ、


いやちょっとまてよ、ループして再進入処理があるはずだ、つまり
ホストとして入り直すこともあるはずだ、恐らく、NwCmdMultiPlayerSearchの中？
いや自分を探すことはないか？


IInNormalList(  > nLobbyConnect     > RaceVersionCheck

TouchNormalRaceTitle > InNormalSubList()
TouchNormalSubRaceTitle >  TouchSubRaceTitle()  > TouchMultiConfirm  >  TouchMultiConfirmSuccess() 
InLobbyComment  > InLobbyConnect() > CreateMultiLobby api



      NwCmdRaceList cmdRaceList = NetworkManager.Instance.GetCmd<NwCmdRaceList>();
      this.InNormalSubList( cmdRaceList.GetData().GetNormalRaceList()[0], cmdRaceList.GetData().GetNormalRaceList()[0] );
      curRaceType = RaceType.Normal;
      SaveData.RacePage = RaceType.Normal;
 

  private void InNormalSubList( NwDataRaceData raceData , NwDataRaceData raceFriendData )
  {
    RaceData.ChapterName = raceData.name;
    RaceData.SubTitle = raceData.sub_title;

    curRaceId = raceData.id;
    MenuBase.CreateMenu<RaceSubList>( ref instanceRaceNormalSubList, raceNormalSubList, this.transform );
//    instanceRaceNormalSubList.SetCallback( raceData.StageDatas, raceData.StageDatas, TouchNormalSubRaceTitle  );
    instanceRaceNormalSubList.SetCallback( raceData.StageDatas, raceFriendData.StageDatas, TouchNormalSubRaceTitle  );
    TitleBoardManager.Instance.AddCallback( BackToRace );
    StartCoroutine( ChangePhase( RaceMenuPhase.NormalRace  ) );





    curRaceType = RaceType.Normal;
    SaveData.RacePage = RaceType.Normal;

    raceMenu.SetInitialPage( category, stage, raceID );
    bool isMulti = category == "multi";

    NwDataRaceData raceData = cmdRaceList.GetData().GetNormalRaceList()[0];
    NwDataStageData stageData = raceData.stageList[0];

   //Equivalent to InNormalSubList
    RaceData.ChapterName = raceData.name;
    RaceData.SubTitle = raceData.sub_title;
    curRaceId = raceData.id;

    //Equivalent to Touch xx SubRaceTitle
    RaceData.IsMultiBgm = isMulti;
    RaceData.SingleBgm = stageData.singleBgm;
    RaceData.IsMultiBgm = stageData.multiBgm;
    curStageId = stageData.id;
    RaceData.StageName = stageData.name;
    RaceData.ConditionCategory = stageData.condition_category;
    RaceData.ConditionType = stageData.condition_type;
    RaceData.ConditionValue = stageData.condition_value;
    RaceData.EntryPoint = stageData.use_entry_point;
    RaceData.RoundNum = stageData.max_battle_num;
    RaceData.Difficulty = stageData.difficulty;
    RaceData.SpecialTermsId = stageData.special_terms_id;
    RaceData.SpecialTermsValue = stageData.special_terms_value;
    RaceData.UnuseBlock = stageData.unuse_block;

    //Equivalent to TouchSubRaceTitle
    Resources.UnloadUnusedAssets(); // TEST ver.1.6.3
    System.GC.Collect(); // TEST ver.1.6.3
   // prevPhase =  RaceMenuPhase.MultiComment;
     RaceData.RaceId = curRaceId;
    //TitleBoardManager.Instance.AddCallback( BackSubRace );

   if(CheckConditionAtConfirm() != true)
   {
       return;
   }
  TouchMultiConfirm();

MultiLobbyStatus.multiType)

これraceDataとstageDataのindexを保存したほうがいいな
さすがにきつい



void TouchMultiSelectMain() から instanceMultiConfirm.CreateDataが呼ばれている
その遷移は
AssetBundleManager.Request () in C:\Project\PuzzleDurbyGit\netd-puzzlederby-develop\program\client\Assets\GameScenes\Common\Plugins\General\AssetBundleManager.cs:458
AssetBundleManager.LoadTexture.AnonymousMethod__2 (obj={jockey_plate_1_2 (UnityEngine.Texture2D)}) in C:\Project\PuzzleDurbyGit\netd-puzzlederby-develop\program\client\Assets\GameScenes\Common\Plugins\General\AssetBundleManager.cs:336
JockeyEventVersionLoader.Load (texture={jockey_plate_1_2 (UnityEngine.Texture2D)}) in C:\Project\PuzzleDurbyGit\netd-puzzlederby-develop\program\client\Assets\GameScenes\Common\Scripts\Network\Common\NwDataJockeyEventVersion.cs:37
JockeyEventVersionLoader.CallOnEnd () in C:\Project\PuzzleDurbyGit\netd-puzzlederby-develop\program\client\Assets\GameScenes\Common\Scripts\Network\Common\NwDataJockeyEventVersion.cs:50

謎



     //Equ TouchMultiSelectMain
　　　RaceData.RaceId = -1;	// レースがまだ決まっていない
　　　RaceData.ConditionCategory = -1;
　　  RaceData.ConditionValue = new int[]{-1};
      MultiLobbyStatus.multiType = MultiType.Host;
      MenuBase.CreateMenu<MultiConfirm>(ref instanceMultiConfirm, multiConfirm, this.transform);
      TitleBoardManager.Instance.AddCallback( BackToHostSelect );
      instanceMultiConfirm.CreateData("", "", MultiLobbyStatus.multiType, TouchMultiConfirm);


    Debug.Log("InLobbyComment");
    MenuBase.CreateMenu<MultiComment>(ref instanceMultiComment, multiComment, this.transform);
    instanceMultiComment.SetCallback(() => {
      curCommentId = instanceMultiComment.GetCurrentCommentId();
      Debug.Log("Comment="+curCommentId);
      if ( curCommentId == (int)RoomCommentID.Password )
      {
        // パスワード設定に遷移.
        OpenPasswordWindow( MultiType.Host, (text) => {
          MultiLobbyStatus.lobbyKey = text;
          InLobbyConnect();
        } );
      }
      else
      {
        InLobbyConnect();
      }
    });
    StartCoroutine(ChangePhase(RaceMenuPhase.MultiComment));

curRaceId, curStageId, curCommentId+1)
















  public void DirectEnterMultiLobby()
  {
    System.Action multiLobbyJump = () =>
    {
        curRaceType = RaceType.Normal;
        SaveData.RacePage = RaceType.Normal;

        NwCmdRaceList cmdRaceList = NetworkManager.Instance.GetCmd<NwCmdRaceList>();
        NwDataRaceData raceData = cmdRaceList.GetData().GetNormalRaceList()[0];
        NwDataStageData stageData = raceData.stage_list[0];

        //Equivalent to InNormalSubList
        RaceData.ChapterName = raceData.name;
        RaceData.SubTitle = raceData.sub_title;
        curRaceId = raceData.id;

        //Equivalent to Touch xx SubRaceTitle
        RaceData.IsMultiBgm = isMulti;
        RaceData.SingleBgm = stageData.singleplay_sound_id;
        RaceData.MultiBgm = stageData.multiplay_sound_id;
        RaceData.StageName = stageData.name;
        RaceData.ConditionCategory = stageData.condition_category;
        RaceData.ConditionType = stageData.condition_type;
        RaceData.ConditionValue = stageData.condition_value;
        RaceData.EntryPoint = stageData.use_entry_point;
        RaceData.RoundNum = stageData.max_battle_num;
        RaceData.Difficulty = stageData.difficulty;
        RaceData.SpecialTermsId = stageData.special_terms_id;
        RaceData.SpecialTermsValue = stageData.special_terms_value;
        RaceData.UnuseBlock = stageData.unuse_block;
        curStageId = stageData.id;

        //Equivalent to TouchSubRaceTitle
        Resources.UnloadUnusedAssets(); // TEST ver.1.6.3
        System.GC.Collect(); // TEST ver.1.6.3
        RaceData.RaceId = curRaceId;
        //TitleBoardManager.Instance.AddCallback( BackSubRace );

        //Equuivalent to TouchMultiSelectMain
        MultiLobbyStatus.multiType = MultiType.Host;
      /*
        MenuBase.CreateMenu<MultiConfirm>(ref instanceMultiConfirm, multiConfirm, this.transform);
        instanceMultiConfirm.CreateData("", "", MultiLobbyStatus.multiType, TouchMultiConfirm);
*/
        prevPhase =  RaceMenuPhase.HostSelect;
        TitleBoardManager.Instance.AddCallback( BackToHostSelect );

        if(CheckConditionAtConfirm() != true)
        {
          return;
        }

      /*
        Debug.Log("InLobbyComment");
        MenuBase.CreateMenu<MultiComment>(ref instanceMultiComment, multiComment, this.transform);
        instanceMultiComment.SetCallback(() => {
        curCommentId = instanceMultiComment.GetCurrentCommentId();
        Debug.Log("Comment="+curCommentId);
        if ( curCommentId == (int)RoomCommentID.Password )
        {
          // パスワード設定に遷移.
          OpenPasswordWindow( MultiType.Host, (text) => {
            MultiLobbyStatus.lobbyKey = text;
            InLobbyConnect();
          } );
        }
        else
        {
          InLobbyConnect();
        }
        });
*/


        int commentBoardNumOfinviteMultiRoom = 3;
        curCommentId = commentBoardNumOfinviteMultiRoom;

        InLobbyConnect();
    };
      
    MethodForJumpInviteMulti(multiLobbyJump);
  }







  private void InNormalList( bool isStart = false )
  {
    Debug.Log("InNormalList");
    MenuBase.CreateMenu<RaceList>( ref instanceRaceNormalList, raceNormalList, this.transform );
    instanceRaceNormalList.SetCallback( TouchNormalRaceTitle );
    instanceRaceNormalList.SetScrollTopID( initialPageSetter );
    
    if( isStart )
    {  
      curPhase = RaceMenuPhase.NormalTop;
      curMenu  = instanceRaceNormalList;
      instanceRaceNormalList.In();
      FooterManager.Instance.ShowSuggestPanel( bannerTexture, this.TouchBanner );
    }
    else
    {
      StartCoroutine( ChangePhase( RaceMenuPhase.NormalTop ) );
    }
    
    curRaceType = RaceType.Normal;
    SaveData.RacePage = RaceType.Normal;

  }


⑤ホストかゲストかで下記の通り遷移を分ける

ホストの場合：「メンバー受付中」の画面(multiplay_player_search)に遷移。④で返したlobby_idがリクエストパラメータに

ゲストの場合：「出走ホース確認」画面に遷移。続く「メンバー参加」画面(multiplay_lobby_search)にアクセスする際、④で返したlobby_idをリクエストパラメータに付けていただけますでしょうか


>>坂本さん

>ゲストの場合：「出走ホース確認」画面に遷移。続く「メンバー参加」画面(multiplay_lobby_search)にアクセスする
際、④で返したlobby_idをリクエストパラメータに付けていただけますでしょうか

念のためなのですが、こちらはmultiplay_lobby_searchのリクエストパラメータに新しくlobby_idを追加するということで大丈夫でしょうか？
お手数ですがよろしくお願いします。






MultiLobbyStatus.LobbyIdが代入される箇所は二か所
MultiLobbySearchとMultiLobbyCreateのAPIでsuccescallbackが返ってきたところ









System.Action TouchMultiConfirmForInvite = () =>
{
	if(CheckConditionAtConfirm() == true)
	{
		return;
	}
    LoadingManager.Instance.Play(true);
    NwCmdMultiLobbySearch cmd = NetworkManager.Instance.GetCmd<NwCmdMultiLobbySearch>();
    cmd.SetCallBack(() => {
      LoadingManager.Instance.Pause();
      MenuBase.CreateMenu<MultiLobbySelect>(ref instanceLobbySelect, multiLobbySelect, this.transform);
      TitleBoardManager.Instance.AddCallback(BackToMultiConfirm);
      instanceLobbySelect.CreateData(cmd.GetLobbyList(), MultiLobbyStatus.lobbyKey, (lobbyItem) => {

      if (!CheckConditionAtMultiLobbySelect(lobbyItem))
     {
	return;
     }

        if ( lobbyItem.GetData().room_comment - 1 == (int)RoomCommentID.Password || lobbyItem.GetData().lobby_key != 0 )
        {
          OpenPasswordWindow( MultiType.Guest, (password)=> {
            bool invalidPassword = true;
            int inputedLobbyKey = 0;
            if ( int.TryParse( password, out inputedLobbyKey ) )
            {
              if ( lobbyItem.GetData().lobby_key == inputedLobbyKey )
              {
                invalidPassword = false;
              }
            }

            if ( invalidPassword )
            {
              // パスワードが違う表示.
              // パスワードウィンドウが閉じてから開かないと、curtainなどがはずれた状態で開く事になるため、閉じるのを待つ.
              StartCoroutine( WaitClosePasswordWindow(()=>{
                MainMenuLogic.Instance.LockFooterHeader();
                CommonWindow.Instance.SetDatas( "InvalidPassword", (idx) => {
                  CommonWindow.Instance.PlayCloseAnim();
                  MainMenuLogic.Instance.UnlockFooterHeader();
                } );
                CommonWindow.Instance.PlayOpenAnim( this.transform, false, true );
              }) );
            }
            else
            {
              RaceVersionCheck(() => {
                Debug.Log("callback TouchLobbySelect");
                TouchLobbySelect(lobbyItem);
              });
            }
          });
        }
        else
        {
          RaceVersionCheck(() => {
            Debug.Log("callback TouchLobbySelect");
            TouchLobbySelect(lobbyItem);
          });
        }
      });
      StartCoroutine(ChangePhase(RaceMenuPhase.MultiLobbySelect));
    },
   (err) => {
      LoadingManager.Instance.Pause();
      if(err == NetworkError.Inconsistent) {
        AssertManager.Instance.SetInconsistentError(cmd, cmd.GetError().ToString());
      } else {
        AssertManager.Instance.SetConnectFailed(cmd);
      }
    });
        
    cmd.ExecCmd();


}


   　 LoadingManager.Instance.Pause();
  　  NwCmdRaceList cmdRaceList = NetworkManager.Instance.GetCmd<NwCmdRaceList>();

   　if( cmdRaceList.GetData().GetSpecialRaceList() != null && cmdRaceList.GetData().GetSpecialRaceList().Length > 0 )
    {
      existRankingEvent = true;
    }
    else
    {
      existRankingEvent = false
    }；

　　 RaceData.RaceId = -1;	// レースがまだ決まっていない
 　　RaceData.ConditionCategory = -1;
　　 RaceData.ConditionValue = new int[]{-1};
 
      MultiLobbyStatus.multiType = MultiType.Guest;
      MenuBase.CreateMenu<MultiConfirm>(ref instanceMultiConfirm, multiConfirm, this.transform);
      TitleBoardManager.Instance.AddCallback( BackToHostSelect );
      instanceMultiConfirm.CreateData("", "", MultiLobbyStatus.multiType, TouchMultiConfirm);
      StartCoroutine( ChangePhase( RaceMenuPhase.MultiConfirm ) );


multiLobbySearchでlobbystatusを上書きしなきゃだめだ
















TouchMultiSelectMain()


    //LoadingManager.Instance.Pause();
    NwCmdRaceList cmdRaceList = NetworkManager.Instance.GetCmd<NwCmdRaceList>();

    if( cmdRaceList.GetData().GetSpecialRaceList() != null && cmdRaceList.GetData().GetSpecialRaceList().Length > 0 )
    {
      existRankingEvent = true;
    }
    else
    {
      existRankingEvent = false;
    }
      RaceData.RaceId = -1;	// レースがまだ決まっていない
      RaceData.ConditionCategory = -1;
      RaceData.ConditionValue = new int[]{-1}; 
      Debug.Log("MultiSelectButtonType.Guest");
      MultiLobbyStatus.multiType = MultiType.Guest;
      MenuBase.CreateMenu<MultiConfirm>(ref instanceMultiConfirm, multiConfirm, this.transform);
      TitleBoardManager.Instance.AddCallback( BackToHostSelect );
      instanceMultiConfirm.CreateData("", "", MultiLobbyStatus.multiType, TouchMultiConfirm);
      StartCoroutine( ChangePhase( RaceMenuPhase.MultiConfirm ) );



<C:\Users\cyclone-staff\Desktop\Windows 10 アップグレード アシスタント.lnk>

まず優先順位決めよ
１ボタン押せないンバグ
２チーム消えるバグ
&amp;がっかない問題


zeOAb_B_cC9JtwoUFefT
zeOAb_B_cC9JtwoUFefT

%0A　改行？


原因はチームＩＤではない？
まあそれはともかくとりあえず戻るボタンのあれをあれしよう

ホストはTouchSubRaceTitle()でmultiConfirmをクリエイトしとるな

TouchSubRaceTitle()


	  RaceData.RaceId = curRaceId;
      MenuBase.CreateMenu<MultiConfirm>(ref instanceMultiConfirm, multiConfirm, this.transform);
      TitleBoardManager.Instance.AddCallback( BackSubRace );
      instanceMultiConfirm.CreateData(RaceData.ChapterName, RaceData.StageName, MultiLobbyStatus.multiType, TouchMultiConfirm);
      StartCoroutine( ChangePhase( RaceMenuPhase.MultiConfirm ) );






1304行目　１３３３１
  public void TouchEventRaceTitle( RaceListItem item )
  {
	#if DEBUG_MODE
	if (TestRaceData.Instance.isTest)
	{
		TestRaceData.Instance.SetTestRaceData(item);
	}
	#endif

    RaceData.ChapterName = item.GetData().name;
    RaceData.SubTitle = item.GetData().sub_title;
    curRaceId = item.GetData().id;   
    MenuBase.CreateMenu<RaceEventSubList>( ref instanceRaceEventSubList, raceEventSubList, this.transform );
    instanceRaceEventSubList.SetCallback( item.GetData(), item.GetData().StageDatas, TouchEventSubRaceTitle );
    
    TitleBoardManager.Instance.AddCallback( BackToEventRace );
    StartCoroutine( ChangePhase( RaceMenuPhase.SpecialRace ) );
  }

なんやこれ、どこで見つかったんや
そもそもひょｊｙｊンのJUMPメゾットはracerは自とらんかったじゃろ

ロビーに入場できませんでした
－２:32758


だめだ3時間たっても解決しない、羅列するしかない、羅列、するしかない
チームIDは正常だとすると、あとはロビーが壊れてるかどうか、とも思ったけど
仮で壊さないようにしても、ちょっとまてよ、ロビーIDが一緒かどうか見てみよう
うーんID違うってことはちゃんと作り直して存在してるってことだよな、んで、
サーバにもチーム送って得に異常は出ていないはず


 instanceRaceConfirm.UseTeamId,





とりあえずやることは、MultiLobby画面で、どこから自分のチームの情報が流されてjきて表示に至っているか確認することだ
もしかしてチームIDだけで判別してんのか?
とにかくSetDataだけみりゃなんとかなると思うけど

あとCreateからJoinはどうやっておこなわれているかね、これを午前中に終わらそう


    cmdTeamEdit = NetworkManager.Instance.GetCmd<NwCmdTeamEdit>();
でチームデータ送ってんのか


やっぱりアプリを落とすだけだとDeleteLobby通ってないから消えてない

やっぱTouchLobbySelectが怪しい、というかまんまなんだよなあ

            TouchLobbySelect(lobbyItem)でリロビー画面に入るんだけど
そもそも、このlobbyitemとはいったい
その招待はこれだ
public class MultiLobbySelectItem : MonoBehaviour 
{
  private MultiLobbySelectItemTouchCallback touchCallback = null;

  public int          Index { get; private set; }

  private NwDataMultiLobbyData data;
  public SpriteText   userNameText;
  public SpriteText   stageNameText;
  public SpriteText   matchNameText;
  public UIButton     btn;
  public HorseCardSprite leader;
//  public PackedSprite formation;
  public PackedSprite itemBaseSprite;
  public PackedSprite commentBaseSprite;
  public SpriteText   commentText;
  public SpriteText   difficultText;
  public GameObject   friendMark;
  public GameObject   passwordMark;

  public string errorReason{ get; private set; }
 
  /// <summary>

あとホストはここ通ってない気kがする

だいいちゲストもロビーに入室した段階のどこかで、apiと連絡しなきゃいけないはずだ

とりあえずNwCmdMultiLobbySearchでロビー情報取得して
その内の指定したロビーIDと合致したものCreateLobbyするか？
そしてその前にdeleteLobbyしないこと。

deleteLobbyのタイミングを頑張って検証して削らないといけないかもね・・・・・




      MultiLobbyStatus.lobbyKey = instanceMultiConfirm.LobbyKey;

      LoadingManager.Instance.Play(true);
      NwCmdMultiLobbySearch cmd = NetworkManager.Instance.GetCmd<NwCmdMultiLobbySearch>();
      cmd.SetCallBack(() => 
      {
          LoadingManager.Instance.Pause();
          MenuBase.CreateMenu<MultiLobbySelect>(ref instanceLobbySelect, multiLobbySelect, this.transform);
          TitleBoardManager.Instance.AddCallback(BackToMultiConfirm);
          instanceLobbySelect.CreateData(cmd.GetLobbyList(), MultiLobbyStatus.lobbyKey, (lobbyItem) => 
          {
              
            if (!CheckConditionAtMultiLobbySelect(lobbyItem))
            {
              return;
            }
                
            RaceVersionCheck(() => 
            {
              Debug.Log("callback TouchLobbySelect");
              TouchLobbySelect(lobbyItem);
            });

          });
          
          StartCoroutine(ChangePhase(RaceMenuPhase.MultiLobbySelect));
      },
      (err) =>
      {
        LoadingManager.Instance.Pause();
        if(err == NetworkError.Inconsistent) 
        {
          AssertManager.Instance.SetInconsistentError(cmd, cmd.GetError().ToString());
        } else
        {
          AssertManager.Instance.SetConnectFailed(cmd);
        }
      });
          
      MultiLobbyStatus.lobbyId = InviteMultiRoom.Instance.InviteLobbyId;
      Debug.Log("Searching Invited Lobby ID is = " + MultiLobbyStatus.lobbyId);

      cmd.ExecCmd(MultiLobbyStatus.lobbyId);






こっちがクｋリエイトの方ですよ

  void InLobbyConnect() {
//   LoadingManager.Instance.Play( true );
   
    Debug.Log("InLobbyConnect");
    RaceVersionCheck(() => {
      NwCmdMultiLobbyCreate cmd = NetworkManager.Instance.GetCmd<NwCmdMultiLobbyCreate>();
      cmd.SetCallBack(() => {
        MultiLobbyStatus.lobbyId = cmd.GetLobbyId();
        Debug.Log("Created Lobby that LobbyId is = " + MultiLobbyStatus.lobbyId);

        if(curCommentId == (int)RoomCommentID.InviteSNS)
        {
          GetInviteMessageData();
          return;
        }
#if !OLD_MULTI
        CreateRoom();
#else
        InLobby(TouchLobbyCancel_Host);
#endif
      },
     (err) => {
        if(err == NetworkError.Inconsistent) {
          AssertManager.Instance.SetInconsistentError(cmd, cmd.GetError().ToString());
        } else {
          AssertManager.Instance.SetConnectFailed(cmd);
        }
      });
      cmd.ExecCmd(curRaceId, curStageId, curCommentId+1); // コメントは (0～n -> 1～n+1)
    });
  }


んｎ？こっちかロビー作成は？


はいはい、部屋に入るときは単純に、      PhotonNetwork.JoinRoom( MultiLobbyStatus.lobbyId.ToString() );
引数にロビーIDをstringに変換して入れてるのねこね


ＰｈｏｔｏｎＮｅｔｗｏｒのconecteｄがfolseみたい、なぜ　７０行目です。





Cannot send messages when not connected. Either connect to Photon OR use offline mode!
UnityEngine.Debug:LogError(Object)
PhotonNetwork:VerifyCanUseNetwork() (at Assets/Photon Unity Networking/Plugins/PhotonNetwork/PhotonNetwork.cs:1570)
PhotonNetwork:RPC(PhotonView, String, PhotonTargets, Boolean, Object[]) (at Assets/Photon Unity Networking/Plugins/PhotonNetwork/PhotonNetwork.cs:2911)
PhotonView:RPC(String, PhotonTargets, Object[]) (at Assets/Photon Unity Networking/Plugins/PhotonNetwork/PhotonView.cs:569)
PhotonManager:SendSyncData() (at Assets/GameScenes/Puzzle/Scripts/MultiPlayInGameScripts/PhotonManager.cs:155)
<SuccessCheck>c__IteratorDD:MoveNext() (at Assets/GameScenes/Puzzle/Scripts/MultiPlayInGameScripts/PhotonManager.cs:114)
UnityEngine.MonoBehaviour:StartCoroutine(IEnumerator)
<SetMultiSamePieces>c__IteratorEC:MoveNext() (at Assets/GameScenes/Puzzle/Scripts/PuzzleLogic.cs:995)
UnityEngine.MonoBehaviour:StartCoroutine(IEnumerator)
<Start>c__IteratorA2:MoveNext() (at Assets/GameScenes/Puzzle/Scripts/GameLogic.cs:365)





VerifyCanUseNetwork()っここでフリーズしてし




PhotonNetworｋの７０行目

    public static bool connected
    {
        get
        {
            if (offlineMode)
            {
                return true;
            }

            if (networkingPeer == null)
            {
                return false;
            }

            return !networkingPeer.IsInitialConnect && networkingPeer.State != PeerState.PeerCreated && networkingPeer.State != PeerState.Disconnected && networkingPeer.State != PeerState.Disconnecting && networkingPeer.State != PeerState.ConnectingToNameServer;
        }
    }

この最後の !networkingPeer.IsInitialConnect && networkingPeer.State != PeerState.PeerCreated && networkingPeer.State != PeerState.Disconnected && networkingPeer.State != PeerState.Disconnecting && networkingPeer.State != PeerState.ConnectingToNameServer;

で常に通信してるか見てる。これが切れるともうあかん。











RaceMenuのOnConnectionFailでphoton独自に切断しとるで
PhotonManager.Disconnect呼ばれとる

  // 通信失敗
  void OnConnectionFail(DisconnectCause cause)
  {
    Debug.Log("OnConnectionFail");
    // フォトン切断
    PhotonNetwork.Disconnect();
    NetworkManager.SendMultiErrorReport( NetworkManager.Instance, LitJson.JsonMapper.ToJson( CreateErrorReportDictionary( "ConnectionFail", string.Format( "RaceMenuMulti.OnConnectionFail[{0}]", cause.ToString() ) ) ) );
    AssertManager.Instance.SetConnectFaile
d( null );
  }

まず一番最初は惑星会議のUpdateでまず不穏な動きがある
        while (PhotonNetwork.isMessageQueueRunning && doDispatch)
        {
            // DispatchIncomingCommands() returns true of it found any command to dispatch (event, result or state change)
            Profiler.BeginSample("DispatchIncomingCommands");
            doDispatch = PhotonNetwork.networkingPeer.DispatchIncomingCommands();
            Profiler.EndSample();
        }

おそらくPhotonNetwork.isMessageQwueueRunninがぬｌｌ


そもそも逆にPhotonってどのタイミングで始まるんだ？？





あんまり上流で処理しないでしたの方で処理しよ
Ｐｈｏｔｏｎの中はもう訳が分からない

こちらＲａｃｅＭｅｎｕ
  // 通信失敗
  void OnConnectionFail(DisconnectCause cause)
  {
    Debug.Log("OnConnectionFail");
    // フォトン切断
    PhotonNetwork.Disconnect();
    NetworkManager.SendMultiErrorReport( NetworkManager.Instance, LitJson.JsonMapper.ToJson( CreateErrorReportDictionary( "ConnectionFail", string.Format( "RaceMenuMulti.OnConnectionFail[{0}]", cause.ToString() ) ) ) );
    AssertManager.Instance.SetConnectFailed( null );
  }


これサーバの方でもＰｌａｙｅｒＳｅａｒｃｈで見つからなかったらすぐerror返してるな



まずＭｕｌｔｉＬｏｂｂｙのApiErrorが肝ってことは分かったけど
これ別に呼び出されなくても、結局PhotonNetwoekで同時通信できなかったよね
connectionだかいう変数がファルスで
やっぱ大前提としてそれが最初だとおもうんだよな
マルチで確かり



とりあえず何も思いつかない、発砲ふさがり、マジでもう駄目だ
とりあえず何か考えてみるか

でも考えてみるとゲストはころころかわってもちゃんと認識してくれるのに
ホストになると分かってくれないってのおかしくないか

とにかく窓口としは絶対に同期直後にLeaderChangeは呼ばれている
ここからさかのぼっていけばどの関数で同期をとっているかわかるはずだ
基本的にLeaderChangeはRefreshUserDataからしかよばれていない
ということは、さらにさかのぼるとReloadPlayer、さらにさかのぼると
Reload、さらにさかのぼるとUpdateになる
これら関数は直接同期をとる関数ではないので、恐らくReloadの関数
の内部あたりに同期をとる何らかの関数があるのでなかろうか
あれえ、Ｒｅｌｏａｄじゃねえのか

とりあえずReloadの一番上の
    if(!subcaptainIsNotFound.IsSending || NwCmdMultiPlayerSearch.Ver108SubcaptainIdNotFound) {
これずっとtrue
falseみたことない、どんなにいじっても


  void ReloadPlayer() {
    reloading = true;
    var cmd = GetCmd<NwCmdMultiPlayerSearch>();
    cmd.SetCallBack(() => {
      if(!Login) {
        Login = true;
        LoadStop();
      }
      List<NwDataMultiUserData> list = cmd.GetUserList();
      RefleshUserData(list, cmd.GetSubCaptainId());

ReloadPlayerの少し下、
      List<NwDataMultiUserData> list = cmd.GetUserList();
      RefleshUserData(list, cmd.GetSubCaptainId());
ここで同期をとっている。まあだから同期というかこれ一方通行なのか
受け取る側はこのPlayerSearchから馬のチームの全体情報（サブキャプテンとかもふくめて）
受け取って、Reload枚にそれを更新しているだけ

とすると、Host側はどうなんだ？どうやってPlayerSearchにデータに反映させるものを
サーバに送っているんだ？

ちょっと立場を変えてみようか、今ゲストだとけどホスト側やってみよう

あれ、予想に反してだいたい通ってるところ一緒だわ
つまりゲストもホストもNwCmdMultiPlayerSearch一点のみ情報のやりとりをしている？？
違うところは下記のなんかdeicdeButtonに関するところだけだったわ
        if(!reloadPause && multiType == MultiType.Host) {
          decideBtn.controlIsEnabled = (list != null && list.Count >= 2 && isLimit && /*!subcaptainIsNotFound.IsNotFound &&*/ !subcaptainIsNotFound.IsSending);

ああよく見たら違かったわ、すまん、
      List<NwDataMultiUserData> list = cmd.GetUserList();だ　ホストがわは
いやいや違くないよ、やっぱりNwCmdMultiPlayerSearch一転だ



んんんんんんんんんんｎしかしNwCmdPlayerSearchはロビーIDしか送ってないぞ、
どうやってロビーIDだけで、上方とかサブリーダーの情報送ってんだよ、んんｎ？？


ようやく見つけた、Reloadの中だ

    var cmd = GetCmd<NwCmdMultiPostSubcaptain>();
    cmd.SetCallBack(() => {
      ReloadPlayer();
    }, (err) => {
      APIError(cmd, ErrorLogout);
    });
    cmd.ExecCmd(MultiLobbyStatus.SubCaptainId);


このNwCmdMultiPostSubcaptainを通して
なんかいろいろあれがみつかる




DeleteLobbyはMainMenuLogic
PhotonのあれはPhotonManagerのFinish






フリーズの問題はここや
｛
ReceiveSyncData
UnityEngine.Debug:Log(Object)
PhotonManager:ReceiveSyncData(Int32) (at Assets/GameScenes/Puzzle/Scripts/MultiPlayInGameScripts/PhotonManager.cs:176)
System.Reflection.MethodBase:Invoke(Object, Object[])
NetworkingPeer:ExecuteRpc(Hashtable, PhotonPlayer) (at Assets/Photon Unity Networking/Plugins/PhotonNetwork/NetworkingPeer.cs:2406)
NetworkingPeer:RPC(PhotonView, String, PhotonTargets, Boolean, Object[]) (at Assets/Photon Unity Networking/Plugins/PhotonNetwork/NetworkingPeer.cs:3295)
PhotonNetwork:RPC(PhotonView, String, PhotonTargets, Boolean, Object[]) (at Assets/Photon Unity Networking/Plugins/PhotonNetwork/PhotonNetwork.cs:2930)
PhotonView:RPC(String, PhotonTargets, Object[]) (at Assets/Photon Unity Networking/Plugins/PhotonNetwork/PhotonView.cs:569)
PhotonManager:SendSyncData() (at Assets/GameScenes/Puzzle/Scripts/MultiPlayInGameScripts/PhotonManager.cs:169)
<SuccessCheck>c__IteratorDD:MoveNext() (at Assets/GameScenes/Puzzle/Scripts/MultiPlayInGameScripts/PhotonManager.cs:128)
UnityEngine.MonoBehaviour:StartCoroutine(IEnumerator)
<SetMultiSamePieces>c__IteratorEC:MoveNext() (at Assets/GameScenes/Puzzle/Scripts/PuzzleLogic.cs:995)
UnityEngine.MonoBehaviour:StartCoroutine(IEnumerator)
<Start>c__IteratorA2:MoveNext() (at Assets/GameScenes/Puzzle/Scripts/GameLogic.cs:365)




SendSyncData
UnityEngine.Debug:Log(Object)
PhotonManager:SendSyncData() (at Assets/GameScenes/Puzzle/Scripts/MultiPlayInGameScripts/PhotonManager.cs:168)
<SuccessCheck>c__IteratorDD:MoveNext() (at Assets/GameScenes/Puzzle/Scripts/MultiPlayInGameScripts/PhotonManager.cs:128)
UnityEngine.MonoBehaviour:StartCoroutine(IEnumerator)
<SetMultiSamePieces>c__IteratorEC:MoveNext() (at Assets/GameScenes/Puzzle/Scripts/PuzzleLogic.cs:995)
UnityEngine.MonoBehaviour:StartCoroutine(IEnumerator)
<Start>c__IteratorA2:MoveNext() (at Assets/GameScenes/Puzzle/Scripts/GameLogic.cs:365)




[[Enter WaitDrag]]
UnityEngine.Debug:Log(Object)
StateMachine`1:StartState(DragState) (at Assets/Standard Assets/Utility/StateMachine.cs:38)
PuzzleLogic:MakeDragStateMachine() (at Assets/GameScenes/Puzzle/Scripts/PuzzleLogic.cs:474)
PuzzleLogic:Init() (at Assets/GameScenes/Puzzle/Scripts/PuzzleLogic.cs:131)
<Start>c__IteratorA2:MoveNext() (at Assets/GameScenes/Puzzle/Scripts/GameLogic.cs:364)
｝


Uv8e014GY2VzYuBwkGwz

了解しました、ウィンドウの上記のメッセージを表示するようにいたします。
よろしくお願いします。





もしやPhotonがまだ残ってるのに新しいphoron作ろうとするとエラー出るのか



まずなんでエラーが来た時にコールバックにあれされないのか
なんかNwCmdでerrorに代入する内容と、ExrcCmdがよぼ\\




>>坂本さん
お疲れ様です、マルチ招待で、ホストがmultiplay_lobby_createで作ったロビーが、すでに壊れてる

>>坂本さん
お疲れ様です。マルチ招待の相談になります。
ホストが招待URLをクリックした際に、自分がmultiplay_lobby_createで作ったロビーが
すでに壊れている場合、現状Photonのエラーが出るだけですが、遷移としては問題ないでしょうか？
プロジェクトの方では、「戻る」ボタンや下部のメニューアイコンをタップすると部屋は壊れる仕様になっています。

お手数ですがよろしくお願いします。



PuzzleLogic dragStateMachine.StartState( DragState.WaitDrag );  >

  // 同期情報送信
  public static void SendSyncData()
  {
    Debug.Log("SendSyncData");
    scenePhotonView.RPC("ReceiveSyncData", PhotonTargets.All, (int)SaveData.UserId );
  }

  // 同期情報受信
  [PunRPC]
  public void ReceiveSyncData( int userId )
  {
    Debug.Log("ReceiveSyncData");
    success.Add( userId );
  }

やっぱこの３つでちょうど止まるね、逆に正常な遷移はどうなってんだ？そもそも上の同期っていつから始まるんだ


正常はここからさらに
ReceivePieceData　＞PlaySe=RaceGateOpen＞　
http://stg.img.derby.pzga.jp/AssetBundle/Android/Sounds/BGM/bgm07_1.unity3d
UnityEngine.Debug:Log(Object)
と続いていく
  // ピース情報受信
  [PunRPC]
  public void ReceivePieceData( int[] color )
  {
    Debug.Log("ReceivePieceData");
    puzzleLogic.SetReceivePieceData( color );
    ReceiveWait = false;
  }



ということはSendPieceDataからReceivePieceDataに飛べないのか
  // ピース情報送信
  public static void SendPieceData( P2PDataPiece data )
  {
    Debug.Log("SendPieceData");
    scenePhotonView.RPC("ReceivePieceData", PhotonTargets.Others, data.pieces);
  }


まず一番最初の遷移の始まりが知りたい














ここか、ここでずっと回ってるんだ
ここでwhileからbreakしないんだ

  // 同期チェック
  public static IEnumerator SuccessCheck(DefaultCallback successedCallback = null)
  {
    if( MultiLobbyStatus.userList == null )
    {
      if(successedCallback != null) successedCallback();
      yield break;
    }
    SendSyncData();

    while( true )
    {
      // ダイアログが出ていないときはインジケーターを回す
      if(!CommonWindow.Instance.IsActive && !CommonWindow.Instance.gameObject.GetComponent<Animation>().isPlaying && 
         !LoadingManager.Instance.IsPlaying) 
      {
        LoadingManager.Instance.PlayFromP2P();
      }

      bool compFlg = true;
      foreach(PhotonPlayer player in PhotonNetwork.playerList)
      {
        if( !success.Contains( int.Parse( player.name )))
        {
          compFlg = false;
          break;
        }
      }

      if(compFlg) {
        break;
      }
      yield return null;
    }

    LoadingManager.Instance.PauseFromP2P();

    if(successedCallback != null) {
      successedCallback();
    }
    success.Clear();

    yield break;
  }




つまりここ一転に集約されるわけだ
      if(compFlg) {
        break;
      }

上にさかのぼると
      bool compFlg = true;
      foreach(PhotonPlayer player in PhotonNetwork.playerList)
      {
        if( !success.Contains( int.Parse( player.name )))
        {
          compFlg = false;
          break;
        }
      }
最初はcompFlgはtrueなんだけど
plyerの中で一人でもsuccesがfalseなら同期が成功しない
そもそもsuccesってなんなんだ？

  //private static Hashtable hashTable;
  private static List<int> success = new List<int>();

ああはいはい、ただのリストか、つまりこのいやリストの中に
全てのプレイヤーがaddされてないとfalseになっちゃうのね
たぶん、あれか、条件を見たいしたマルチプレイヤーが
succesの中にａｄｄされるんだ
suucesにaddされるのは

  // 同期情報受信
  [PunRPC]
  public void ReceiveSyncData( int userId )
  {
    Debug.Log("ReceiveSyncData");
    success.Add( userId );
  }
のぶぶん

PhotonNetwork.playerListのすべて人間がsuccesにaddされないと
レースが始まらない
んんんん、でも、ReceiveSyncDataまでは呼ばれているはずなんだよな、少なくともｹﾞｽﾄは
ちょっとホスト見てみるか


考えられる状況としてはPlayerListの値がホストとゲストで食い違ってるとかあると思う
たぶんゲスト側は問題なくて、ホスト側が、ReceiveSyncDataが呼ばれていない
いやどうなんだろうな、お互いがお互いの自分のuserIdを送って
それをsuccesにaddしてるのか＋？？？










やはりホスト側か問題は
SendSyncDatanoログの後にこれ
１５６３行目
    private static bool VerifyCanUseNetwork()
    {
        if (connected)
        {
            return true;
        }

        Debug.LogError("Cannot send messages when not connected. Either connect to Photon OR use offline mode!");
        return false;
    }



    public static bool connected
    {
        get
        {
            if (offlineMode)
            {
                return true;
            }

            if (networkingPeer == null)
            {
                return false;
            }

            return !networkingPeer.IsInitialConnect && networkingPeer.State != PeerState.PeerCreated && networkingPeer.State != PeerState.Disconnected && networkingPeer.State != PeerState.Disconnecting && networkingPeer.State != PeerState.ConnectingToNameServer;
        }
    }




ここのどこかがfalseになることでconnecteしてないことにまってメッセージを送れないんだ
一体なにがあれなんだ








問題を切り出すとPhotonManagerの121行目SuccesCheckループでフリーズ、
その理由はホスト側のPhotonNetworkの
７０行目のconnectionがfalseを返しているから、だから一生進まないあ
エラーPhotonNetworkの1563行目、connectがfalseと言ってる


return !networkingPeer.IsInitialConnect &&
networkingPeer.State != PeerState.PeerCreated &&
 networkingPeer.State != PeerState.Disconnected && 
networkingPeer.State != PeerState.Disconnecting && 
networkingPeer.State != PeerState.ConnectingToNameServer;

まずIsInitialConnectはConnectUsingSettingsが呼ばれるとtrueになるから絶対に問題ない
んでPeerCreatedか
        

photonNetworkの1563行目

    private static bool VerifyCanUseNetwork()
    {
        if (connected)
        {
            return true;
        }

        Debug.LogError("Cannot send messages when not connected. Either connect to Photon OR use offline mode!");
        return false;
    }



俺の勘違いだった、全然できてなかった
またつながったと思ったのは、部屋にゲストがいたから、常いフォトンとつながってかろうじてつながっているように見えている
だけだったのだ、だけだったのだ、だけだったのだ
部屋に誰もいない状態で抜け出すと、完全にフォトンコネクションが切れる。


方法としてはあのフォトンのエラーが出ている時に、再び同じIDで部屋を作り直すことだ
そうだNwCmdLobbyDeleteのSucessいやMakeDataｆｒいいや、そこで、強制的に
InviteMultiRoom.Instance.InviteLobbyIdをリセットしよう
そして、InviteLobbyIdがまだ残っている場合には、Photonの作り直しを認めることにする
ところでInviteLobbyIdってどこで代入されてるんだっけ


ListでつくったロビーIDと消したロビーIDを管理しよう。
セーブデータではないIDのリストを作って、管理しよう
そんでListの中に再構築したいIDが残ってるのなら、
再構築しよう、Photonはいくらでも作り直せる
問題はサーバだ

と、そういうことが問題となると、もはやPhotonNetworkのFinish関連は全く気にしなくて
いいことになるな



まずNwCmdLobbyDeleteがExecCmdが呼ばれる箇所は４、５か所ある
のちのち全部追うことになるがそれはまあ置いといて
キッキンで大事なのはID指定で飛んだロビーが存在していないとき
想定してるのは起動直後のジャンプなので、この時点でlobbyIDリストには何も保存がされてない
そうすると、ちょっと前まで考えていた、デリートしてないロビーのリストにのっているものは
再構築だなんてそんな夢見物語なんて無理のまた無理だ
いったい何をもって、どうするか


とりあえずRaceMenu.(RaceMenuMulti?)のOnPhotonJoinRoomFailedから始まって
次にNwCmdMultiLobbyDeleteのExecCmdがついに呼ばれる



もう部屋が壊れてるから、部屋の情報は引き出せないわけですよ、ということはね
ローカルに部屋情報なんなりを保存しないといけないよね、よね
ただまあやっていいことと悪いことがあるよねタイミングてきに
”今”とジャンプＵＲＬを貼った瞬間とでチーム構成が変わってると大変困るわけですよ
そうすると


まずCreateMultiLobbyに必要なすべての変数あげつらってみる・・・・・・？

まあでも、実質ロビー作成に必要な変数３つだけじゃね？
いや待てよ、チームＩＤもなんか必要な気がしてきたぞ
チームＩＤと、そのチームＩＤの先頭馬３とうのＩＤも必要じゃねえか？
いやもっと言えばチームＩＤなんてどうでもいいんだ
現在選択している先頭３馬が、ロビークリエイトしたときの先頭３馬と一緒ならクリアだ





ほう、以外に整理されておるな。」。」。」。」。」
まあそれは置いといて、、一体いつPhotonのエラーが出るのか確認しなくては


    if ( OccurOnPhotonCreateRoomFailed )
    {
      object[] args = new object[2];
      args[0] = 10;
      args[1] = "debug";
      OnPhotonCreateRoomFailed(args);
      OccurOnPhotonCreateRoomFailed = false;
    }

ＲａｃｅＭｅｎｕＭｕｌｔｉの中でRoomFailedが当たると、そんなかでOnPhotonCreateRoomFailedやるんやなあ。。。。。
これってさ、

ああそうか・・・・・現状、ああそうか、、、、、、、


        //Equuivalent to TouchMultiSelectMain
        MultiLobbyStatus.multiType = MultiType.Host;


んんんんんんんんんんｎ、こんなのあったか、そうかあったか。

実際NwCmdLobbyCreateで返ってくるのはロビーＩＤだけで、こんなんじゃまともなレースはできない
やっぱりさ、いくつか、６つか、レースデータの保存が必要だ。。。。
と



とりあえずRaceIdがindexじゃなくそのまま



      StartCoroutine(MultiSystemStart(InHostSelect));

nなんかjockeyEventLoadermo
あるんやて

どっか抜けてるんだろうけどどこが抜けてるか全然わからん
そもそも、なんでゲストが来た瞬間に壊れるんだよ
わけわからん



multiplay_lobby_create
stage_id parameter error



かのうせいがあるのmultiConfirm周りの初期化かなあ
どっか抜けてるのかな

instanceMultiConfirm.CreateData(RaceData.ChapterName, RaceData.StageName, MultiLobbyStatus.multiType, TouchMultiConfirm);

    callback = cbMethod;
    multiType = type;
    LobbyKey = "----";
   
    instanceWindow = FindObjectOfType(typeof(LobbyPasswordWindow)) as LobbyPasswordWindow;
    if(instanceWindow == null) {
      instanceWindow = Instantiate(passwordWindow) as LobbyPasswordWindow;
    }
   
    bool isHost = (multiType == MultiType.Host);
    this.raceName.gameObject.SetActive(isHost);
    this.subRaceName.gameObject.SetActive(isHost);
    if(isHost) {
      this.raceName.Text = raceName;
      this.subRaceName.Text = subRaceName;
    }
   

    // 各チームの詳細情報を設定&表示
    base.UseTeamId = UserDataManager.Instance.GetUseTeam().id;
    
    Dictionary<int,NwDataTeamDetail> datas = UserDataManager.Instance.GetTeamDatas();
    base.teamNum = datas.Count;
    
    scrollList.ClearList(true);
    instanceMultiConfirmItems = new MultiConfirmItem[teamNum];
    
    for(int i = 1; i <= teamNum; i++) 
	{
      instanceMultiConfirmItems[i - 1] = Instantiate(multiConfirmItem) as MultiConfirmItem;
      instanceMultiConfirmItems[i - 1].SetData(i, teamNum, datas[i].horses, ShowCardDetail);
      scrollList.AddItem(instanceMultiConfirmItems[i - 1].gameObject);
    }





  public void TouchRankingEventSubRaceTitle( RaceSubListItem touchItem  )
  {
    //2014.11.29 設定されているBGMモードを取得
    int singleBgm=0,multiBgm=0;
    touchItem.GetBGM(ref singleBgm, ref multiBgm);
    RaceData.IsMultiBgm = isMulti;
    RaceData.SingleBgm = singleBgm;
    RaceData.MultiBgm = multiBgm;

    curStageId = touchItem.GetData().id;
    RaceData.StageName = touchItem.GetData().name;
    RaceData.SubTitle = touchItem.GetData().sub_title;
    RaceData.ConditionCategory = touchItem.GetData().condition_category;
    RaceData.ConditionType = touchItem.GetData().condition_type;
    RaceData.ConditionValue = touchItem.GetData().condition_value;
	RaceData.EntryPoint = touchItem.GetData().use_entry_point;
	RaceData.RoundNum = touchItem.GetData().max_battle_num;
    RaceData.Difficulty = touchItem.GetData().difficulty;
	RaceData.SpecialTermsId = touchItem.GetData ().special_terms_id;
	RaceData.SpecialTermsValue = touchItem.GetData ().special_terms_value;
	RaceData.UnuseBlock = touchItem.GetData ().unuse_block;
	TouchSubRaceTitle();
｝



 967行目   MultiLobbyStatus.lobbyKey = instanceMultiConfirm.LobbyKey;
//      MultiLobbyStatus.hostFormation = SaveData.GetFormation(UserDataManager.Instance.GetUseTeamId() - 1);
/

あ、ロビーキー、ロビーキー

  // メンバー受付中 画面へ
  void TouchLobbySelect(MultiLobbySelectItem lobbyItem) {
    MultiLobbyStatus.lobbyId = lobbyItem.GetData().lobby_id;
    NwCmdMultiGuestEntry cmd = NetworkManager.Instance.GetCmd<NwCmdMultiGuestEntry>();
    cmd.SetCallBack(() => {
      if(cmd.GetStatus() == "OK") {
        MultiLobbyStatus.hostFormation = lobbyItem.GetData().host_formation;
        TitleBoardManager.Instance.AddCallback(BackToLobbySelect); // <---戻り先
#if !OLD_MULTI
        JoinRoom();
#else
        InLobby(TouchLobbyCancel_Guest);
#endif
      } else {
        LoadingManager.Instance.Pause();
        AssertManager.Instance.SetInconsistentError(cmd, cmd.GetError().ToString());
      }
    },
    (err) => 
    {
      if(cmd.GetError() == NwCmdMultiGuestEntry.ErrorType.AlreadyEntry)
      {
        TouchLobbySelect_Already(lobbyItem);
      } 
      else 
      {
        LoadingManager.Instance.Pause();
        if(err == NetworkError.Inconsistent)
        {
          AssertManager.Instance.SetInconsistentError(cmd, cmd.GetError().ToString(), instanceLobbySelect.Research);
        } else 
        {
          AssertManager.Instance.SetConnectFailed(cmd, instanceLobbySelect.Research);
        }
     }
    });
    cmd.ExecCmd();
  }

ここ全般大事っぽいな。このhost_formationとか俺何も代入してなかったような。。。
        MultiLobbyStatus.hostFormation = lobbyItem.GetData().host_formation;
ロビーitemにhostformationの情報なんかあったっけ、これ私てあないこｍな
え、HostFormation上の一行でしか代入されてないじゃんどういうこと
ホストはどうやって情報渡してんの？？？


    base.SetStrParam("natinfo", MultiLobbyStatus.NatInfo_Type);


なんやこのNatInfoって


うーーんもしやいくつかのapi呼んでないか？？
    ReadyAnnounce();とか呼んでる＞



ん？？？？
この MultiMatchApi.csのNwCmdMultiMatchReadyCompleteCheckも
なんかそもそも読んでない気がするぞ


#region Common
  void Awake() {
#if OLD_MULTI
    MultiplayPlugin.InitQueue();
#endif
    MultiplayPluginObject_Base.debug_scene = P2PState.API;
    LHDebug.Log("multi api start");
//   LoadingManager.Instance.Play(true);
    IsError = false;
    Finish = false;
    if(MultiPlayManager.IsHost) {
      readyTimeOut = 0f;
      ReadyCompleteCheck();
    } else {
      MatchReadyCheck();
    }
  }




NwCmdMultiHostMatchStart
NwCmdMultiMatchDispose
NwCmdMultiMatchReadyAnnounce
NwCmdMultiMatchReadyCompleteCheck
NwCmdMultiMatchResultAnnounce
NwCmdMultiMatchResultCompleteCheck
NwCmdMultiMatchStartCompleteCheck
NwCmdMultiPostSubcaptain
NwCmdMultiRetry
たぶんこれらのapiなんも関係ないわ




 OperationResponse 226: ReturnCode: 32758 

Uv8


エラーのレスポンスでは上記notFoundやlobby id parameter errorなどの文字列で
判断してコモンウィンドウを表示しています。


Uv8eO14GY2VzYuBwkGwz


Uv8eOl4GY2VzYuBwkGwz





では、multiplay_invite_entryの場合、

code parameter error ⇒ codeのリクエストパラメータが空
database error ⇒ DB接続エラー
notFound  ⇒ ロビー情報が見つからない



ありがとうございます。では、multiplay_invite_messageの方は下記でお願い出来ますでしょうか。

lobby_id parameter error ⇒ lobby_idのリクエストパラメータが空
database error ⇒ DB接続エラー
kvs error ⇒ KVS接続エラー
lobbyNotFound ⇒ ロビー情報が見つからない
raceNotFound ⇒ レース情報が見つからない

Uv8e0l4GY2VzYuBwｋGwz
U

zeOAb_B_cC9JtwoUFefT






>>坂本さん
了解しました。
少し古い端末で問題がおきまして、ホストがロビー画面で招待ボタンを押してtwitterなどを外部起動したときに、
パズダビがサスペンドするだけでなくそのまま落ちてしまうということが100%の確率で起こりました。

ホスト側がこのアプリが落ちた状態から同じロビーIDの画面に復帰するには、ホスト側も自分で張り付けたURLを
タップしてジャンプする必要があります。（通常のマルチレースの遷移だと同じロビーには二度と入れないため）

これは少し不親切というか分かりにくい感じもしますので、
SNSの招待のウィンドウを起動してから、戻るボタンを押すまでの間にアプリが落ちた場合には、次回起動時に
URLを踏まなくても、そのcodeを使って同じ部屋のマルチロビーに即ジャンプするように実装しようと思っています。

現状20文字固定を想定してmessageから取り出して保存しているのですが、上司と相談したところ
あまり良い方法ではない気がするという話になりましたので、multiplay_invite_messageのapiで、
messageと一緒にcodeも返してくれるようにすることは可能でしょうか？

お手数ですがよろしくお願いします。





zeOAb_B_cC9JtwoUFefT


>>坂本さん
お疲れ様です。先週multiplay_invite_messageのレスポンスにcodeを追加していただきましたが、
SNSのウィンドウの「招待URLをコピー」ボタン用に、招待URL丸ごとを追加していただくことは可能でしょうか？

現在はローカルに保存した"http://stg.derby.pzga.jp/?pid=multi_invite&code="とcodeを組み合わせてますが、
よく考えるとrelease用のURLなどの問題もありまして、（また前回同様messageから取り出すのも不安要素が残るので）
サーバ側から直接もらった方が確実だろうという話になりました。
お手数ですがよろしくお願いします。


度々ありがとうございます、urlの方確認が取れました。引き続きよろしくお願いします。



とりあえず考えまとめないと何もできないぞ
どういうときにsavedataのあれをあれする訳？
まずすでにscheme情報がある場合うやんなくてもいい


やばい詰まった、サスペンドとアプリ初回起動の扱いを変えたいんだけど
どうすりゃいいんだ、いまだと判別つかない



zeOAb_B_cC9JtwoUFefT